<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>I/O流(二)</title>
      <link href="/2019/10/24/2019-10-24-IoLiu/"/>
      <url>/2019/10/24/2019-10-24-IoLiu/</url>
      
        <content type="html"><![CDATA[<h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><ol><li><p>基本概念<br>java.io.FileOutputStream类主要用于写入图像数据之类的原始字节流到输出流中。</p></li><li><p>常用的方法<br><code>FileOutputStream(String name)</code> - 根据参数指定的文件名来构造对象<br><code>FileOutputStream(String name, boolean append)</code> </p><pre><code>以追加的方式根据文件名构造对象  </code></pre><p><code>void write(int b)</code></p><pre><code>用于将参数指定的单个字节写入输出流  </code></pre><p><code>void write(byte[] b, int off, int len)</code></p><pre><code>用于将数组b中下标从off开始的len个字节写入输出流  </code></pre><p><code>void write(byte[] b)</code></p><pre><code>用于将数组b中所有字节写入输出流    //  String转换字节数组："Hello".getBytes()  </code></pre><p><code>void close()</code></p><pre><code>用于关闭流并释放有关的资源  </code></pre></li></ol><h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><ol><li><p>基本概念<br>java.io.FileInputStream类主要用于从输入流中读取图像数据之类的字节流 </p></li><li><p>常用的方法<br><code>FileInputStream(String name)</code>  根据参数指定的文件名来构造对象<br><code>int read()</code>   用于读取单个字节   </p><pre><code>若读取到文件末尾则返回-1，否则返回实际读到的数据内容  </code></pre><p><code>int read(byte[] b, int off, int len)</code> 数组转字符串 用于从输入流中读取len个字节的数据放入数组b中下标从off开始的位置   </p><pre><code>若读取到文件末尾则返回-1，否则返回实际读到的字节个数   </code></pre><p><code>int read(byte[] b)</code></p><pre><code>用于从输入流中读取b.length个字节的数据放入数组b中   </code></pre><p><code>int available()</code></p><pre><code>用于获取该输入流所关联文件的大小   </code></pre><p><code>void close()</code></p></li></ol><h3 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h3><ol><li><p>基本概念<br>java.io.DataOutputStream类用于将Java基本数据类型的变量写入输出流中。</p></li><li><p>常用的方法<br>DataOutputStream(OutputStream out) - 根据参数指定的引用构造对象。</p><pre><code>- 其中OutputStream类是个抽象类，实参需要传递子类的对象。            例；；；；；；；； DataOutputStream da=new DataOutputStream(                                                                                                 new FileOutputStream(地址))；</code></pre><p>void writeInt(int v) </p><pre><code>- 用于将参数指定的整数以4字节的方式写入输出流中，先写入高字节。- 127: 0000 0000   0000 0000   0000 0000   0111 1111          高               =&gt;                 低</code></pre><p>void close()</p><h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3></li><li><p>基本概念<br>java.io.DataInputStream类用于从输入流中读取Java基本数据类型的内容 </p></li><li><p>常用的方法<br>DataInputStream(InputStream in)  根据参数指定的引用来构造对象 </p><pre><code>其中InputStream类是个抽象类，实参需要传递子类的对象  </code></pre><p>int readInt() </p><pre><code>用于读取4个字节的整数数据并返回  </code></pre><p>void close() </p></li></ol><h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><ol><li><p>基本概念<br>java.io.ObjectOutputStream类主要用于将Java语言的对象整体写入输出流中<br>只能将支持 java.io.Serializable 接口的对象写入流中<br>类通过实现 java.io.Serializable 接口以启用其序列化功能<br>所谓序列化将一个对象所依赖的相关信息有效组织成字节序列的转化过程 </p></li><li><p>常用的方法<br>ObjectOutputStream(OutputStream out)   根据参数指定的引用来构造对象</p><pre><code>其中OutputStream类是个抽象类，实参需要传递子类的对象  </code></pre><p>void writeObject(Object obj) </p><pre><code>用于将参数指定的对象整体写入输出流中  </code></pre><p>void close()</p></li></ol><h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><ol><li><p>基本概念<br>java.io.ObjectInputStream类主要用于从输入流中读取一个对象整体  </p></li><li><p>常用的方法<br>ObjectInputStream(InputStream in)   根据参数指定的引用来构造对象  </p><pre><code>其中InputStream类是抽象类，实参需要传递子类的对象  </code></pre><p>Object readObject()   </p><pre><code>用于从输入流中读取一个对象并返回  无法通过返回值来判断是否读取到文件的末尾  </code></pre><p>void close()  </p></li></ol><p><strong>当需要将多个对象写入文件时，通常建议先将多个对象放入一个集合中，然后将该集合整体看做一个对象写入文件中，此时只需要从文件中读取一次就可以读出所有内容</strong>  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O流(一)</title>
      <link href="/2019/10/23/2019-10-23-IoLiu/"/>
      <url>/2019/10/23/2019-10-23-IoLiu/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><ol><li><p>基本概念<br>I/O就是Input/Output的简写，也就是输入/输出的含义<br>I/O流就是指像流水一样不间断地进行读写数据的状态  </p></li><li><p>基本分类<br>按照数据读写的单位不同分为：字节流 和 字符流<br>其中字节流主要指以字节为单位进行读写的过程，可以读写任意类型的文件<br>其中字符流主要指以字符(2个字节)为单位进行读写的过程，只能读写文本文件  </p><p>按照数据流动的方向不同分为：输入流 和 输出流(站在程序的角度)<br>其中输入流主要指从文件中读取数据内容输入到程序中<br>其中输出流主要指将程序中的数据内容输出到文件中，也就是写入文件  </p></li><li><p>基本框架<br>字节流的顶层父类：InputStream类 和 OutputStream类<br> InputStream类的常用子类：  </p><pre><code>FileInputStream类、DataInputStream类、ObjectInputStream类    </code></pre><p> OutputStream类的常用子类：  </p><pre><code>FileOutputStream类、  DataOutputStream类、  ObjectOutputStream类`</code></pre><p>字符流的顶层父类：Reader类  和  Writer类<br>Reader类的常用子类：  </p><pre><code>BufferedReader类、InputStreamReader类   </code></pre><p>Writer类的常用子类：  </p><pre><code>BufferedWriter类、  OutputStreamWriter类   </code></pre></li></ol><h3 id="部分常用方法"><a href="#部分常用方法" class="headerlink" title="部分常用方法"></a>部分常用方法</h3><p><strong>BufferedReader类</strong></p><ol><li><p>基本概念<br>java.io.BufferedReader类主要用于从输入流中读取单个字符、字符数组以及一行字符串</p></li><li><p>常用的方法<br><code>BufferedReader(Reader in)</code>   根据参数指定的引用构造对象 </p><pre><code>其中Reader类是个抽象类，实参需要传递子类的对象  </code></pre><p><code>int read()</code>   用于从输入流中读取单个字符    若读取到文件末尾则返回-1，否则返回实 际读取到的数据内容对应的整数值<br><code>int read(char[] cbuf, int off, int len)</code> </p><pre><code>用于从输入流中读取len个字符放入数组cbuf中下标从off开始的位置    若读取到文件末尾则返回-1，否则返回实际读取到的字符数  </code></pre><p><code>int read(char[] cbuf)</code></p><pre><code>用于从输入流中读取cbuf.length个字符到数组cbuf中    </code></pre><p><code>String readLine()</code></p><pre><code>用于从输入流中读取一行字符串内容。若读取到文件末尾则返回null        </code></pre><p><code>void close()</code>                       </p></li></ol><p><strong>PrintStream类</strong></p><ol><li><p>基本概念<br>java.io.PrintStream类主要用于实现各种数据的打印并自动刷新 </p></li><li><p>常用的方法<br><code>PrintStream(OutputStream out)</code>   根据参数指定的引用构造对象  </p><pre><code>- 其中OutputStream类是个抽象类，实参需要传递子类的对象   </code></pre><p><code>void print(String s)</code><br>用于打印参数指定的字符串内容<br><code>void println(String x)</code></p><pre><code>用于打印参数字符串后终止该行 </code></pre><p><code>void close()</code></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的异常机制</title>
      <link href="/2019/10/22/2019-10-22-Exception/"/>
      <url>/2019/10/22/2019-10-22-Exception/</url>
      
        <content type="html"><![CDATA[<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   异常就是”不正常”的含义，在Java语言中主要指运行阶段发生的错误,Java中错误有俩种：<br>   Error类主要描述比较严重通常无法编码解决的错误<br>   Exception类主要描述轻微可以编码解决的错误，如：0作为除数  </p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p>   java.lang.Exception类是所有异常的超类，具体分类如下：<br>       RuntimeException异常 - 运行时异常，也叫做非检测性异常<br>       IOException和其它异常 - 其他异常，也叫做检测性异常<br>             所谓检测性异常就是在编译阶段能够被编译器检测出来并给出提示的异常<br>   RuntimeException异常的主要子类：</p><ul><li>ArithmeticException - 算术异常</li><li>ArrayIndexOutOfBoundsException - 数组下标越界异常</li><li>NullPointerException - 空指针异常</li><li>ClassCastException - 类型转换异常</li><li>NumberFormatException - 数字格式异常</li></ul><p><strong>注意</strong>：<br>   当程序执行过程中发生异常又没有手动处理时，则由Java虚拟机采用默认方式处理，而默认处理方式：打印异常的名称、异常的原因、异常发生位置后终止程序，导致后续代码无法执行   </p><h3 id="异常的避免"><a href="#异常的避免" class="headerlink" title="异常的避免"></a>异常的避免</h3><p>   对于绝大多数的非检测性异常可以直接使用if条件判断来避免该异常的发生。</p><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><ol><li>语法格式<br>try{<br>   编写所有可能发生异常的语句；<br>}<br>catch(异常类型 变量名){<br>   编写针对该类异常处理的语句；<br>}<br>…<br>finally{<br>   编写无论是否发生异常都应该执行的语句；<br>}</li><li>注意事项<br>a.若需要多个catch分支时，切记小类型的异常放在大类型的前面。<br>b.懒人的写法：<pre><code>catch(Exception e){ ...}</code></pre>c.finally{}中的代码主要用于进行善后工作的处理，如：关闭打开的文件、删除文件等</li></ol><h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><ol><li><p>基本概念<br>在某些特殊场合中无法处理或不便于处理发生的异常，此时就需要将异常转移给该方法的调用者处理，这种方式就叫异常的抛出。</p></li><li><p>语法格式<br>访问控制符 返回值类型 方法名称(形参列表) throws 异常类型1,异常类型2,…{}</p></li><li><p>方法重写的原则<br>a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类。<br>b.要求方法权限不能变小，可以相同或变大。<br>c.要求不能抛出更大的异常。</p></li></ol><p><strong>注意</strong>：<br>   子类重写的方法可以抛出与父类一样的异常、更小的异常以及不抛出异常，但不能抛出更大的异常或平级不一样的异常。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li><p>基本概念<br>虽然Java官方提供了大量异常类但没有专门针对年龄不合理的异常类，若希望使用这种针对性的异常就需要程序员自己写一个异常类。</p></li><li><p>实现流程<br>a.自定义XXXException继承Exception或者其子类；<br>b.提供两个版本的构造方法：无参构造 和 字符串作为参数的构造；</p></li><li><p>异常对象的产生<br>throw new 异常类型();<br>如：<br>throw new NullPointerException(); - 表示产生空指针异常</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map集合简介</title>
      <link href="/2019/10/21/2019-10-21-Map-collection/"/>
      <url>/2019/10/21/2019-10-21-Map-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p><strong>基本概念</strong><br>   <code>java.util.Map&lt;K,V&gt;</code>接口中存放元素的基本单位是：单对元素 (键值对) </p><ul><li><p>K - 用于描述键(Key)的类型</p></li><li><p>V - 用于描述值(Value)的类型</p><p>该接口的主要实现类：HashMap类 和 TreeMap类<br>该接口中key(键)不允许重复，而且每个key(键)能且只能对应一个Value(值)  </p></li></ul><p><strong>常用方法</strong><br><code>V put(K key, V value)</code>   用于将key和value组成一对放入当前集合中  </p><ul><li><p>若实现增加功能则返回null；若实现修改功能则返回原来的value.    </p><p><code>boolean containsKey(Object key)</code></p><pre><code>用于判断当前集合中是否存在参数指定的key  </code></pre><p><code>boolean containsValue(Object value)</code> </p><pre><code>用于判断当前集合中是否存在参数指定的value   </code></pre><p><code>V get(Object key)</code></p><pre><code>用于根据参数指定的key返回对应的value，若key不存在则返回null  </code></pre><p><code>V remove(Object key)</code></p><pre><code>用于根据参数指定的key来删除键值对，返回该key对应的value    </code></pre><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></p><pre><code>用于将Map集合转换为Set集合，集合中的每个元素都是键值对  </code></pre><ul><li>其中Map.Entry是接口类型，常用方法有：  </li></ul><ul><li>K getKey()   用于获取键值对中的键 </li><li>V getValue()  用于获取键值对中的值</li></ul><p><code>Set&lt;K&gt; keySet()</code>  用于将Map集合中的所有键放入Set集合中并返回  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//Map集合各种方法的使用</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TestHashMap {</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">//1.声明Map类型的引用指向实现类的对象，形成多态</span><br><span class="line">Map&lt;String, String&gt; m1 = new HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">//2.向Map集合中添加元素并打印</span><br><span class="line">m1.put("1", "one");</span><br><span class="line">m1.put("2", "two");</span><br><span class="line">m1.put("3", "three");</span><br><span class="line">System.out.println("m1 = " + m1); //输出{1=one, 2=two, 3=three}</span><br><span class="line"> </span><br><span class="line">//3.查找Map集合中是否拥有指定的key以及指定的value并打印</span><br><span class="line">boolean b1 = m1.containsKey("4");</span><br><span class="line">System.out.println("b1 = " + b1); //false</span><br><span class="line">b1 = m1.containsKey("1");</span><br><span class="line">System.out.println("b1 = " + b1); //true</span><br><span class="line"></span><br><span class="line">b1 = m1.containsValue("eleven");</span><br><span class="line">System.out.println("b1 = " + b1); //false</span><br><span class="line">b1 = m1.containsValue("three");</span><br><span class="line">System.out.println("b1 = " + b1); //true</span><br><span class="line"></span><br><span class="line">System.out.println("--------------------------------------");</span><br><span class="line">//4.根据参数指定的key返回对应的value，若不存在则返回null</span><br><span class="line">String str1 = m1.get("5");</span><br><span class="line">System.out.println("str1 = " + str1); //null</span><br><span class="line">str1 = m1.get("2");</span><br><span class="line">System.out.println("str1 = " + str1); //two</span><br><span class="line"></span><br><span class="line">//5.实现集合中元素的删除</span><br><span class="line">String str2 = m1.remove("10");</span><br><span class="line">System.out.println("str2 = " + str2); //null</span><br><span class="line">System.out.println("m1 = " + m1); //{1=one, 2=two, 3=three}</span><br><span class="line"></span><br><span class="line">str2 = m1.remove("1");</span><br><span class="line">System.out.println("str2 = " + str2); //one</span><br><span class="line">System.out.println("m1 = " + m1); //{2=two, 3=three}</span><br><span class="line"></span><br><span class="line">//6.实现Map集合中所有元素的遍历</span><br><span class="line">//方式一：调用toString()方法可以实现遍历</span><br><span class="line">System.out.println("m1 = " + m1); //{2=two, 3=three}</span><br><span class="line"></span><br><span class="line">//方式二：调用entrySet()方法可以实现遍历</span><br><span class="line">//实现Map集合向Set集合的转换</span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; s1 = m1.entrySet();</span><br><span class="line">//使用for each结构来打印Set集合中的所有元素</span><br><span class="line">for(Map.Entry&lt;String,String&gt; me : s1){</span><br><span class="line">//System.out.println(me);</span><br><span class="line">System.out.println(me.getKey() + "=" + me.getValue());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//方式三：调用keySet()方法可以实现遍历</span><br><span class="line">//实现Map集合中所有的key转换为Set集合</span><br><span class="line">Set&lt;String&gt; s2 = m1.keySet();</span><br><span class="line">//使用for each结构打印Set集合中的所有元素</span><br><span class="line">for(String ts : s2){</span><br><span class="line">System.out.println(ts + "=" + m1.get(ts));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set集合简介</title>
      <link href="/2019/10/20/2019-10-20-Set-Collection/"/>
      <url>/2019/10/20/2019-10-20-Set-Collection/</url>
      
        <content type="html"><![CDATA[<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   java.util.Set接口是Collection接口的子接口，与List接口是平级关系<br>   该接口与List接口相比元素没有先后次序，并且不允许有重复的元素。无序且唯一<br>   该接口的主要实现类：HashSet类 和 TreeSet类<br>   其中HashSet类的底层是采用哈希表进行数据管理的<br>   其中TreeSet类的底层是采用有序二叉树进行数据管理的  </p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><p>   其实Set集合好多方法都是从Collection中继承过来的，所以常用方法参照Collection集合 </p><p>   <code>Iterator&lt;E&gt; iterator()</code>  获取当前集合中的迭代器对象，用于迭代/遍历集合中所有元素<br>   其中Iterator<e>是个接口，常用方法如下：<br>       <code>boolean hasNext()</code> 用于判断是否拥有可以访问的元素<br>      <code>E next()</code>  用于取出一个元素并指向下一个位置<br>      <code>void remove()</code>   用于将刚刚取出的元素删除  </e></p><p><strong>小知识—forEach循环</strong></p><ul><li>语法格式<br><code>for( 元素类型 变量名 : 集合/数组的名称){  循环体;}</code><ul><li>执行流程<br>不断地从集合/数组中取出一个元素赋值给变量后执行循环体，直到处理完毕所有元素为止</li></ul></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// Set集合常用方法使用</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TestSet {</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">// 1.声明Set接口的引用指向实现类的对象，形成了多态</span><br><span class="line">Set&lt;String&gt; s1 = new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">// 2.向集合中添加元素内容</span><br><span class="line">boolean b1 = s1.add("two");</span><br><span class="line">System.out.println("b1 = " + b1); // true</span><br><span class="line">System.out.println("s1 = " + s1); // [one, two]</span><br><span class="line">b1 = s1.add("one");</span><br><span class="line">System.out.println("b1 = " + b1); // true</span><br><span class="line">System.out.println("s1 = " + s1); // [one]</span><br><span class="line">b1 = s1.add("three");</span><br><span class="line">System.out.println("b1 = " + b1); // true</span><br><span class="line">System.out.println("s1 = " + s1); // [one, two, three]</span><br><span class="line">b1 = s1.add("one");</span><br><span class="line">System.out.println("b1 = " + b1); // false</span><br><span class="line">// 自动调用toString()方法，得到String类型的整体</span><br><span class="line">System.out.println("s1 = " + s1); // [one, two, three]</span><br><span class="line"></span><br><span class="line">System.out.println("-------------------------");</span><br><span class="line">// 3.使用迭代器来访问集合中的每个元素并打印出来</span><br><span class="line">// 3.1 获取迭代器对象并记录</span><br><span class="line">Iterator&lt;String&gt; it1 = s1.iterator();</span><br><span class="line">/*</span><br><span class="line">// 3.2 判断是否拥有可以访问的元素</span><br><span class="line">System.out.println(it1.hasNext()); // true</span><br><span class="line">// 3.3 取出该元素并并打印出来然后指向下一个位置</span><br><span class="line">System.out.println("获取到的元素是：" + it1.next()); // one</span><br><span class="line"></span><br><span class="line">// 3.2 判断是否拥有可以访问的元素</span><br><span class="line">System.out.println(it1.hasNext()); // true</span><br><span class="line">// 3.3 取出该元素并并打印出来然后指向下一个位置</span><br><span class="line">System.out.println("获取到的元素是：" + it1.next()); // two</span><br><span class="line">*/</span><br><span class="line">while(it1.hasNext()){</span><br><span class="line">System.out.println("获取到的元素是：" + it1.next()); //one two three</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//练习：使用StringBuilder类和迭代器实现toString()方法的打印效果</span><br><span class="line">StringBuilder sb1 = new StringBuilder();</span><br><span class="line">sb1.append("[");</span><br><span class="line">//重新获取迭代器，也就是让迭代器回到开头位置</span><br><span class="line">it1 = s1.iterator();</span><br><span class="line">//将集合中每个元素取出来拼接字符串</span><br><span class="line">while(it1.hasNext()){</span><br><span class="line">String str = it1.next();</span><br><span class="line">//若处理最后一个元素时，直接连接元素和]</span><br><span class="line">/*</span><br><span class="line">if(!it1.hasNext()){</span><br><span class="line">sb1.append(str).append("]");</span><br><span class="line">}else{</span><br><span class="line">sb1.append(str).append(",").append(" ");</span><br><span class="line">}</span><br><span class="line">*/</span><br><span class="line">if(it1.hasNext()){</span><br><span class="line">sb1.append(str).append(",").append(" ");</span><br><span class="line">}else{</span><br><span class="line">sb1.append(str).append("]");</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">//将最后一个元素后面的逗号和空格删除</span><br><span class="line">//sb1.delete(sb1.length()-2, sb1.length());</span><br><span class="line">//拼接最后的]</span><br><span class="line">//sb1.append("]");</span><br><span class="line">System.out.println("s1 = " + sb1);</span><br><span class="line"></span><br><span class="line">System.out.println("-------------------------");</span><br><span class="line">//4.实现集合中元素的删除操作</span><br><span class="line">System.out.println("s1 = " + s1); //[one, two, three]</span><br><span class="line">//使用迭代器获取集合中的每个元素并判断，若是"two"则删除否则打印即可</span><br><span class="line">//重新获取迭代器，也就是让迭代器回到开头位置</span><br><span class="line">it1 = s1.iterator();</span><br><span class="line">while(it1.hasNext()){</span><br><span class="line">//切记next()方法会取出元素的同时指向下一个位置</span><br><span class="line">/*</span><br><span class="line">if(it1.next().equals("two")){</span><br><span class="line">//调用迭代器的remove()方法可以删除元素</span><br><span class="line">it1.remove();</span><br><span class="line">}else{</span><br><span class="line">System.out.println(it1.next());</span><br><span class="line">}</span><br><span class="line">*/</span><br><span class="line">String str2 = it1.next();</span><br><span class="line">if("two".equals(str2)){</span><br><span class="line">//调用迭代器自己的remove()方法删除元素</span><br><span class="line">it1.remove();</span><br><span class="line">//调用Set集合自己的remove()方法删除元素</span><br><span class="line">//s1.remove(str2); //编译ok，运行产生异常</span><br><span class="line">}else{</span><br><span class="line">System.out.println(str2); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">System.out.println("-------------------------");</span><br><span class="line">System.out.println("删除之后的结果是：" + s1); //[one, three]</span><br><span class="line"></span><br><span class="line">System.out.println("-------------------------");</span><br><span class="line">//5.使用forEach循环来打印集合s1中的所有元素，推荐使用</span><br><span class="line">for(String ts : s1){</span><br><span class="line">System.out.println(ts);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">System.out.println("-------------------------");</span><br><span class="line">//使用forEach打印数组中的所有元素</span><br><span class="line">int[] arr = {11, 22, 33, 44, 55};</span><br><span class="line">for(int ti : arr){</span><br><span class="line">System.out.println(ti);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List集合简介</title>
      <link href="/2019/10/19/2019-10-19-List%20-Collection%20/"/>
      <url>/2019/10/19/2019-10-19-List%20-Collection%20/</url>
      
        <content type="html"><![CDATA[<h2 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection 集合"></a>Collection 集合</h2><p>在Java中 集合框架的顶层接口就是<code>java.util.Collection 和 java.util.Map</code><br> 其中Collection接口中存放元素的基本单位是：单个元素<br> 而Map接口中存放元素的基本单位是：单对元素  </p><p> 而我们今天学习的是List集合，它是Collection接口的子接口 ，其实我们开发中很少直接使用Collection接口，而是更多的使用该接口的子接口：List接口、Queue接口以及Set接口</p><p><strong>常用方法</strong><br> <code>boolean add(E e)</code> 用于将参数指定的元素e放入当前集合中<br>  <code>boolean addAll(Collection&lt;? extends E&gt; c)</code><br>        用于将参数集合c中的所有元素放入当前集合中<br>   <code>boolean contains(Object o)</code>用于判断当前集合是否包含参数指定的单个元素<br>  <code>boolean containsAll(Collection&lt;?&gt; c)</code><br>   用于判断是否包含参数c中的所有元素<br>   <code>boolean remove(Object o)</code>  用于将参数指定的单个元素从当前集合删除<br>   <code>boolean removeAll(Collection&lt;?&gt; c)</code><br>        用于删除参数集合中的所有元素<br>  <code>void clear()</code>用于清空当前集合中的所有元素<br>   <code>int size()</code>  用于获取集合中的元素个数<br>  <code>boolean isEmpty()</code>  用于判断当前集合是否为空<br>  <code>boolean retainAll(Collection&lt;?&gt; c)</code><br>        用于计算调用对象和参数对象的交集并保留到当前集合中，覆盖原有数据<br>     当前集合中的元素若发生改变则返回true，否则返回false</p><h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h2><p>   java.util.List接口是Collection接口的子接口<br>   该集合中的所有元素拥有先后放入次序，并且允许重复。 简称有序不唯一<br>   该集合的主要实现类由：ArrayList类、LinkedList类、Stack类<br>   其中ArrayList类的底层是采用动态数组实现的，因此访问元素方便，增删元素不方便<br>   其中LinkedList类的底层是采用链表实现的，因此访问元素不方便，增删元素方便<br>   其中Stack类的底层是采用动态数组实现的，该集合主要用于描述具有后进先出特性的数据结构，叫做栈(last in first out LIFO)  </p><p>   <strong>常用方法</strong><br>   <code>void add(int index, E element)</code><br>         用于将元素element插入到下标index的位置<br>   <code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>  用于将集合c中的所有元素插入到下标index的位置<br>  <code>E get(int index)</code><br>         用于根据参数index指定的下标获取对应的元素并返回<br>  <code>E remove(int index)</code><br>         用于根据参数index指定的下标位置来删除元素<br>   返回被删除的元素值<br>  <code>E set(int index, E element)</code><br>         用于将参数index指定下标位置的元素修改为element，返回修改之前的元素<br>   <code>List&lt;E&gt;subList(int fromIndex, int toIndex)</code><br>        用于获取子List，sublist获取的List与原List占有相同的存储空间，对子List的操作会影响到原List </p><p><strong>Java中的泛型机制</strong>  </p><p>通常情况下集合中允许存放各种不同类型的对象，此时这些对象都被看做Object类型放入，当集合中的这些数据被取出之后也是Object类型，为了表达数据的真实类型需要做强制类型转换，而强制类型转换很可能引发类型转换异常</p>所以泛型机制的出现，明确要求集合后跟&lt;数据类型&gt;，规范了该集合可以存放的类型   <p>集合 &lt;数据类型&gt; 变量名 = new 集合&lt;同前边的数据类型，可写可不写&gt;();</p><p>泛型的本质就是参数化类型，也就是让数据类型作为参数传递的方式，其中E相当于形式参数负责占位，当准备集合时&lt;&gt;中的数据类型相当于实际参数负责给形式参数E进行赋值，此时集合中所有E都被替换为实际参数类型，由于实际参数可以传递的类型非常广泛，因此得名”泛型”</p><!--数据类型--><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期日历类</title>
      <link href="/2019/10/18/2019-10-18-date/"/>
      <url>/2019/10/18/2019-10-18-date/</url>
      
        <content type="html"><![CDATA[<h2 id="日期相关的类"><a href="#日期相关的类" class="headerlink" title="日期相关的类"></a>日期相关的类</h2><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p><strong>基本概念</strong><br>   <code>java.util.Date</code>类用于描述特征的瞬间，可以精确到毫秒数</p><p><strong>常用的方法</strong></p><p>   <code>Date()</code> 使用无参的方式构造对象，默认采用当前系统时间来初始化<br>   <code>Date(long date)</code>  根据参数指定的毫秒数来构造对象。</p><ul><li>其中参数为距离1970年1月1日0时0分0秒以来的毫秒数  </li><li>1秒 = 1000毫秒</li></ul><ul><li><p>可File类中的方法搭配使用。  </p><p><code>long getTime()</code><br>用于获取当前调用对象距离1970年1月1日0时0分0秒的毫秒数<br><code>void setTime(long time)</code><br>用于设置当前调用对象的时间为距离1970年1月1日0时0分0秒的毫秒数。</p></li></ul><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p><strong>基本概念</strong><br><code>java.text.SimpleDateFormat</code>类主要用于实现日期和文本之间的转换  </p><p><strong>常用的方法</strong><br>   <code>SimpleDateFormat(String pattern)</code>  根据参数指定的模式来构造对象</p><ul><li>常用的模式有：y-年  M-月  d-日  H-时  m-分  s-秒  </li></ul><p><code>public final String format(Date date)</code><br>  用于实现Date类型向String类型的转换<br>   <code>Date parse(String source)</code><br>        用于实现String类型向Date类型的转换。</p><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p><strong>基本概念</strong><br>   <code>java.util.Calendar</code>类用于描述特定的瞬间，来取代Date类中的过时方法<br>   <em>该类是个抽象类，因此该类不能构造对象。</em></p><p><strong>常用的方法</strong><br>   <code>static Calendar getInstance()</code><br>        用于获取Calendar类型的引用并返回<br>   <code>void set(int year, int month, int date, int hourOfDay, int minute, int second)</code><br>        用于设置年月日时分秒信息<br>   <code>Date getTime()</code><br>        用于将Calendar类型的时间转换为Date类型的对象并返回</p><pre><code>一个小案例: 提示用户按照指定的格式输入生日信息，计算距离1970年1月1日的天数并打印出来    //1.提示用户按照指定的格式输入生日信息并使用变量记录      System.out.println("请输入您的生日信息(xxxx年xx月xx日)：");      Scanner sc = new Scanner(System.in);      String str = sc.next();      //2.根据用户输入的生日信息转换为距离1970年1月1日的天数并记录      SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日");      //实现字符串内容向Date类型的转换      Date d1 = sdf.parse(str);      System.out.println("根据用户输入的字符串转换的日期是：" + d1);      //获取距离1970年1月1日的毫秒数      long msec = d1.getTime();      System.out.println("距离1970年1月1日的毫秒数为：" + msec);      //转换为天数      long day = (msec/1000/3600+8)/24;      //3.打印最终的转换结果      System.out.println("距离1970年1月1日的天数为：" + day);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuffer,StringBuilder</title>
      <link href="/2019/10/17/2019-10-17-String%20StringBuilder%20StringBuffer/"/>
      <url>/2019/10/17/2019-10-17-String%20StringBuilder%20StringBuffer/</url>
      
        <content type="html"><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>String类用于描述字符串，Java程序中的所有字符串字面值都可以使用该类的实例/对象加以描述<br>String类描述的字符串内容是个常量，因此可以被共享<br>String类被<code>final</code>关键字修饰 表示不能被继承<br><strong>构造方法(常见的)</strong><br><code>String()</code>  使用无参方式构造对象得到空字符序列</p><p><code>String(byte[] bytes)</code>  使用bytes数组中的所有内容构造对象 </p><p><code>String(char[] value)</code>  使用value数组中的所有内容构造对象。</p><p><strong>成员方法(常见的)</strong></p><p><code>char charAt(int index)</code>  根据参数指定的下标返回对应的单个字符<br><code>boolean contains(CharSequence s)</code> 用于判断当前字符串是否包含参数指定的内容(参数传递接口类的引用，所以实参传递实现类的对象，<b>String类</b> 刚好实现了这个接口)<br><code>boolean endsWith(String suffix)</code>  判断当前字符串是否以参数指定的内容为结尾<br><code>boolean startsWith(String prefix)</code>判断当前字符串中是否以参数指定的内容为开头<br><code>String toLowerCase()</code> 用于将当前字符串中所有字符转换为小写<br><code>String toUpperCase()</code> 用于将当前字符串中所有字符转换为大写<br><code>String trim()</code> 用于去除当前字符串中两端的空白字符<br><code>boolean equals(Object anObject)</code> 用于比较字符串内容是否相等并返回；<br><code>String substring(int beginIndex)</code> 用于获取当前字符串中从beginIndex位置开始的子字符串并返回<br><code>String substring(int beginIndex, int endIndex)</code>  用于获取当前字符串中从beginIndex位置开始到endIndex结尾的子字符串并返回<br><code>int indexOf(int ch)</code> 用于返回当前字符串中参数ch指定的字符第一次出现的下标</p><h2 id="StringBuilder类-和-StringBuffer类"><a href="#StringBuilder类-和-StringBuffer类" class="headerlink" title="StringBuilder类 和 StringBuffer类"></a>StringBuilder类 和 StringBuffer类</h2><p>这俩个类方法一模一样，只不过StringBuilder单线程效率高，而StringBuffer多线程效率低<br>StringBuilder类 和 StringBuffer类的出现是为了弥补String类描述的字符串内容是个常量不可改变，所以 StringBuilder类 和 StringBuffer类可以直接修改字符串内容<br>String StringBuffer StringBuilder操作的数据类型相同，即字符串类型</p><p><strong>常用方法</strong>  </p><p><code>StringBuilder(String str)</code>  根据参数指定的字符串来构造对象<br><code>StringBuilder insert(int offset, String str)</code>用于将参数str代表的内容插入到当前字符串中下标为offset的位置上。</p><ul><li>返回当前对象的引用，也就是当前对象自己  </li></ul><p><code>StringBuilder append(String str)</code> 用于将参数str代表的内容追加到当前字符串的末尾<br><code>StringBuilder delete(int start, int end)</code>  用于将当前字符串中从start位置(含)开始到end位置(不含)结束之间的内容删除<br><code>StringBuilder deleteCharAt(int index)</code> 用于将当前字符串中下标为index位置的单个字符删除<br><code>StringBuilder replace(int start, int end, String str)</code>用于将当前字符串中从start位置到end位置之间的内容使用str替换掉<br><code>void setCharAt(int index, char ch)</code> 用于将当前字符串中下标为index位置的单个字符修改为参数ch的数值<br><code>int indexOf(String str)</code> 用于在当前字符串中查找参数str第一次出现的索引位置<br><code>StringBuilder reverse()</code> 用于实现字符串内容的反转</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2019/10/16/2019-10-16-abstractClass/"/>
      <url>/2019/10/16/2019-10-16-abstractClass/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类主要指不能具体实现的类，体现在该类不能实例化/构造对象并使用abstract修饰。  </p><p><strong>抽象方法</strong>  </p><p>抽象方法主要指不能具体实现的方法，体现在该方法没有方法体并使用abstract关键字修饰 </p><blockquote><p>public abstract void 方法名(); </p></blockquote><p><strong>注意事项</strong>  </p><ul><li>抽象类中可以有成员变量、成员方法以及构造方法。</li><li>抽象类中可以有抽象方法也可以没有。</li><li>拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并使用abstract<br>  关键字修饰的类才是真正意义上的抽象类  </li></ul><p><strong>意义</strong></p><p>抽象类的意义在于被继承而不是自身实例化对象，当一个类继承另一个类，必须重写抽象方法，否则自身也必须是抽象类，所以抽象类对子类具有规范性</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一种比抽象类还抽象的类，因此也不能实例化对象 定义接口的关键字是<code>interface</code>,实现接口的关键字是<code>implements</code>  </p><p><strong>抽象类和接口之间的区别</strong>  </p><ul><li>定义抽象类的关键字是class，而定义接口的关键字是interface。</li><li>继承抽象类的关键字是extends，而实现接口的关键字是implements。</li><li>继承抽象类支持单继承，而实现接口支持多实现。</li><li>抽象类中可以有构造方法，而接口中不可以有。</li><li>抽象类中可以有成员变量，而接口中只可以有常量。</li><li>抽象类中可以有成员方法，而接口中只可以有抽象方法。</li><li>抽象类中增加方法通常不影响子类，而接口中增加方法通常影响子类。</li><li>从jdk1.8开始允许接口中有非抽象方法，但需要使用default关键字修饰。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object Oriebted</title>
      <link href="/2019/10/15/2019-10-15-Object%20Oriented/"/>
      <url>/2019/10/15/2019-10-15-Object%20Oriented/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>为了防止给成员变量赋于一些合法但不合理的数值，对成员变量进行密封包装处理，来保证成员变量值的合理性，这种机制就叫封装</p><p>   <strong>封装的流程</strong></p><ul><li>私有化成员变量，使用private关键字修饰；</li><li>提供公有的get和set方法，在方法体中进行合理值的判断；</li><li>在构造方法中调用set方法进行合理值的判断；</li></ul><p><strong>封装好处</strong></p><ul><li>提高代码安全性（可维护性）</li><li>防止外部随意调用</li><li>降低了类于类之间的耦合度</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>当多个类中具有相同的特征和行为时，可以将共性的内容提取出来组成一个公共类，让多个类分别吸收公共类中已有的特征和行为，而在多个类的内部只需要编写自己独有特征和行为的机制就叫继承  <b>继承关键字extends</b></p><blockquote><p>注意: 其中被继承的类叫父类或者超类，或者基类<br> 继承的类叫子类或派生类<br> 一个父类可以有多个子类<br> 但是一个子类只能由一个父类</p></blockquote><p>其中可以继承的有 <em>父类中被public protected修饰的类成员</em><br>不能被继承的有 <em>父类的构造器和所有私有化的类成员</em><br>选择继承的有 <em>缺省修饰的类成员</em></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态主要指同一种事物表现出来的多种形态。<br>语法格式:  父类类型 引用变量名 = new 子类类型();  </p><p><strong>多态效果</strong><br>当父类引用指向子类对象时，父类引用可以直接调用父类独有的成员方法<br>当父类引用指向子类对象时，父类引用可以直接调用子类独有的成员方法<br>对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类版本；<br>对于父子类都有的静态成员方法来说，编译和运行阶段都调用父类版本；<br>     (静态成员隶属于类层级，与指向哪个对象无关)</p><p><strong>多态效果</strong><br>多态的实际意义在于屏蔽不同子类的差异性实现通用的编程带来不同的结果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象小知识</title>
      <link href="/2019/10/14/2019-10-14-object%20oriented/"/>
      <url>/2019/10/14/2019-10-14-object%20oriented/</url>
      
        <content type="html"><![CDATA[<p>周末午后，我正在愉快的打着王者荣耀，五杀在即之际。女朋友拿着一本我看过的《面向对象编程》过来找我。</p><p></p><ul><li>女朋友：什么是面向对象？是要面向我写代码吗？</li><li>我： 不是啦，这个面向对象的对象不是你这个对象啦。</li><li>此时，我突然感受到了一股莫名的杀气。</li><li>我：什么？你还有其他对象吗？有我好看吗？有我瘦吗？不对。你不能有其他对象。</li><li>什么是面向对象？</li></ul><blockquote><p>面向对象，英文名字叫Object Oriented，是一种软件开发方法。是和面向过程相对应的。</p></blockquote><ul><li><p>女朋友：别给我拽英文。给我详细说说，说不明白今天就没完。</p></li><li><p>我：我有点饿了，要不然你给我做点饭，我慢慢的详细给你讲吧。</p></li><li><p>女朋友：我现在就想听你给我讲，咱们直接点外卖吧，别自己动手做饭了。</p><p>其实，对于吃饭这件事儿，就可以分为面向过程吃饭和面向对象吃饭。自己亲自下厨就是面向过程，点外卖就是面向对象。</p><p>在面向过程的吃饭中，我们想要填饱肚子，需要自己亲自下厨把这顿饭做出来，那么，我们就需要先想好吃什么、然后去买菜、洗菜、洗米、蒸饭、炒菜等等一系列的事情。</p></li><li><p>我：那么，你说和点外卖相比，自己做饭有哪些缺点啊？</p></li><li><p>女朋友：那还用说，麻烦呗。</p></li><li><p>的确，面向过程编程也一样，由于想要完成做饭这件事，需要自己定义很多个方法。除此之外，还有很多遇到很多其他问题，比如：</p><ul><li>我不想吃米饭，我想吃馒头。</li><li>上次买的菜家里面还有，不需要去买菜。</li><li>中午吃剩下的菜家里面还有，直接热一热就可以吃了。</li><li>这次去的一家超市提供洗菜服务，不需要我们自己洗菜了。<p>以上这些突发事件，在编程中就叫做需求变更或者新的需求，这种事情发生是必然会发生的。</p></li></ul></li></ul><p></p><p>那么，有<strong>新的需求</strong>了怎么办？上面这种自己动手做饭的场景，就只能重新拼凑咯。</p><p>对于程序员来说，就需要通读代码，找出可以复用的方法，然后重新调用，不能复用的就重新写一个。时间久了，方法就会越来越多，系统维护越来越复杂。</p><p>面向对象，其实就是我们通过点外卖的方式来“做饭”。我们知道我们需要一顿饭，我们只需要打开外卖软件，在里面选择我们需要的菜品然后下单就可以了。我们不关心饭店做饭的过程。想吃什么点什么，家里来人了就再下一个订单，不想吃米饭了，想吃馒头了，也可以给饭店打电话，让他们把米饭换成馒头。</p><p>所以，通过面向对象的方式“做饭”，就像上面的代码一样。</p><ul><li>女朋友：哦，我明白了，面向对象就是把本来可能需要自己做的事情交给别人来做？对于我来说，外卖软件就是个对象，我再面向他“做饭”，其实是他帮我做的。</li><li>我：额、你说的也对，也不对。在这个场景中，确实可以把外卖软件当做是「对象」。其实，在面向对象编程中，抛弃了函数，想要实现一个功能不再是通过函数的叠加调用实现的了。而是通过对象。<br>对象就是对事物的一种抽象描述。现实世界中的事物，都可以用「数据」和「能力」来描述。</li></ul><blockquote><p>比如我要描述一个人，「数据」就是他的年龄、性别、身高体重，「能力」就是他能做什么工作，承担什么样的责任。</p></blockquote><blockquote><p>描述一个外卖软件，「数据」就是他包含的菜品，而「能力」就是他可以点菜。</p></blockquote><p><strong>什么是封装？</strong></p><blockquote><p>我们把「数据」和「能力」组合成一个对象的过程就叫做「封装」。</p></blockquote><blockquote><p>封装的结果就是可以有一个类，通过这个类我们可以获得一个对象。然后我们就可以通过给这个对象下命令，让他执行自己的「能力」。</p></blockquote><ul><li>女朋友：除了把「数据」和「能力」封装成一个「对象」更加方便使用以外，还有啥其他的特点么？<blockquote><p>封装只是面向对象的第一步，目的是把现实世界的东西抽象成对象。面向对象真正有威力的地方是「继承」和「多态」。</p></blockquote></li></ul><p>举一个不是很恰当，但是女朋友比较容易理解的例子。</p><p>我们使用外卖软件点餐，当我们第二次去某一家店时，外卖软件会提示你上一次你在这家点了什么，你可以点击&lt;再来一单&gt;把上次的菜品直接加到购物车中，这就是「继承」。而在购物车中的物品你可以直接付款下单，也可以把增删和修改菜品。这就是「多态」。<!--再来一单--></p><p><strong>什么是继承？</strong></p><blockquote><p>在面向对象编程中，当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类「继承」这个父类。继承后子类自动拥有了父类的部分属性和方法。</p></blockquote><p><code>通过继承创建的新类称为“子类”或“派生类”。</code></p><p><code>被继承的类称为“基类”、“父类”或“超类”。</code></p><p>比如：</p><p>上面的例子中，狗类 是父类，牧羊犬类 是子类。牧羊犬类 通过继承获得狗类的 吠() 的能力，同时增加了自己独有的 放羊() 的能力。转换成Java代码如下：</p><p><strong>什么是多态？</strong></p><blockquote><p>同一操作，作用于不同的对象，可以产生不同的结果，这就是「多态」。通常说的多态都是指运行期的多态，也叫动态绑定。</p></blockquote><p>要实现多态，需要满足三个条件：</p><p><strong>有类继承或接口实现、子类重写父类的方法、父类引用指向子类的对象。</strong> 比如：</p><p>狗和狼都是犬科动物，拉来一直犬科动物，如果它你叫的话，你可能没办法直接分辨出他到底是狼还是狗。只要他真正的叫出来的时候，你才知道。这就是运行时多态。转化成Java代码如下：</p><p>这样，就实现了多态，同样是Canidae的实例，canidae.bark调用的就是Dog类的方法，而canidae1.bark();调用的却是Wolf的方法。</p><p>有人说，你自己定义的对象，定义的时候不就知道canidae到底是什么类的对象了么，这个其实并不决定的，很多时候我们可能不知道，原因是，对象可能并不是我们自己new出来的，比如Spring的IOC。</p><ul><li>女朋友：奥，那我终于知道什么是面向对象编程了。</li><li>我：嗯，对了，外卖点好了么？</li><li>女朋友：呃…</li><li>我：那.. 咋不吃饭了</li><li>女朋友：不吃饭怎么行啊</li><li>我：吃你啊<p>画面不可描述中······</p> </li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>orcale,mysql,mongodb,redis对比</title>
      <link href="/2019/10/12/2019-10-12-ribao/"/>
      <url>/2019/10/12/2019-10-12-ribao/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL概述：</strong></p><blockquote><p>关系型数据库。无论数据还是索引都存放在硬盘中。到要使用的时候才交换到内存中。能够处理远超过内存总量的数据。</p></blockquote><blockquote><p>在不同的引擎上有不同 的存储方式。</p></blockquote><blockquote><p>查询语句是使用传统的 SQL 语句，拥有较为成熟的体系，成熟度很高。</p></blockquote><blockquote><p>开源数据库的份额在不断增加，MySQL 的份额页在持续增长。</p></blockquote><blockquote><p>缺点：在海量数据处理的时候效率会显著变慢。</p></blockquote><p><strong>MySQL特点：</strong></p><blockquote><ol><li>使用c和c++编写，并使用了多种编译器进行测试，保证源代码的可移植性</li></ol></blockquote><blockquote><ol start="2"><li>支持多种操作系统</li></ol></blockquote><blockquote><ol start="3"><li>为多种编程语言提供可API</li></ol></blockquote><blockquote><ol start="4"><li>支持多线程，充分利用CPU资源<br>优化的SQL查询算法，有效的提高查询速度</li></ol></blockquote><blockquote><ol start="5"><li>提供多语言支持，常见的编码如：GB2312、BIG5、UTF8</li></ol></blockquote><blockquote><ol start="6"><li>提供TCP/IP、ODBC和JDBC等多种数据库连接途径<br>提供用于管理、检查、优化数据库操作的管理工具</li></ol></blockquote><blockquote><ol start="7"><li>大型的数据库。可以处理拥有上千万条记录的大型数据库</li></ol></blockquote><blockquote><p>8.支持多种存储引擎</p></blockquote><blockquote><ol start="9"><li>MySQL软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库</li></ol></blockquote><blockquote><ol start="10"><li>MySQL使用标准的SQL数据语言形式</li></ol></blockquote><blockquote><ol start="11"><li>Mysql是可以定制的，采用GPL协议，你可以修改源码来开发自己的MySQL系统</li></ol></blockquote><blockquote><ol start="12"><li>在线DDL更改功能</li></ol></blockquote><blockquote><ol start="13"><li>复制全局事务标识</li></ol></blockquote><blockquote><ol start="14"><li>复制无崩溃从机</li></ol></blockquote><blockquote><p>15.复制多线程从机</p></blockquote><p><strong>MongoDB概述：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">它是一个内存数据库，数据都是放在内存里面的。</span><br><span class="line"></span><br><span class="line">对数据的操作大部分都在内存中，但 MongoDB 并不是单纯的内存数据库。</span><br><span class="line"></span><br><span class="line">MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的开源数据库系统。</span><br><span class="line"></span><br><span class="line">在高负载的情况下，添加更多的节点，可以保证服务器性能。</span><br><span class="line"></span><br><span class="line">MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</span><br></pre></td></tr></tbody></table></figure><blockquote><p>缺点：占用的空间很大</p></blockquote><p><strong>MongoDB特点：</strong></p><blockquote><ol><li>模式自由：可以把不同结构的文档存储在同一个数据库里</li></ol></blockquote><blockquote><ol start="2"><li>面向集合的存储：适合存储JSON风格文件的形式</li></ol></blockquote><blockquote><ol start="3"><li>完整的索引支持，对任何属性可索引</li></ol></blockquote><blockquote><ol start="4"><li>复制和高可用性：支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目的是提供冗余及自动故障转移</li></ol></blockquote><blockquote><ol start="5"><li>自动分片：支持水平的数据库集群，可动态添加额外的机器</li></ol></blockquote><blockquote><p>6.丰富的查询：支持丰富的查询表达方式，查询指令使用JSON形式额标记，可轻易查询文档中的内嵌的对象及数组</p></blockquote><blockquote><ol start="7"><li>快速就地更新：查询优化器会分析查询表达式，并生成一个高效的查询计划</li></ol></blockquote><blockquote><p>8.高效的传统存储方式：支持二进制数据及大型对象</p></blockquote><p><strong>Redis：</strong></p><blockquote><p>它就是一个不折不扣的内存数据库。</p></blockquote><blockquote><p>持久化方式：Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。</p></blockquote><p><strong>Redis特点：</strong></p><blockquote><ol><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li></ol></blockquote><blockquote><ol start="2"><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，在set，hash等数据结构的存储。</li></ol></blockquote><blockquote><ol start="3"><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ol></blockquote><blockquote><ol start="4"><li>性能极高- Redis能读的速度是110000次/s，写的速度是81000次/s</li></ol></blockquote><blockquote><ol start="5"><li>丰富的数据类型-Redis支持二进制案例的Strings,Lists,Hashes,Setes及Ordered Sets数据类型操作。</li></ol></blockquote><blockquote><ol start="6"><li>原子 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ol></blockquote><blockquote><ol start="7"><li>丰富的特性 - Redis还支持publish/subscribe,通知，key过期等等特性。</li></ol></blockquote><p><strong>数据量和性能的比较：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当物理内存够用的时候，Redis &gt; MongoDB &gt; MySQL</span><br><span class="line"></span><br><span class="line">当物理内存不够用的时候，Redis 和 MongoDB 都会使用虚拟内存。</span><br><span class="line"></span><br><span class="line">实际上如果Redis要开始虚拟内存，那很明显要么加内存条，要么你就该换个数据库了。</span><br><span class="line"></span><br><span class="line">但是，MongoDB 不一样，只要，业务上能保证，冷热数据的读写比，使得热数据在物理内存中，mmap 的交换较少。</span><br><span class="line"></span><br><span class="line">MongoDB 还是能够保证性能。有人使用 MongoDB 存储了上T的数据。</span><br><span class="line"></span><br><span class="line">MySQL，MySQL根本就不需要担心数据量跟内存下的关系。不过，内存的量跟热数据的关系会极大地影响性能表现。</span><br><span class="line"></span><br><span class="line">当物理内存和虚拟内存都不够用的时候，估计除了 MySQL 你没什么好选择了。</span><br><span class="line"></span><br><span class="line">其实，从数据存储原理来看，我更倾向于将 MongoDB 归类为硬盘数据库，但是使用了 mmap 作为加速的手段而已。</span><br></pre></td></tr></tbody></table></figure><p><strong>使用场景的不同：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、MongoDB适用于：</span><br><span class="line"></span><br><span class="line">①网站数据：适合实时的插入，更新与查询，并具备网站实时数据存储所需对的复制及高度伸缩性；</span><br><span class="line"></span><br><span class="line">②缓存：由于性能很高，也适合作为信息基础设施的缓存层，在系统重启之后，搭建的持久化缓存可以避免下层的数据源过载；</span><br><span class="line"></span><br><span class="line">③大尺寸、低价值的数据也是MongoDB的最佳选择，使用传统的关系数据库存储一些数据时可能会比较贵，再次之前很多程序员往往会选择传统的文件进行存储</span><br><span class="line"></span><br><span class="line">④高伸缩的场景，非常是个由数十或者数百台服务器组成的数据库</span><br><span class="line"></span><br><span class="line">⑤用于对象及json数据的存储，MongoDB的bson数据格式非常适合文档格式化的存储及查询。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2、而mysql还是更加适用于：</span><br><span class="line"></span><br><span class="line">①高度事务性的系统。例如银行或者会计系统，传统的关系型数据库目前还是更实用于需要大量原子性复杂事务的应用程序</span><br><span class="line"></span><br><span class="line">②传统的商业智能应用，针对特定问题的BI数据库会对产生高度优化的查询方式，对于此类应用，数据仓库可能是更合适的选择</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3、Redis应用场景：</span><br><span class="line"></span><br><span class="line">①用来做缓存-redis的所有数据时放在内存中的</span><br><span class="line"></span><br><span class="line">②可以在某些特定应用场景下替代传统数据库--比如社交类的应用</span><br><span class="line"></span><br><span class="line">③在一些大型系统中，巧妙的实现一些特定的功能：session共享、购物车</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql碎片整理优化</title>
      <link href="/2019/10/11/2019-10-11-ribao/"/>
      <url>/2019/10/11/2019-10-11-ribao/</url>
      
        <content type="html"><![CDATA[<p><strong>MysqL碎片整理优化</strong></p><p>先来说一下什么是碎片，怎么知道碎片有多大！</p><blockquote><p>简单的说,删除数据必然会在数据文件中造成不连续的空白空间,而当插入数据时,这些空白空间则会被利用起来.于是造成了数据的存储位置不连续,以及物理存储顺序与理论上的排序顺序不同,这种是数据碎片.实际上数据碎片分为两种,一种是单行数据碎片,另一种是多行数据碎片.前者的意思就是一行数据,被分成N个片段,存储在N个位置.后者的就是多行数据并未按照逻辑上的顺序排列.当有大量的删除和插入操作时,必然会产生很多未使用的空白空间,这些空间就是多出来的额外空间.索引也是文件数据,所以也会产生索引碎片,理由同上,大概就是顺序紊乱的问题.Engine 不同,OPTIMIZE 的操作也不一样的,MyISAM 因为索引和数据是分开的,所以 OPTIMIZE 可以整理数据文件,并重排索引。这样不但会浪费空间，并且查询速度也更慢。</p></blockquote><blockquote><p>解决方案：（切记，一定要在夜里执行，表越大，越耗资源时间，不要频繁修复，可以几个月甚至一年修复一次，如果表频繁被更改，可以按周/月来整理。）</p></blockquote><p><strong>查看表碎片的方法</strong><br><code>select ROW_FORMAT,TABLE_ROWS,DATA_LENGTH,INDEX_LENGTH,MAX_DATA_LENGTH,DATA_FREE,ENGINE from TABLES where TABLE_SCHEMA='test_db' and TABLE_NAME='table_name' limit 1;</code></p><blockquote><p>通过<code>OPTIMIZE TABLE　table_name</code>后再查询一下</p></blockquote><blockquote><p>也可以观察Mysql的数据目录存储文件Data文件大小，如MYD</p></blockquote><p>一、Innodb存储引擎清理碎片方法</p><p><code>ALTER TABLE tablename ENGINE=InnoDB</code></p><p>二、Myisam存储引擎清理碎片方法</p><blockquote><p>OPTIMIZE 操作会暂时锁住表,而且数据量越大,耗费的时间也越长,它毕竟不是简单查询操作.所以把 Optimize 命令放在程序中是不妥当的,不管设置的命中率多低,当访问量增大的时候,整体命中率也会上升,这样肯定会对程序的运行效率造成很大影响.比较好的方式就是做个 Script,定期检查mysql中 information_schema.TABLES字段,查看 DATA_FREE 字段,大于0话,就表示有碎片.脚本多长时间运行一次,可以根据实际情况来定,比如每周跑一次.</p></blockquote><p><code>OPTIMIZE TABLE table_name</code> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql简单整理</title>
      <link href="/2019/10/10/2019-10-10-ribao/"/>
      <url>/2019/10/10/2019-10-10-ribao/</url>
      
        <content type="html"><![CDATA[<ol><li><p>windows键+r启动小黑框，输入 <code>mysql -u用户名 p密码</code>，会出现WELCOME to MYSQL 等字眼</p></li><li><p>我们经常用小黑框查询以及测试数据是否正常：<br> 首先看看有没有数据库，或者创建数据库</p><p>查看数据库: <code>SHOW DATABASES</code>; </p></li></ol><p>2.或者如果没有你想选择的数据库，你可以创建一个数据库</p><p><code>CREATE DATABASE IF NOT EXISTS</code>数据库名;</p><p>记住数据库名后要写分号’;’</p><p>选取创建的数据库 ： USE 数据库名;</p><p>创建数据表：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE IF NOT EXISTS 表名(</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; name VARCHAR(255) UNIQUE, -- 如果你想让你的字段名的值是唯一值的话就加上UNIQUE，否则就去掉</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp;age TINYINT UNSIGNED NOT NULL DEFAULT 1,&nbsp; -- 默认值请为1， UNSIGNED 字段值不能有符号</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp;sex TINYINNT UNSIGNED NOT NULL&nbsp;</span><br><span class="line"></span><br><span class="line">)ENGINE = InnoDB DEFAULT CHARSET = UTF8;</span><br></pre></td></tr></tbody></table></figure><p>增加数据:<code>INSERT INTO 表名(id,字段2，字段N。。) VALUES(NULL,'张三',12,1);</code></p><p>查询数据: <code>SELECT id,nam,age,sex FROM 表名; ||  SELECT id,name,age,sex FROM WHERE id=N；</code></p><p>修改数据: <code>UPDATE 表名 SET 修改的字段名 WHERE  id=N；</code></p><p>删除数据：</p><p><strong>删除数据之前先添加一条数据免得表是空的</strong></p><p>  <code>INSERT INTO 表名(id,字段2，字段N。。) VALUES(NULL,'张三',12,1);</code></p><p>ok,简单的增删改查就ok了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2019/10/09/2019-10-9-ribao/"/>
      <url>/2019/10/09/2019-10-9-ribao/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB操作命令"><a href="#MongoDB操作命令" class="headerlink" title="MongoDB操作命令"></a>MongoDB操作命令</h1><h2 id="Mongo简介"><a href="#Mongo简介" class="headerlink" title="Mongo简介"></a>Mongo简介</h2><p>属于非关系型数据库，是分布式文档数据库。<br>特点：扩展灵活、结构灵活、使用方便、支持查询、索引。<br>不足：缺乏事务控制，无法保障数据完整性。</p><p>oracle存储结构</p><p><img src="https://i.imgur.com/iGIiT2H.png" alt=""></p><p>mongodb存储结构</p><p><img src="https://i.imgur.com/03lOJQN.png" alt=""></p><h2 id="Mongo命令"><a href="#Mongo命令" class="headerlink" title="Mongo命令"></a>Mongo命令</h2><ol><li><p>库命令</p><ul><li><p>查看</p><pre><code>show dbs</code></pre></li><li><p>使用</p><pre><code>use 库名称</code></pre></li><li><p>创建</p><pre><code>use 库名称  //库存在就是使用；不存在就创建再使用</code></pre></li><li><p>删除</p><pre><code>db.dropDatabase() //删除当前use的库</code></pre></li></ul></li><li><p>集合</p><ul><li><p>查看</p><pre><code>show collections</code></pre></li><li><p>创建</p><pre><code>当使用"db.集合名.insert()"插入数据时，集合不存在时会自动创建</code></pre></li><li><p>删除</p><pre><code>db.集合名.drop()</code></pre></li></ul></li><li><p>数据操作</p><ul><li><p>插入</p><p>  插入单条记录</p><pre><code>db.dept.insert({"no":1,"dname":"beijing"})</code></pre><p>  插入多条记录</p><pre><code>var objs = [{"no":3,"dname":"chengdu"},{"no":4,"dname":"shenyang"}];db.dept.insert(objs)</code></pre><p>  或</p><pre><code>for(var i=1;i&lt;10;i++){ db.dept.insert({"no":10+i,"dname":"bj"+i});}</code></pre></li><li><p>删除</p><p>  删除单条记录</p><pre><code>db.dept.remove({"no":1})</code></pre><p>  删除所有记录</p><pre><code>db.dept.remove({})</code></pre></li><li><p>修改</p><p>  全部更新覆盖</p><pre><code>db.dept.update({"no":1},{"dname":"shanghai"})</code></pre><p>  部分更新</p><pre><code>db.dept.update(条件json对象,{$set:要更新的json对象})//示例db.dept.update({"no":1},{$set:{"dname":"chengdu"}})</code></pre></li><li><p>查询</p><p>  $gt、$lt、$gte、$lte、$ne等</p><p>  查询所有记录</p><pre><code>db.dept.find()</code></pre><p>  查询某条记录，no=1的记录</p><pre><code>db.dept.find({"no":1})</code></pre><p>  查询条件记录，no&gt;1的记录</p><pre><code>db.dept.find({"no":{$gt:1}})db.dept.find({"no":{$gte:1}})</code></pre><p>  排序</p><pre><code>db.dept.find().sort({"no":1})</code></pre><p>  1表示升序、-1表示降序</p><p>  分页</p><pre><code>//跳过begin条，然后抓取记录db.dept.find().skip(begin).limit(记录数)</code></pre></li><li><p>统计</p><p>  统计所有记录数量</p><pre><code>db.dept.count()</code></pre><p>  统计满足条件记录数</p><pre><code>db.dept.count({"no":11})db.dept.count({"no":{$gt:10}})</code></pre></li></ul></li></ol><h1 id="Java访问MongoDB"><a href="#Java访问MongoDB" class="headerlink" title="Java访问MongoDB"></a>Java访问MongoDB</h1><pre><code>驱动包：mongo-java-driver-2.13.2.jar</code></pre><ol><li><p>原生方式</p><ul><li><p>引入mongo-java-driver-2.13.2.jar驱动包</p></li><li><p>建立连接</p><pre><code>MongoClient mongo = new MongoClient("localhost");//操作mongo.close();关闭连接</code></pre></li><li><p>获取库和集合信息</p><pre><code>MongoClient mongo = new MongoClient("localhost");List&lt;String&gt; dbs = mongo.getDatabaseNames();//show dbs 查看所有库名DB db = mongo.getDB("java11");//use java11 获取库对象//db.getCollectionNames();//show collections 查看集合名</code></pre></li><li><p>插入记录</p><pre><code>MongoClient mongo = new MongoClient("localhost");DB db = mongo.getDB("java11");DBCollection dept = db.getCollection("dept");DBObject arr = new BasicDBObject();arr.put("no", 10);arr.put("dname", "beijing1");dept.insert(arr);//db.dept.insert({"no":10,"dname":"beijing1"})mongo.close();</code></pre></li><li><p>更新记录</p><pre><code>MongoClient mongo = new MongoClient("localhost");DB db = mongo.getDB("java11");DBCollection dept = db.getCollection("dept");DBObject q = new BasicDBObject();q.put("no", 10);DBObject o = new BasicDBObject();DBObject n = new BasicDBObject();n.put("dname", "北京");o.put("$set", n);//db.dept.update({"no":10},{$set:{"dname":"北京"}})dept.update(q, o);mongo.close();</code></pre></li><li><p>查询记录</p><pre><code>MongoClient mongo = new MongoClient("localhost");DB db = mongo.getDB("java11");//use java11 获取库对象DBCollection dept = db.getCollection("dept");//获取dept集合对象DBCursor cursor = dept.find();//db.dept.find() 查询所有记录while(cursor.hasNext()){    DBObject obj = cursor.next();    Object no = obj.get("no");    Object dname = obj.get("dname");    System.out.println("no="+no+" dname="+dname);}mongo.close();</code></pre></li></ul></li><li><p>spring-data-mongodb方式（Spring框架）</p><p> 利用MongoTemplate对象进行MongoDB操作。</p></li></ol><pre><code>- 导入下列jar包，注意版本匹配，容易产生冲突。    - mongo-java-driver-2.13.2.jar    - spring-data-mongodb-1.4.2.RELEASE.jar    - spring-data-commons-1.7.2.RELEASE.jar    - slf4j-api-1.5.8.jar    - slf4j-log4j12-1.5.8.jar    - log4j-1.2.12.jar- 追加Spring配置，创建MongoTemplate对象        &lt;!-- 追加mongo命名空间，定义Factory --&gt;        &lt;mongo:db-factory id="mongoFactory"             host="localhost" port="27017" dbname="java11"/&gt;        &lt;!-- 创建MongoTemplate --&gt;        &lt;bean id="mongoTemplate"             class="org.springframework.data.mongodb.core.MongoTemplate"&gt;            &lt;constructor-arg index="0" ref="mongoFactory"&gt;            &lt;/constructor-arg&gt;        &lt;/bean&gt;- 测试Template应用        @RunWith(SpringJUnit4ClassRunner.class)        @ContextConfiguration(locations={"classpath:spring-mongo.xml"})        public class TestMongoTemplate {            @Resource            private MongoTemplate mongoTemplate;            @Test//测试添加            public void test1(){                System.out.println(mongoTemplate);                User user = new User();                user.setId(20);                user.setName("tiger");                user.setPassword("123456");                mongoTemplate.save(user);//默认集合名user            }            @Test//测试查询所有记录            public void test2(){                List&lt;User&gt; list = mongoTemplate.findAll(User.class);//默认查user集合                for(User user:list){                    System.out.println(user.getId()+" "+user.getName()+" "+user.getPassword());                }            }            @Test//测试按条件查询记录            public void test3(){                Query query = new Query(Criteria.where("id").is(10));                User user = mongoTemplate.findOne(                    query,User.class);                System.out.println(user.getId()+" "+user.getName()+" "+user.getPassword());            }        }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/10/08/2019-10-8-ribao/"/>
      <url>/2019/10/08/2019-10-8-ribao/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p> 目的：利用Redis做数据缓存,缓存查询出来的对象数据。</p><p> NoSQL：Not Only SQL，非关系数据库。</p><p> 关系型数据库指的是表结构存储，典型Oracle、MySQL、DB2。</p><ul><li>key-value存储 : 典型Redis</li><li>列存储 ： HBase</li><li>文档存储 : MongoDB</li><li>图形存户：Neo4j</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Redis是基于内存的数据库，常用于缓存</li><li>Redis是采用C语言编写</li><li>Redis是采用Key-value结构存储</li><li>Redis中value值支持存储类型为字符串、哈希、列表、集合、可排序集合</li><li>Redis支持高速读写操作，效率高</li><li>Redis支持持久化、按一定策略将内存数据异步保存到磁盘</li><li>Redis支持事务控制、消息传递等功能</li></ul><h2 id="各种类型数据存储命令"><a href="#各种类型数据存储命令" class="headerlink" title="各种类型数据存储命令"></a>各种类型数据存储命令</h2><ol><li><p>字符串操作（string）</p><p> <img src="https://i.imgur.com/9sJtYCB.png" alt=""></p><ul><li>set key value  //存一组key value</li><li>mset key value key value //存多组key value</li><li>get key //获取value</li><li>strlen key //获取value字符长度</li><li>incr key //将value加1</li><li>incrby key number //将value加number</li><li>decr key //将value减1</li><li>decrby key number //将value减number</li><li>append key value1 //将value拼接value1</li></ul></li><li><p>key操作</p><ul><li>keys *  //查看有哪些key</li><li>del key //删除key</li><li>expire key n  //设置key有效期为n秒</li><li>rename key newkey //修改key名字</li><li>type key //返回value值得类型</li><li>exists key //判断key是否存在</li></ul></li></ol><ol start="3"><li><p>哈希操作 (hashmap)</p><p> <img src="https://i.imgur.com/3ROwSOy.png" alt=""></p><ul><li>hset key 字段名 字段值  //设置一个字段名和字段值</li><li>hmset key 字段名1 字段值1 字段名2 字段值2 //设置多个</li><li>hget key 字段名 //获取一个字段值</li><li>hmget key 字段名1 字段名2 //获取多个字段值</li><li>hlen key  //获取字段数量</li><li>hkeys key //获取字段名</li><li>hdel key 字段名 //删除某个字段</li></ul></li></ol><ol start="4"><li><p>列表操作 (list)</p><p> <img src="https://i.imgur.com/ZGLumMQ.png" alt=""></p><ul><li>lpush key value //在列表头部插入一个元素</li><li>rpush key value //在列表尾部插入一个元素</li><li>lrange key 0 -1 //获取列表所有元素</li><li>llen key //获取列表元素数量</li><li>lrem key count value //删除列表指定数量的元素</li><li>lset key index value //更新某个索引位置的元素</li><li>lindex key index //获取指定索引位置的元素</li><li>lpop key //删除列表头部第一个元素</li><li>rpop key //删除列表尾部最后一个元素</li><li>linsert key BEFROE|AFTER value newvalue //在列表value元素前或后插入newvalue值</li></ul></li><li><p>集合操作 (set)</p><p> A = {1,3,5}</p><p> B = {3,5,7,9}</p><p> A交B = {3,5}</p><p> A并B = {1,3,5,7,9}</p><p> A差B = {1}</p><p> B差A = {7,9}</p><ul><li>sadd key value value //向集合存数据</li><li>smembers key //获取集合所有元素</li><li>scard key //获取集合元素数量</li><li>srem key value //删除value元素</li><li>spop key //随机删除一个元素</li><li>srandmember key n //随机返回n个元素</li><li>sdiff key1 key2 //key1和key2集合的差集</li><li>sinter key1 key2 //key1和key2集合交集</li><li>sunion key1 key2 //key1和key2集合并集</li><li>sdiffstore key key1 key2 //key1和key2集合的差集,结果存放到key集合中   </li></ul></li></ol><ol start="6"><li><p>有序集合操作</p><p> 排序规则：给每个元素配一个double分值，按分值排序，默认由小到大排序。</p><ul><li>zadd key score value score value //添加元素</li><li>zcard key //获取元素数量</li><li>zrange key 0 n //获取指定索引范围的元素,0 -1表示所有元素(由小到大排序)。</li><li>zrevrange key 0 n//根据score由大到小排序,获取指定索引的元素</li><li>zrem key value //删除某个元素</li><li>zscore key value //返回元素的分值</li><li>zrank key value //获取元素索引位置(由小到大排序)</li><li>zrevrank key value //获取元素索引位置（由大到小排序）</li><li>zcount key min max //统计分值在min和max之间的元素数量</li></ul></li></ol><ol start="7"><li>其他</li></ol><h2 id="Java如何操作Redis存取数据"><a href="#Java如何操作Redis存取数据" class="headerlink" title="Java如何操作Redis存取数据"></a>Java如何操作Redis存取数据</h2><p>连接Redis</p><pre><code>@Test//测试连接public void test1(){    Jedis jedis = new Jedis("localhost");    System.out.println(jedis.ping());}</code></pre><p>字符串写操作</p><pre><code>public void test2_1(){    long i = 10000L;    Jedis jedis = new Jedis("localhost");    jedis.set("i", i+"");    jedis.set("msg1", "Hello Redis");    jedis.set("msg2".getBytes(), "你好 Redis".getBytes());    jedis.close();}</code></pre><p>字符串读操作</p><pre><code>public void test2_2(){    Jedis jedis = new Jedis("localhost");    String str = jedis.get("msg1");    byte[] bts = jedis.get("msg2".getBytes());    long i = Long.parseLong(jedis.get("i"));    String str2 = new String(bts);    System.out.println(str);    System.out.println(str2);    jedis.close();}</code></pre><p><strong>其他类型存取操作请参考课上示例代码</strong></p><h2 id="Java如何利用Redis做缓存"><a href="#Java如何利用Redis做缓存" class="headerlink" title="Java如何利用Redis做缓存"></a>Java如何利用Redis做缓存</h2><ol><li><p>对象存取方案</p><ul><li>将Java对象转成json字符串然后写入redis，取值时将json串转成Java对象</li></ul></li></ol><pre><code>        @Test//写对象        public void test1(){            User user = new User();            user.setId(10);            user.setName("scott");            user.setPassword("123");            //写对象            Jedis jedis = new Jedis("localhost");            Gson gson = new Gson();            String s = gson.toJson(user);            jedis.set("user_"+user.getId(), s);            jedis.close();        }        @Test//读对象        public void test2(){            int id = 10;            Jedis jedis = new Jedis("localhost");            String s = jedis.get("user_"+id);            Gson gson = new Gson();            User user = gson.fromJson(s, User.class);            System.out.println(user.getId()+" "+user.getName());            jedis.close();        }- 将Java对象序列化成字节数组然后写入redis，取值时反序列化成Java对象        @Test//写对象        public void test3(){            User user = new User();            user.setId(10);            user.setName("scott");            user.setPassword("123");            //写对象            Jedis jedis = new Jedis("localhost");            //序列化            byte[] value = SerializableUtil.serialize(user);            jedis.set("user_10".getBytes(), value);            jedis.close();        }        @Test//读对象        public void test4(){            int id = 10;            String key = "user_"+id;            Jedis jedis = new Jedis("localhost");            byte[] value = jedis.get(key.getBytes());            //反序列化            User user = (User)SerializableUtil.unserialize(value);            System.out.println(user.getId()+" "+user.getName()+" "+user.getPassword());            jedis.close();        }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 10月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28日日报</title>
      <link href="/2019/09/28/2019-9-28-ribao-md/"/>
      <url>/2019/09/28/2019-9-28-ribao-md/</url>
      
        <content type="html"><![CDATA[<p>今天搞了一天的博客和git，我的电脑出了问题，怎么也连不上git</p><p>于是我想到了用hexo部署至git，还可以加一个可爱的看板娘</p><p>说干就干，我尝试百度了好多，终于安装好了hexo及其需要的环境</p><p>博客是搭好了，可是出了乱码，原因是我的.md文件编码不是utf-8，于是乎我 关闭虚拟机，在win10上进行操作,最终干掉了疑难</p><p>OK!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建国70周年观后感</title>
      <link href="/2019/09/27/2019-9-27-xinde/"/>
      <url>/2019/09/27/2019-9-27-xinde/</url>
      
        <content type="html"><![CDATA[<p>在这个蓝色的、富有生命的星球中，在世界这片广阔的地域里，有一只雄鸡它巍然屹立在亚洲的海陆之中，它——就是中国!</p><p>中国历史古老而又文明，中国文化更是源远流长,是信念，也是希望</p><p>我很高兴我是中国人，我的祖先被万代国人传诵。中国人民坚强刚毅，无论在任何困难面前都不会退缩，他们会坚持下去，克服眼前的所有困难</p><p>我们是跨世纪的一代新人，我们的今天就是祖国的明天，我们肩负着振兴国家，是国家更加繁荣富强的重任，所以我们更要努力的学习，学习真知识，掌握真本领，我们心中，伟大的祖国时时刻刻在激励着我们，给我们以勇气，给我们以力量</p><p>望着祖国日新月异、日渐富强的景象，我骄傲，因为我有一颗中国心;望着国外那一台台印着“中国制造”字样的电视、电脑，我骄傲，因为我有一颗中国心;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库(4)</title>
      <link href="/2019/09/26/2019-9-26-datebasekey/"/>
      <url>/2019/09/26/2019-9-26-datebasekey/</url>
      
        <content type="html"><![CDATA[<p>约束   constraint </p><p>   概念 </p><p>  当数据进入 数据库表中时,数据库管理系统 可以通过加在字段上 约束 限制来对数据进行<br>    检查 符合检查条件的数据才能进入数据库的表。</p><p>  约束的种类 </p><p>   主键约束       primary  key      pk<br>       如果对一个字段加了主键约束 则 这个字段的取值 必须不能为空 并且 值 不能<br>        重复。一张表只能有一个主键。<br>    唯一性约束    unique           uk<br>        如果对一个字段加了唯一性约束 则这个字段的值 不能重复<br>    非空约束       not  null        nn<br>        字段的值不能为空<br>     检查约束     check             ck<br>         字段的值必须符合检查条件<br>     外键约束     foreign  key      fk<br>            references   </p><p>  约束的实现方式 </p><p>   列级约束实现 : 在定义表的某一列时 直接在这一列后面加约束限制  </p><p>   表级约束实现: 在定义完表的所有列之后  再选择某些列加约束限制。</p><p>   主键的列级约束实现</p><p>   create  table  column_cons(<br>       id    number   primary key,<br>       name  varchar2(30),<br>       salary  number<br>   );<br>   insert into  column_cons values(1,’t1’,12312);<br>   ERROR at line 1:<br>   ORA-00001: unique constraint (SYSTEM.SYS_C007123) violated<br>   SYSTEM.SYS_C007123  这代表约束的名字  系统默认提供一个不重复的<br>   约束名  但不方便记忆 和 对数据的维护。</p><p>   建立约束时 给约束起名字 </p><p>   名字构成 是  表名_字段名_约束简称<br>   drop    table  column_cons;<br>   create  table  column_cons(<br>       id    number  constraint  column_cons_id_pk primary key,<br>       name  varchar2(30),<br>       salary  number<br>   );<br>   insert into  column_cons values(1,’t1’,12312);<br>   ERROR at line 1:<br>ORA-00001: unique constraint (SYSTEM.COLUMN_CONS_ID_PK) violated<br>```</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库(3)</title>
      <link href="/2019/09/25/2019-9-25-data/"/>
      <url>/2019/09/25/2019-9-25-data/</url>
      
        <content type="html"><![CDATA[<p>** 日期类型 **</p><h5 id="1-日期类型的默认表现"><a href="#1-日期类型的默认表现" class="headerlink" title="1.日期类型的默认表现"></a>1.日期类型的默认表现</h5><pre><code>&gt; dd-MON-yy      select  id,start_date from  s_emp;</code></pre> <p>按照入职日期排序 显示  id  first_name start_date</p>    &gt; select  id,first_name,start_date from s_emp order by start_date;<h5 id="2-使用-to-char-来改变显示的格式"><a href="#2-使用-to-char-来改变显示的格式" class="headerlink" title="2.使用 to_char 来改变显示的格式"></a>2.使用 to_char 来改变显示的格式</h5><pre><code>&lt;p&gt;新的日期格式:&lt;/p&gt;</code></pre><p>    yyyy     四位年</p><p>    mm       两位月</p><p>    dd       天</p><p>    hh       12小时制 </p><p>    hh24     24小时制</p> <p>    mi       分钟 </p><p>    ss       秒 </p> <p>    day      星期几 </p><p>    MON      英文月的缩写</p> <p>    month    英文月的全写 </p><p>    pm       上午 显示成 am  下午显示成pm</p><blockquote><p>select  id,first_name,to_char(start_date,’yyyy-mm-dd hh24:mi:ss MON pm’)<br>       from s_emp order by start_date;</p></blockquote><blockquote><p>select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss day pm’) from dual; </p></blockquote><h5 id="3-日期数据的插入"><a href="#3-日期数据的插入" class="headerlink" title="3. 日期数据的插入"></a>3. 日期数据的插入</h5><blockquote><p>sysdate   可以代表 当前的时间点 </p></blockquote>   <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   过去和 未来的时间 如何处理? </span><br><span class="line">   2008-08-08 20:08:10 </span><br><span class="line">   2090-08-08 08:10:25</span><br><span class="line">   dd-MON-yy  只能放入 年月日 时分秒 默认是 零 </span><br><span class="line">   ``` </span><br><span class="line">   &gt; to_date(par1,par2)  par1 是要处理的日期字符串  par2 是日期格式字符串 </span><br><span class="line">      能把日期字符串 根据日期格式转换成 日期数据 </span><br><span class="line"> </span><br><span class="line">``` </span><br><span class="line">   insert  into  myemp values(5,'test','test','08-AUG-08');</span><br><span class="line">   commit;</span><br><span class="line">   select  id,to_char(sdate,'yyyy-mm-dd hh24:mi:ss') from myemp;</span><br><span class="line">   insert  into  myemp values(6,'test','test',</span><br><span class="line">      to_date('2008-08-08 20:08:10','yyyy-mm-dd hh24:mi:ss'));</span><br><span class="line">   commit;</span><br><span class="line">   insert  into  myemp values(7,'test','test',</span><br><span class="line">      to_date('2090-08-08 08:10:25','yyyy-mm-dd hh24:mi:ss'));</span><br><span class="line">   commit;</span><br><span class="line">```   </span><br><span class="line">##### 4. 日期调整 </span><br><span class="line">     &gt; 先调整  秒  分钟  小时  天   默认以天为单位</span><br></pre></td></tr></tbody></table></figure><p>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(sysdate+1,’yyyy-mm-dd hh24:mi:ss’) from dual;<br>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(sysdate-2,’yyyy-mm-dd hh24:mi:ss’) from dual;<br>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(sysdate+10/(24*60),’yyyy-mm-dd hh24:mi:ss’) from dual;</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; add_months(par1,par2)  par1 要处理的日期   par2 几个月 正数负数都可以</span><br></pre></td></tr></tbody></table></figure><p>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(add_months(sysdate,2),’yyyy-mm-dd hh24:mi:ss’) from dual;    </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; trunc(par1,par2) par1 是要处理的日期   par2处理的精度  默认是天 </span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">select  to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),</span><br><span class="line"> to_char(trunc(sysdate),'yyyy-mm-dd hh24:mi:ss') from dual;     </span><br><span class="line">select  to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),</span><br><span class="line"> to_char(trunc(sysdate,'mm'),'yyyy-mm-dd hh24:mi:ss') from dual; </span><br><span class="line">select  to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),</span><br><span class="line"> to_char(trunc(add_months(sysdate,-1),'mm'),'yyyy-mm-dd hh24:mi:ss')</span><br><span class="line"> from dual;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库(2)</title>
      <link href="/2019/09/24/2019-9-24-study_select/"/>
      <url>/2019/09/24/2019-9-24-study_select/</url>
      
        <content type="html"><![CDATA[<p> 表连接</p><pre><code>内连接         等值连接     员工和部门       部门和地区                非等值连接   员工的工资 和 对应的工资级别        自连接          谁是领导? 外连接        等值连接     员工和部门 (找出没有部门的员工)      部门和地区 (没有地区编号的部门)                非等值连接   员工的工资 和 对应的工资级别  (超出统计范围的工资)        自连接          谁是普通员工?  外连接的结果集 等于 内连接的结果集  加上匹配不上的记录         如何实现的?  (+)   (+)的意思所在字段的对面的表的数据全部被匹配出来         本质上 底层是通过 NULL 记录进行的匹配</code></pre><p>   SQL99 内外连接</p><pre><code>内连接标准  from  a表  join b表  on 连接条件  where 过滤条件; from  a表  inner join b表  on 连接条件  where 过滤条件;       显示 每个部门的名字 和 对应的地区的名字    select  d.name,r.name      from  s_dept d,s_region r          where  d.region_id = r.id; select  d.name,r.name      from  s_dept d  join s_region r          on  d.region_id = r.id; select  d.name,r.name      from  s_dept d  inner  join s_region r          on  d.region_id = r.id; 外连接的标准 a表  left outer  join  b 表  on 表的连接条件   where  过滤条件; a表  right outer  join  b 表  on 表的连接条件   where  过滤条件; a表  full  outer  join  b 表  on 表的连接条件  where  过滤条件;  a表  left outer  join  b 表  就是a表发起连接  意思就是a表的数据全部被匹配出来。 a表  right outer  join b 表  就是b表发起连接  意思就是 b表的数据全部被匹配出来。       本质上也通过 NULL 记录进行的匹配       显示每个部门的名字  和 对应的地区的名字  没有地区编号的部门也要显示    select d.id, d.name,r.name      from  s_dept  d,s_region r           where  d.region_id = r.id(+);      select d.id, d.name,r.name      from  s_dept  d left outer  join s_region r           on  d.region_id = r.id;   select d.id, d.name,r.name      from  s_region r  right outer  join  s_dept  d          on  d.region_id = r.id;                 使用左外连接  实现 s_emp 谁是普通员工的问题 显示  id  first_name            谁是领导?40   谁是普通员工 40   改成 left outer  join  20    select distinct m.id,m.first_name        from  s_emp  e,s_emp m             where  e.manager_id(+) = m.id and e.manager_id is null;           select distinct m.id,m.first_name        from  s_emp  m  left outer join s_emp e             on  e.manager_id = m.id where e.manager_id is null;  select distinct m.id,m.first_name        from  s_emp  m  left  join s_emp e             on  e.manager_id = m.id where e.manager_id is null;  full outer join          全外连接 只是一个逻辑概念，代表左外连接的结果集 加上 右外连接的结果集 然后 排除重复的记录。  Oracle 中如何实现全外连接呢? 不是通过两端都加(+) 实现的。         而是通过  union    来实现的 union 的意思是 合并两个结果集  然后排重。  union  all  合并两个结果集  不排重。  select  id from  s_emp  union    select id from s_emp;  select  id from  s_emp  union  all   select id from s_emp;    </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库(1)</title>
      <link href="/2019/09/23/2019-9-23-stuey-select/"/>
      <url>/2019/09/23/2019-9-23-stuey-select/</url>
      
        <content type="html"><![CDATA[<p>** 内连接 **<br>      </p><p>内连接的特点就是 符合连接条件的数据 被选中  不符合连接条件的数据被过滤掉。</p><br>      <p>上面的  等值连接    非等值连接   自连接 都是内连接。</p><br>** 外连接 **<br>   <p>外连接的结果集 等于 内连接的结果集  加上 匹配不上的记录(一个也不能少)</p>  <p></p> <p> (+)  (+) 所在的表的字段 对面的表的数据全部被匹配出来               底层通过 NULL 记录匹配出来的  </p>  &gt;select distinct m.id,m.first_name from  s_emp  e,s_emp m  where e.manager_id(+) = m.id and  e.manager_id is null;<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">练习   s_emp   s_dept </span><br><span class="line">     显示每个员工的id, first_name  和 对应的 部门名(name)</span><br><span class="line">    select  e.id,first_name,name</span><br><span class="line">        from  s_emp e,s_dept d</span><br><span class="line">            where  e.dept_id=d.id; </span><br><span class="line">     公司为了业务发展 需要抽调一部分人出来  这些人将离开原来的部门 </span><br><span class="line">  update  s_emp  set dept_id = null where id &lt; 3;</span><br><span class="line">  commit; </span><br><span class="line">     显示每个员工的id, first_name  和 对应的 部门名(name)  没有部门编号的员工也要显示 </span><br><span class="line">  select  e.id,first_name,name</span><br><span class="line">        from  s_emp e,s_dept d</span><br><span class="line">            where  e.dept_id=d.id(+);   </span><br><span class="line"></span><br><span class="line">练习   s_dept     s_region</span><br><span class="line">   显示每个部门的名字  和 对应的地区的名字</span><br><span class="line"> select d.id, d.name,r.name</span><br><span class="line">      from  s_dept  d,s_region r </span><br><span class="line">          where  d.region_id = r.id;</span><br><span class="line"> 公司业务扩大了  增加了一些新的部门 </span><br><span class="line"> insert  into  s_dept  values(100,'test100',NULL);</span><br><span class="line"> insert  into  s_dept  values(101,'test101',NULL);</span><br><span class="line"> commit;                      </span><br><span class="line"> 显示每个部门的名字  和 对应的地区的名字  没有地区编号的部门也要显示  </span><br><span class="line">  select d.id, d.name,r.name</span><br><span class="line">      from  s_dept  d,s_region r </span><br><span class="line">          where  d.region_id = r.id(+);          </span><br><span class="line">  非等值连接的外连接    salgrade   s_emp </span><br><span class="line">   列出每个员工的 id  salary  和  salary 对应的工资级别</span><br><span class="line"> select id,salary,grade</span><br><span class="line">      from  s_emp,salgrade </span><br><span class="line">          where salary  between  losal and hisal;</span><br><span class="line"> 把 id = 25  和 id=24 的这两个人的工资 改成 12345</span><br><span class="line"> update  s_emp  set  salary=12345 where id &gt;= 24;</span><br><span class="line"> commit;</span><br><span class="line"> 列出每个员工的 id  salary  和  salary 对应的工资级别  超出统计范围的员工也要显示 </span><br><span class="line"> select id,salary,grade</span><br><span class="line">      from  s_emp,salgrade </span><br><span class="line">          where salary  between  losal(+) and hisal(+);</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22日日报</title>
      <link href="/2019/09/22/2019-9-22-windows/"/>
      <url>/2019/09/22/2019-9-22-windows/</url>
      
        <content type="html"><![CDATA[<p><strong>终于我还是败给了deepin</strong></p><p>今天又安回了win10系统,因为我Linux下安装数据库安装了好长时间</p><p>于是我自闭了，安回了win10。看见熟悉的画面，emmm.... 还是windows看着舒服</p><p>今天安装各种软件安装了好长时间,所以学习时间就少了好多</p><p>但是这并不是我不努力的理由,所以只有更努力的学习了嘛</p><p>you can</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/09/20/2019-9-20-jvm/"/>
      <url>/2019/09/20/2019-9-20-jvm/</url>
      
        <content type="html"><![CDATA[<p><strong>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</strong></p><p>Java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。   Java虚拟机本质是就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。</p>   <p>Java虚拟机不仅是一种跨平台的语言，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种API、优化技术等。Java技术使同一种应用可以运行在不同的平台上。Java平台可分为两部分，即Java虚拟机（Java virtual machine，JVM）和Java API类库。</p>   <p>Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块   Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据，这样做的目的就是为了保持Java虚拟机的指令集尽量的紧凑，同时也便于JAVA虚拟机在那些只有很少通用寄存器的平台上实现</p>   <p>   对于Java运行时涉及到的存储区域主要包括程序计数器、Java虚拟机栈、本地方法栈、java堆、方法区以及直接内存等等．   程序计数器主要是取下一条指令，在Java里面主要是取下一条指令的字节码文件；Java虚拟机栈主要是利用栈先进后出的特性存储局部变量表，动态链接等，主要包括堆内存和栈内存，对于程序员内存分析而言是特别重要的。本地方法栈与上边的栈基本作用差不多，只不过这里是为Java方法而服务。Java堆是内存管理中最大的一块，所有的线程共享这一块内容，同时该部分也是垃圾收集器的主要区域   </p>   <p>   虚拟机的垃圾回收机制是完善的，动态内存分配和回收是比较成熟的，一般的对于内存回收首先就是判断某一个部分是生存还是死亡，主要是通过下面二种算法：                                  <br>其一是引用计数算法:该算法实现简单，判定的效率也比较高，但是它难以处理对象之间相互调用的问题   <br>其二是称可达性分析算法，该算法核心思想是依靠判断对象是否存活来实现的，本算法是通过一系列的GC ROOTS的对象作为起始点，采用搜索的算法遍历引用链，如果搜索过程中没有发现该节点，则认为该节点是不可达的，即可回收的   </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兄弟会感悟</title>
      <link href="/2019/09/19/2019-9-19-ganwu/"/>
      <url>/2019/09/19/2019-9-19-ganwu/</url>
      
        <content type="html"><![CDATA[<p>时间如白马过隙，悄然而逝，但是自从我来到兄弟会，不仅学到了好多东西，而且认识了这么多可以帮得到我的兄弟萌，有辛苦，有欢乐</p><p>当然，我们兄弟会成立之初，我们也有过迷茫，我们也想过兄弟会是否能给我们以进步(emmm...),但是小明告诉我，我们其实学到了很多，比如自己的学习能力，解决问题的能力，知识覆盖面，尤其是我们很少主动问别人问题了(当然不能不会还憋着不问)</p><p>到现在，教练们的辛苦负责，组长们的热情多助，学员们的心得分享，已让我的生活变得充实，每天都有自己能学到的东西。迷茫，彷徨自然就随风而散了。每天的充实生活已让我陶醉，每天的学习也让我进步</p><p>所以呀，考虑一千次，不如去做一次；犹豫一万次，不如实践一次；华丽的跌倒，胜过无谓的彷徨，将来的你，一定会感谢现在奋斗的你</p><p>小明说:所有成功的背后，都是苦苦堆积的坚持；所有人前的风光，都是背后傻傻的不放弃，那么我们也要紧追他的步伐</p><p>so,加油啊少年</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动vue时报错</title>
      <link href="/2019/09/17/2019-9-17-dsb.md/"/>
      <url>/2019/09/17/2019-9-17-dsb.md/</url>
      
        <content type="html"><![CDATA[<p>✘ 1 problem (1 error, 0 warnings)</p><p>Errors:<br>  1  <a href="http://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener">http://eslint.org/docs/rules/no-trailing-spaces</a></p><p>  ✘  <a href="http://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener">http://eslint.org/docs/rules/no-trailing-spaces</a>  Trailing spaces not allowed<br>  src/components/HelloWorld.vue:6:1</p><p>   ^</p><p>  ✘  <a href="http://eslint.org/docs/rules/eol-last" target="_blank" rel="noopener">http://eslint.org/docs/rules/eol-last</a>            Newline required at end of file but not found<br>  src/components/HelloWorld.vue:16:10<br>  </p><p>✘ 2 problems (2 errors, 0 warnings)</p><p>Errors:<br>  1  <a href="http://eslint.org/docs/rules/eol-last" target="_blank" rel="noopener">http://eslint.org/docs/rules/eol-last</a><br>  1  <a href="http://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener">http://eslint.org/docs/rules/no-trailing-spaces</a></p><p>You may use special comments to disable some warnings.<br>Use // eslint-disable-next-line to ignore the next line.<br>Use /* eslint-disable */ to ignore all warnings in a file.</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><p>在 my-project/config/index.js里有配置:</p><blockquote><p>useEslint: true, // 改为false即可。</p></blockquote><p>然后重新执行   cnpm run dev</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17日日报</title>
      <link href="/2019/09/17/2019-9-17-ribao/"/>
      <url>/2019/09/17/2019-9-17-ribao/</url>
      
        <content type="html"><![CDATA[<br><p><strong>今天又是学习Vue的一天</strong></p><p>有在很努力学习vue的呢</p><p>emmm... 今天还进行了3个js的学习</p><p>但是我只学会了一个(手动狗头)</p><p>不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多</p><p>10年后的你肯定会感谢现在努力的自己</p><p>you can</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue.js安装</title>
      <link href="/2019/09/16/2019-9-16-dsaf-day/"/>
      <url>/2019/09/16/2019-9-16-dsaf-day/</url>
      
        <content type="html"><![CDATA[<h3 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1. 独立版本"></a>1. 独立版本<br></h3><p>我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="2-使用-CDN-方法"><a href="#2-使用-CDN-方法" class="headerlink" title="2. 使用 CDN 方法"></a>2. 使用 CDN 方法<br></h3><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p><blockquote><p>Staticfile CDN（国内） : <a href="https://cdn.staticfile.org/vue/2.2.2/vue.min.js" target="_blank" rel="noopener">https://cdn.staticfile.org/vue/2.2.2/vue.min.js</a></p></blockquote><blockquote><p>unpkg：<a href="https://unpkg.com/vue/dist/vue.js" target="_blank" rel="noopener">https://unpkg.com/vue/dist/vue.js</a>, 会保持和 npm 发布的最新的版本一致。</p></blockquote><blockquote><p>cdnjs : <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</a></p></blockquote><h3 id="3-NPM-方法"><a href="#3-NPM-方法" class="headerlink" title="3. NPM 方法"></a>3. NPM 方法</h3><p>npm 版本需要大于 3.0，如果低于此版本需要升级它</p><h4 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h4><blockquote><p>npm install npm -g</p></blockquote><h4 id="全局安装-vue-cli"><a href="#全局安装-vue-cli" class="headerlink" title="全局安装 vue-cli"></a>全局安装 vue-cli</h4><blockquote><p>$ cnpm install –global vue-cli</p></blockquote><h4 id="创建一个基于-webpack-模板的新项目"><a href="#创建一个基于-webpack-模板的新项目" class="headerlink" title="创建一个基于 webpack 模板的新项目"></a>创建一个基于 webpack 模板的新项目</h4><blockquote><p>$ vue init webpack my-project</p></blockquote><h4 id="这里需要进行一些配置，默认回车即可"><a href="#这里需要进行一些配置，默认回车即可" class="headerlink" title="这里需要进行一些配置，默认回车即可"></a>这里需要进行一些配置，默认回车即可</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This will install Vue 2.x version of the template.</span><br><span class="line"></span><br><span class="line">For Vue 1.x use: vue init webpack#1.0 my-project</span><br><span class="line"></span><br><span class="line">? Project name my-project</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author runoob &lt;test@runoob.com&gt;</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Use ESLint to lint your code? Yes</span><br><span class="line">? Pick an ESLint preset Standard</span><br><span class="line">? Setup unit tests with Karma + Mocha? Yes</span><br><span class="line">? Setup e2e tests with Nightwatch? Yes</span><br></pre></td></tr></tbody></table></figure><h4 id="进入项目，安装并运行："><a href="#进入项目，安装并运行：" class="headerlink" title="进入项目，安装并运行："></a>进入项目，安装并运行：</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd my-project </span><br><span class="line">$ cnpm install</span><br><span class="line">$ cnpm run dev</span><br><span class="line">DONE  Compiled successfully in 4388ms</span><br><span class="line">Listening at http://localhost:8080</span><br></pre></td></tr></tbody></table></figure><p>成功执行以上命令后访问 <a href="http://localhost:8080/，可得输出结果" target="_blank" rel="noopener">http://localhost:8080/，可得输出结果</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue语法格式</title>
      <link href="/2019/09/16/2019-9-16-ribao/"/>
      <url>/2019/09/16/2019-9-16-ribao/</url>
      
        <content type="html"><![CDATA[<h4 id="吼吼-，今天其实已经开始了vue的学习"><a href="#吼吼-，今天其实已经开始了vue的学习" class="headerlink" title="吼吼 ，今天其实已经开始了vue的学习"></a>吼吼 ，今天其实已经开始了vue的学习</h4><h2 id="vue语法格式"><a href="#vue语法格式" class="headerlink" title="vue语法格式"></a>vue语法格式</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id = "vue_det"&gt;</span><br><span class="line"> &lt;h1&gt;&lt;/h1&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> var vm=new Vue({</span><br><span class="line">el:'#vue_det',</span><br><span class="line">data:{</span><br><span class="line">  site: "菜鸟教程",</span><br><span class="line">  url: "www.runoob.com",</span><br><span class="line">  alexa: "10000"</span><br><span class="line">},</span><br><span class="line">methods:{</span><br><span class="line">  details:function(){</span><br><span class="line">    return  this.site+"-学的不仅是技术，更是梦想！";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> })</span><br><span class="line"> &lt;p&gt;data 用于定义属性，实例中有三个属性分别为：site、url、alexa。&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;methods 用于定义的函数，可以通过 return 来返回函数值。&lt;/p&gt;</span><br><span class="line"> 在Vue构造器中有一个el参数，它是DOM元素中的id，这意味着我们接下来的改动全部在以上指定的div内，div外部不受影响。</span><br></pre></td></tr></tbody></table></figure><blockquote><p>当一个Vue实例被创建时，它向Vue的响应式系统中加入了其data对象中能找到的所有的属性。当这些属性的值发生改变时，html视图将也会产生相应的变化。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var data = { site: "菜鸟教程", url: "www.runoob.com", alexa: 10000}</span><br><span class="line"> var vm = new Vue({</span><br><span class="line">   el: '#vue_det',</span><br><span class="line">data: data      // 它们引用相同的对象！</span><br><span class="line"> })</span><br><span class="line"> document.write(vm.site === data.site) // true</span><br><span class="line"> document.write("&lt;br&gt;")                // 设置属性也会影响到原始数据</span><br><span class="line"> vm.site = "Runoob"</span><br><span class="line"> document.write(data.site + "&lt;br&gt;") // Runoob</span><br><span class="line"> // ……反之亦然</span><br><span class="line"> data.alexa = 1234</span><br><span class="line"> document.write(vm.alexa) // 1234</span><br></pre></td></tr></tbody></table></figure><p>除了数据属性，Vue实例还提供了一些有用的实例属性与方法。它们都有前缀$，以便与用户定义的属性区分开来。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id="vue_det"&gt;</span><br><span class="line">  &lt;h1&gt;site : Jekyll::Drops::SiteDrop&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var data = { site: "菜鸟教程", url: "www.runoob.com", alexa: 10000}</span><br><span class="line">var vm = new Vue({</span><br><span class="line">  el: '#vue_det',</span><br><span class="line">  data: data</span><br><span class="line">}) </span><br><span class="line">document.write(vm.$data === data) // true</span><br><span class="line">document.write("&lt;br&gt;") </span><br><span class="line">document.write(vm.$el === document.getElementById('vue_det')) // true</span><br></pre></td></tr></tbody></table></figure><blockquote><p>vue插值</p></blockquote><p>文本和html</p><p>使用v-text指令不解析直接输出字符串，使用v-html指令解析后用于输出字符串的执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">    &lt;div v-html="message"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-text="message"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  new Vue({</span><br><span class="line">    el: '#app',</span><br><span class="line">    data: {</span><br><span class="line">      message: '&lt;h1&gt;菜鸟教程&lt;/h1&gt;'</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; 属性绑定</span><br><span class="line"> </span><br><span class="line"> &lt;p&gt; value值的绑定&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组。</span><br><span class="line">  单选按钮是直接取值不是逻辑值。&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;select列表与单选按钮是相似取值&lt;/p&gt;</span><br></pre></td></tr></tbody></table></figure> <input type="checkbox" v-model="use"> <input type="checkbox" id="runoob" value="Runoob" v-model="checkedNames"> <label for="runoob">Runoob</label>  new Vue({    el: '#app',    data:{      use: false    }  });<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> &lt;p&gt; input的value等于use，值的变化是相互的。即如果勾选后，use=true；&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&gt; class的绑定</span><br><span class="line"> </span><br><span class="line"> ``` </span><br><span class="line">  v-bind:class ="{class名1:boolean值，...,class名2:boolean值}"</span><br><span class="line">  判断class名1的值，如果为true使用class名1类的样式，否则不使用该类。</span><br><span class="line">  &lt;div v-bind:class="{'class1': use}"&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  new Vue({</span><br><span class="line">    el: '#app',</span><br><span class="line">    data:{</span><br><span class="line">      use: false</span><br><span class="line">    }</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  v-bind:class ="[vue的属性名1,...,vue的属性名n]"</span><br><span class="line">  class数组中的vue属性值就是class名。</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  new Vue({</span><br><span class="line">    el: '#app',</span><br><span class="line">    data: {</span><br><span class="line">      activeClass: 'active',</span><br><span class="line">      errorClass: 'text-danger'</span><br><span class="line">    }</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><blockquote><p> style的绑定，与class相似。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id="app"&gt;</span><br><span class="line">&lt;div v-bind:style="{color:activeColor,fontSize:fontSize+'px'}"&gt;菜鸟教程&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> new Vue({</span><br><span class="line">   el: '#app',</span><br><span class="line">   data: {</span><br><span class="line">     activeColor: 'green',</span><br><span class="line">  fontSize: 30</span><br><span class="line">   }</span><br><span class="line"> })</span><br><span class="line"></span><br><span class="line"> &lt;div id="app"&gt;</span><br><span class="line">   &lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;菜鸟教程&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> new Vue({</span><br><span class="line">   el: '#app',</span><br><span class="line">   data: {</span><br><span class="line">     baseStyles: {</span><br><span class="line">       color: 'green',</span><br><span class="line">       fontSize: '30px'</span><br><span class="line">     },</span><br><span class="line">  overridingStyles: {</span><br><span class="line">       'font-weight': 'bold'</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"> })</span><br></pre></td></tr></tbody></table></figure><blockquote><p>表达式</p></blockquote><p>Vue.js都提供了完全的JavaScript表达式支持。</p> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id="app"&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> new Vue({</span><br><span class="line">   el: '#app',</span><br><span class="line">   data: {</span><br><span class="line">  ok: true,</span><br><span class="line">     message: 'RUNOOB',</span><br><span class="line">  id : 1</span><br><span class="line">   }</span><br><span class="line"> })</span><br></pre></td></tr></tbody></table></figure><blockquote><p>指令</p></blockquote> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v-if指令将根据表达式seen的值(true 或 false )来决定是否插入p元素。</span><br><span class="line">&lt;div id="app"&gt;</span><br><span class="line">  &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">new Vue({</span><br><span class="line">  el: '#app',</span><br><span class="line">  data: {</span><br><span class="line">    seen: true</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line">还有v-else 、v-else-if指令，具有与JavaScript的条件语句相同的含义，</span><br><span class="line">v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后。</span><br><span class="line">v-show指令来根据条件真假来是否展示元素。</span><br><span class="line">&lt;div id="app"&gt;</span><br><span class="line">  &lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue({</span><br><span class="line">  el: '#app',</span><br><span class="line">  data: {</span><br><span class="line">    ok: true</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p> v-for指令</p></blockquote> <p> v-for="变量名 in 数组名"  变量名是从数组中取出的每一个变量的临时名称，数组名是vue的一个属性名。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id="app"&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for="value in object"&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue({</span><br><span class="line">  el: '#app',</span><br><span class="line">  data: {</span><br><span class="line">    object: {</span><br><span class="line">      name: '菜鸟教程',</span><br><span class="line">      url: 'http://www.runoob.com',</span><br><span class="line">      slogan: '学的不仅是技术，更是梦想！'</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">v-for="（变量名1，变量名2）in 数组名"</span><br><span class="line">变量名1是从数组中取出的每一个变量的临时名称，变量名2是从数组中取出的每一个变量的键名，数组名是vue的一个属性名。</span><br><span class="line">&lt;div id="app"&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for="(value, key) in object"&gt;</span><br><span class="line">       : </span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">v-for="（变量名1，变量名2，变量名3）in 数组名"</span><br><span class="line">变量名1是从数组中取出的每一个变量的临时名称，变量名2是每一个变量的键名，变量名3是每一个变量的下标值，数组名是vue的一个属性名。</span><br><span class="line">&lt;div id="app"&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for="(value, key, index) in object"&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12日日报</title>
      <link href="/2019/09/12/2019-9-12-ribao/"/>
      <url>/2019/09/12/2019-9-12-ribao/</url>
      
        <content type="html"><![CDATA[<br><p>今天学习了新的js特效，充实的一天很快过去，疲惫的一天也即将完结</p><p>但是我的心里的激动却停不了，明天就是中秋节，那明天就是假期?</p><p>甚至会情不自禁笑出声，忽然航哥告诉我们:明天放假，作业是...</p><p>wtf? 忽然一瞬间，心情由高空落向低谷，行吧做作业把</p><p>you can,加油少年</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11日日报</title>
      <link href="/2019/09/11/2019-9-11-ribao/"/>
      <url>/2019/09/11/2019-9-11-ribao/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>又是超级无聊的一天日报</p><p>但是又是超级努力的一天</p><p>不只是我在努力哦，全班同学都十分努力</p><p>大家都想提前努力，好让航哥知道我们不是吃醋的(还是糖好吃)</p><p>行吧，还是要努力呀</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10日日报</title>
      <link href="/2019/09/10/2019-9-10-ribao/"/>
      <url>/2019/09/10/2019-9-10-ribao/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天又是重复的一天</p><p>日子一天天过去</p><p>js也越发熟练，然而我的耐心也一点点消耗着</p><p>但是，小明告诉我们不要放弃呀</p><p>所以，要跟紧小明的步伐</p><p>推一首歌<strong><rain(魔女与玛丽之花主题曲)></rain(魔女与玛丽之花主题曲)></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9日日报</title>
      <link href="/2019/09/09/2019-9-9-ddddribao/"/>
      <url>/2019/09/09/2019-9-9-ddddribao/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天学习了用js制作表单验证和表单设置默认值</p><p>学的马马虎虎，但是能默写出来(时间够的话)</p><p>哦，对了，今天还学会了div转圈圈 和 js设置选项卡</p><p>emmm... 过了 ，毫无瑕疵</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2019/09/08/2019-9-8-singleton/"/>
      <url>/2019/09/08/2019-9-8-singleton/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是单例设计模式？</strong></p><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>需要：</p>1. 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。2. 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。3.  定义一个静态方法返回这个唯一对象。<p><em>实现一：立即加载 / “饿汉模式”</em></p><p>立即加载就是使用类的时候已经将对象创建完毕（不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”），常见的实现办法就是直接new实例化。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton {</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static、final修饰</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() {}</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">    public static Singleton getInstance() {</span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>“饿汉模式”的优缺点：</p><p>优点：实现起来简单，没有多线程同步问题。</p><p>缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。</p><p><em>实现二：延迟加载 / “懒汉模式”</em></p><p>延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton {</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() {}</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">    public static Singleton getInstance() {</span><br><span class="line">        if(instance == null) {</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        }</span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>“懒汉模式”的优缺点：</p><p>优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。</p><p>缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。</p><p><em>实现三：线程安全的“懒汉模式”</em></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton {</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() {}</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例，加synchronized关键字实现同步</span><br><span class="line">    public static synchronized Singleton getInstance() {</span><br><span class="line">        if(instance == null) {</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        }</span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优点：在多线程情形下，保证了“懒汉模式”的线程安全。</p><p>缺点：众所周知在多线程情形下，synchronized方法通常效率低，显然这不是最佳的实现方案。</p>*实现四：DCL双检查锁机制（DCL：double checked locking）*<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton {</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() {}</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">    public static Singleton getInstance() {</span><br><span class="line">        // 第一次检查instance是否被实例化出来，如果没有进入if块</span><br><span class="line">        if(instance == null) {</span><br><span class="line">            synchronized (Singleton.class) {</span><br><span class="line">                // 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象</span><br><span class="line">                if (instance == null) {</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法四算是单例模式的最佳实现方式。内存占用率高，效率高，线程安全，多线程操作原子性。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统后重新与github建立连接</title>
      <link href="/2019/09/07/2019-9-7-dddd/"/>
      <url>/2019/09/07/2019-9-7-dddd/</url>
      
        <content type="html"><![CDATA[<p><strong>解决办法是，再次生成一个密钥，然后完成跟github远程仓库的认证即可建立连接。</strong></p><p>默认你已经安装好了git，如果没有安装，windows下安装gitbash自带git，linux系统的话sudo apt-get  install -g git就可以了</p><h3 id="生成SSH秘钥"><a href="#生成SSH秘钥" class="headerlink" title="生成SSH秘钥"></a>生成SSH秘钥</h3><p>第一步先生成ssh秘钥。在系统根目录下打开命令行终端，执行命令：ssh-keygen -t rsa -C "填写你的任意邮箱"，</p><p>执行完成后，会生成一个.ssh文件夹，里面的id_rsa.pub文件内容就是秘钥，那么我们就进入ssh文件夹打开该文件后复制它的内容。或者命令行快速打开cd ./.ssh &amp;&amp; cat id_rsa.pub然后会有一大串字符打印在终端，这个是秘钥内容，全部复制下来。</p><h3 id="登录github新建SSH-Key"><a href="#登录github新建SSH-Key" class="headerlink" title="登录github新建SSH Key"></a>登录github新建SSH Key</h3><p>登录自己的github，在右上角头像框点击邮件选择Settings，然后在左边菜单选择SSH and GPG keys,在SSH keys一栏点击New SSH key的绿色按钮，title随便写，key那一个框框里把刚才复制的id_rsa.pub的内容粘贴到这里，确定复制的是完整的秘钥不要漏了。粘贴完后点下面Add的绿色按钮，这样就在github上生成了一个对应的SSH秘钥了。</p><h3 id="验证SSH"><a href="#验证SSH" class="headerlink" title="验证SSH"></a>验证SSH</h3><p>回到本地，随便找个空文件夹或者新建一个文件夹，在这个新文件夹下新建一个git本地仓库。终端在这个文件夹的路径下打开，路径一定要正确，然后执行</p><blockquote><p>git init</p></blockquote><p>再然后就是设置用户名和邮箱：</p><blockquote><p>git config –global user.name “你的用户名”</p></blockquote><blockquote><p>git config –global user.email “你的邮箱”</p></blockquote><p>设置完后，设置你想要建立对应连接的远程仓库地址：</p><blockquote><p>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:XXXXXXX/xxxxxxx.git </p></blockquote><p>这里的地址填写你github仓库的SSH地址，注意是SSH的地址不是http的地址</p><p>设置完成后，把远程仓库的源代码拉取到本地：</p><blockquote><p>git pull origin master –allow-unrelated-histories  </p></blockquote><p><strong>这里的master是你远程仓库的分支名，如果你的分支名不是master你就改成你的分支名</strong></p><p>一般来讲没有改过的分支名肯定有一个是master，只不过不知道你想要的代码在不在master分支。</p><p>执行上述命令后会出现一堆信息，大概就是关于验证的，结束会有一个（yes/no），这里手打‘yes’再回车就可以完成验证了，直接打回车会验证错误，原贴在这里 [https://blog.csdn.net/u010193432/article/details/82877663](https://blog.csdn.net/u010193432/article/details/82877663)    验证通过后就会拉取远程master分支的代码到你的文件夹，并同时在本地创建一个master分支。接下来就是要建立本地分支和远程分支的追踪关系，方便以后push，执行如下命令：</p><blockquote><p>git branch –set-upstream-to=origin/master</p></blockquote><p>至此，本地仓库重新与github远程仓库建立了连接,再次执行git pull,出现up to date就没问题了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webstrom安装</title>
      <link href="/2019/09/07/2019-9-7-wwebstorm/"/>
      <url>/2019/09/07/2019-9-7-wwebstorm/</url>
      
        <content type="html"><![CDATA[<p>安装webstorm首先应该配置环境安装 java的开源代码库,再下载安装包进行</p><p>WebStorm是基于Java的,我们需要安装Oracle JDK的支持.   注:有jdk就不用本步骤了</p><p>安装 Oracle JDK 的命令如下:</p><p></p><h3 id="1-sudo-add-apt-repository-ppa-webupd8team-java"><a href="#1-sudo-add-apt-repository-ppa-webupd8team-java" class="headerlink" title="1. sudo add-apt-repository ppa:webupd8team/java"></a>1. sudo add-apt-repository ppa:webupd8team/java</h3><p>add-apt-repository ppa:<ppa_name>  下载java开源代码库。</ppa_name></p><h3 id="2-sudo-apt-get-update"><a href="#2-sudo-apt-get-update" class="headerlink" title="2.sudo apt-get update"></a>2.sudo apt-get update</h3><p>获取到最新的软件包(apt-get update)</p><h3 id="3-sudo-apt-get-install-oracle-java7-installer"><a href="#3-sudo-apt-get-install-oracle-java7-installer" class="headerlink" title="3.sudo apt-get install oracle-java7-installer"></a>3.sudo apt-get install oracle-java7-installer</h3><p>下载并安装java开源代码库</p><h3 id="4-sudo-apt-get-install-oracle-java7-set-defaul"><a href="#4-sudo-apt-get-install-oracle-java7-set-defaul" class="headerlink" title="4.sudo apt-get install oracle-java7-set-defaul"></a>4.sudo apt-get install oracle-java7-set-defaul</h3><p>运行命令查看是否安装成功:</p><blockquote><p>java -version</p></blockquote><p>显示java开源代码的版本,如果显示则说明java开源代码安装成功.</p><p><strong>[WebStorm]安装</strong></p><p>首先需要下载WebStrom的Linux安装包,地址如下:</p><p></p><blockquote><p>s<a href="https://www.jetbrains.com/webstorm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/webstorm/download/</a></p></blockquote><p></p><p>然后运行如下命令解压并安装并运行WebStorm:</p><blockquote><p>sudo tar xfz ~/Downloads/WebStorm-16.2.3.tar.gz</p></blockquote><p>这一步是先进行解压缩</p><blockquote><p>sudo mv ~/Downloads/WebStorm-162.2228.20 /home/wang/下载/</p></blockquote><p>mv移动命令</p><p>然后再把解压文件移动到 home/wang/下载/ 下</p><blockquote><p>cd /home/wang/下载/WebStorm-162.2228.20/<br>   cd bin/</p></blockquote><p>进入bin目录</p><blockquote><p>sudo sh webstorm.sh</p></blockquote><p>sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取启动webstorm</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6日日报</title>
      <link href="/2019/09/06/2019-9-6-ddddd/"/>
      <url>/2019/09/06/2019-9-6-ddddd/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天也考核了</p><p>考核前,感觉良好,因为看了好几天,总归是有点记忆的</p><p>但是,航哥开口一瞬间,我感觉到了自己的不足(诧异),好像没学过似的</p><p>但是我是不会努力的,杰宝come on</p><p>Keep on going never give up</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>放大镜实现</title>
      <link href="/2019/09/05/2019-9-5-ddddd/"/>
      <url>/2019/09/05/2019-9-5-ddddd/</url>
      
        <content type="html"><![CDATA[<h4 id="放大镜的实现"><a href="#放大镜的实现" class="headerlink" title="放大镜的实现"></a>放大镜的实现</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;style type="text/css"&gt;    </span><br><span class="line">*{margin:0px;</span><br><span class="line">padding:0px;}</span><br><span class="line">.img{</span><br><span class="line">width: 350px;</span><br><span class="line">height: 350px;</span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">margin: 0px;</span><br><span class="line">position: absolute;</span><br><span class="line">cursor:move;</span><br><span class="line">left: 500px;</span><br><span class="line">}    </span><br><span class="line">.bimg{</span><br><span class="line">position: absolute;</span><br><span class="line">top: -1px;</span><br><span class="line">left: 360px;         </span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">width: 350px;</span><br><span class="line">height: 350px;         </span><br><span class="line">overflow: hidden;</span><br><span class="line">display: none;</span><br><span class="line">}  </span><br><span class="line">#move{</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;        </span><br><span class="line">  background-color: rgba(8,152,202,0.2);</span><br><span class="line">  top: 0px;        </span><br><span class="line">  left: 0px;</span><br><span class="line">  display: none;</span><br><span class="line">  }   </span><br><span class="line">.simg{</span><br><span class="line">width: 350px;</span><br><span class="line">height: 350px;</span><br><span class="line">}</span><br><span class="line">.bimg&gt;img{</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 0px;</span><br><span class="line">   top: 0px;</span><br><span class="line">   }</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class="img"&gt;   </span><br><span class="line">&lt;div class="simg"&gt;&lt;!--小图片--&gt;     </span><br><span class="line">    &lt;img src="/home/zhangjie/图片/miojk(复件).jpg" style="width:350px;height:350px;" /&gt;     </span><br><span class="line">    &lt;div id="move"&gt;&lt;/div&gt;&lt;!--放大区域--&gt;  </span><br><span class="line"> &lt;/div&gt;  </span><br><span class="line">    &lt;div class="bimg"&gt;&lt;!--大图片--&gt;    </span><br><span class="line">    &lt;img src="/home/zhangjie/图片/miojk.jpg" style="width:1225px ;height: 1225px;" /&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function(){</span><br><span class="line"></span><br><span class="line">//鼠标移动到图片显示，移除隐藏     </span><br><span class="line">$(".img").hover(function(){           </span><br><span class="line">   $(".bimg").css("display","block");          </span><br><span class="line">    $("#move").css("display","block");       </span><br><span class="line">},function(){       </span><br><span class="line">  $(".bimg").css("display","none");         </span><br><span class="line">  $("#move").css("display","none");       </span><br><span class="line">  });</span><br><span class="line">//放大区域移动，大图片移动</span><br><span class="line">$(".img").mousemove(function(event){</span><br><span class="line">    var x = event.pageX;          </span><br><span class="line">    var y = event.pageY;                   </span><br><span class="line">    var nx = x - $(".img").offset().left-$("#move").width()/2;            </span><br><span class="line">    var ny = y - $(".img").offset().top-$("#move").height()/2;           </span><br><span class="line">    if(nx &lt; 0){ </span><br><span class="line">        nx = 0;</span><br><span class="line">    }            </span><br><span class="line">    if(nx &gt; $(".img").width()-$("#move").width()){        </span><br><span class="line">        nx = $(".img").width()-$("#move").width();         </span><br><span class="line">    }            </span><br><span class="line">    if(ny &lt; 0){       </span><br><span class="line">        ny = 0;            </span><br><span class="line">    }            </span><br><span class="line">    if(ny &gt; $(".img").height()-$("#move").height()){       </span><br><span class="line">        ny = $(".img").height()-$("#move").height();     </span><br><span class="line">    }                </span><br><span class="line">    $("#move").css({           </span><br><span class="line">        left:nx+"px",           </span><br><span class="line">        top:ny+"px"       </span><br><span class="line">    });           </span><br><span class="line">    $(".bimg&gt;img").css({         </span><br><span class="line">        left:-nx*$(".bimg").width()/$("#move").width()+"px",   </span><br><span class="line">        top:-ny*$(".bimg").height()/$("#move").height()+"px"      </span><br><span class="line">    });</span><br><span class="line">})</span><br><span class="line">                                              </span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4日日报</title>
      <link href="/2019/09/04/2019-9-4-ddddd/"/>
      <url>/2019/09/04/2019-9-4-ddddd/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天任务比较重 ,大家都什么认真的在学习,我也不例外</p><p>但是我能看的出来大家都有点局促不安</p><p>果然,下午航哥来对我们进行考核了,大家在一片哈哈声中有了一丝丝的沉重</p><p>考完了,怎么说呢 ,差点去世,航哥考核我们的是团队协作能力</p><p>大家都有一些顿悟,大家的声音也感觉到了靠近</p><p>什么是兄弟呢?</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3日日报</title>
      <link href="/2019/09/03/2019-9-2-dsad-day/"/>
      <url>/2019/09/03/2019-9-2-dsad-day/</url>
      
        <content type="html"><![CDATA[<h4 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h4><h5 id="今天任务繁重-明天任需加油"><a href="#今天任务繁重-明天任需加油" class="headerlink" title="今天任务繁重 明天任需加油"></a>今天任务繁重 明天任需加油</h5><h5 id="今天听书内容精湛-同学们准备充足-思路清晰-主题明确-大家都积极发言-好和谐一集体"><a href="#今天听书内容精湛-同学们准备充足-思路清晰-主题明确-大家都积极发言-好和谐一集体" class="headerlink" title="今天听书内容精湛,同学们准备充足 思路清晰 主题明确,大家都积极发言,好和谐一集体"></a>今天听书内容精湛,同学们准备充足 思路清晰 主题明确,大家都积极发言,好和谐一集体</h5><h5 id="以后还得加油鸭"><a href="#以后还得加油鸭" class="headerlink" title="以后还得加油鸭"></a>以后还得加油鸭</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2日日报</title>
      <link href="/2019/09/02/2019-9-2-dasda/"/>
      <url>/2019/09/02/2019-9-2-dasda/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><h4 id="今天背了用socketio做成的聊天室-虽然比较简陋-但是是可以作为自己玩乐的小游戏的"><a href="#今天背了用socketio做成的聊天室-虽然比较简陋-但是是可以作为自己玩乐的小游戏的" class="headerlink" title="今天背了用socketio做成的聊天室 虽然比较简陋,但是是可以作为自己玩乐的小游戏的"></a>今天背了用socketio做成的聊天室 虽然比较简陋,但是是可以作为自己玩乐的小游戏的</h4><h4 id="emmm…今天还和兄弟们一起装修了工作区-我们都很高兴-新办公桌办公椅真是舒服"><a href="#emmm…今天还和兄弟们一起装修了工作区-我们都很高兴-新办公桌办公椅真是舒服" class="headerlink" title="emmm…今天还和兄弟们一起装修了工作区,我们都很高兴,新办公桌办公椅真是舒服"></a>emmm…今天还和兄弟们一起装修了工作区,我们都很高兴,新办公桌办公椅真是舒服</h4><h4 id="所以呀-要更加努力了"><a href="#所以呀-要更加努力了" class="headerlink" title="所以呀,要更加努力了"></a>所以呀,要更加努力了</h4><h4 id="come-on"><a href="#come-on" class="headerlink" title="come on!"></a>come on!</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websocket和socketio的总结</title>
      <link href="/2019/08/30/2019-8-30-thth-day/"/>
      <url>/2019/08/30/2019-8-30-thth-day/</url>
      
        <content type="html"><![CDATA[<h3 id="WebSocket和SocketIO总结"><a href="#WebSocket和SocketIO总结" class="headerlink" title="WebSocket和SocketIO总结"></a>WebSocket和SocketIO总结</h3><h4 id="WebSocket是什么？"><a href="#WebSocket是什么？" class="headerlink" title="WebSocket是什么？"></a>WebSocket是什么？</h4><p>WebScoket是一种让客户端和服务器之间能进行双向实时通信的技术。它是HTML最新标准HTML5的一个协议规范，本质上是个基于TCP的协议，它通过HTTP/HTTPS协议发送一条特殊的请求进行握手后创建了一个TCP连接，此后浏览器/客户端和服务器之间便可以通过此连接来进行双向实时通信。</p><h4 id="为什么要用WebSocket？"><a href="#为什么要用WebSocket？" class="headerlink" title="为什么要用WebSocket？"></a>为什么要用WebSocket？</h4><ul><li><p>一直以来，HTTP协议是无状态、单向通信的，即客户端请求一次，服务器回复一次。如果想让服务器消息及时下发到客户端，需要采用类似于轮询的机制，即客户端定时频繁的向服务器发出请求，这样效率很低，而且HTTP数据包头本身的字节量较大，浪费了大量带宽和服务器资源；</p></li><li><p>为提高效率，出现了AJAX/Comet技术，它实现了双向通信且节省了一定带宽，但仍然需要发出请求，本质上仍然是轮询；</p></li><li><p>新一代HTML标准HTML5推出了WebSocket技术，它使客户端和服务器之间能通过HTTP协议建立TCP连接，之后便可以随时随地进行双向通信，且交换的数据包头信息量很小；</p><h4 id="如何使用WebSocket？"><a href="#如何使用WebSocket？" class="headerlink" title="如何使用WebSocket？"></a>如何使用WebSocket？</h4></li></ul><p>在支持WebSocket的浏览器中，创建Socket之后，通过onopen、onmessage、onclose、onerror四个事件的实现来处理Socket的响应；</p><h4 id="WebSocket与HTTP、TCP的关系"><a href="#WebSocket与HTTP、TCP的关系" class="headerlink" title="WebSocket与HTTP、TCP的关系"></a>WebSocket与HTTP、TCP的关系</h4><p>WebSocket和HTTP都属于应用层协议，且都是基于TCP的，它们的send函数最终也是通过TCP系统接口来做数据传输。那么WebSocket和HTTP的关系呢？WebSocket在建立握手连接时，数据是通过HTTP协议传输的，但是在连接建立后，真正的数据传输阶段则不需要HTTP协议的参与</p><h4 id="什么情况下使用WebSocket？"><a href="#什么情况下使用WebSocket？" class="headerlink" title="什么情况下使用WebSocket？"></a>什么情况下使用WebSocket？</h4><p>如果游戏需要同时支持手机端、Web端，那毫无疑问应该使用WebSocket，现在各个平台都提供了相应的WebSocket实现。如果游戏不需要支持Web端，且对实时性要求比较高，如多人射击、MMORPG之类，那么使用TCP/UDP结合的原生Socket会比较好。</p><h4 id="SocketIO"><a href="#SocketIO" class="headerlink" title="SocketIO"></a>SocketIO</h4><p>WebSocket是HTML5最新提出的规范，虽然主流浏览器都已经支持，但仍然可能有不兼容的情况，为了兼容所有浏览器，给程序员提供一致的编程体验，SocketIO将WebSocket、AJAX和其它的通信方式全部封装成了统一的通信接口，也就是说，我们在使用SocketIO时，不用担心兼容问题，底层会自动选用最佳的通信方式。因此说，WebSocket是SocketIO的一个子集。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30日日报</title>
      <link href="/2019/08/30/2019-8-30--ththth-day/"/>
      <url>/2019/08/30/2019-8-30--ththth-day/</url>
      
        <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><ul><li><p>今天学习了服务器和客户端之间的知识</p></li><li><p>然后搞了点视频教学,视频教学在B站</p><blockquote><p><a href="https://www.bilibili.com/video/av16660731?from=search&amp;seid=16870578180827938449" target="_blank" rel="noopener">https://www.bilibili.com/video/av16660731?from=search&amp;seid=16870578180827938449</a></p></blockquote></li></ul><p>我看了好长时间...  主要是俩个字母错了,结果在整个代码找了好久</p><h4 id="我太难了"><a href="#我太难了" class="headerlink" title="我太难了"></a>我太难了</h4><ul><li><p>好了,学习使我快乐, 努力学习</p></li><li><p>加油 加油 加油!</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs简单使用</title>
      <link href="/2019/08/29/2019-8-29--ththth-day/"/>
      <url>/2019/08/29/2019-8-29--ththth-day/</url>
      
        <content type="html"><![CDATA[<h3 id="Node-js-组成"><a href="#Node-js-组成" class="headerlink" title="Node.js 组成"></a>Node.js 组成</h3><ol><li><p>引入required模块：我们可以使用require指令来载入Node.js模块。</p></li><li><p>创建服务器：服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p></li><li><p>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轮播图</title>
      <link href="/2019/08/29/2019-8-29--ththtz-day/"/>
      <url>/2019/08/29/2019-8-29--ththtz-day/</url>
      
        <content type="html"><![CDATA[<h3 id="轮播图代码"><a href="#轮播图代码" class="headerlink" title="轮播图代码"></a>轮播图代码</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html lang="ch"&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line"> &lt;meta charset="UTF-8"&gt;</span><br><span class="line"> &lt;title&gt;轮播演示&lt;/title&gt;</span><br><span class="line"> &lt;style type="text/css"&gt;</span><br><span class="line">img{</span><br><span class="line">border: 1px solid pink;</span><br><span class="line">height: 270px;</span><br><span class="line">}</span><br><span class="line">body{</span><br><span class="line">background-color: purple;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"> &lt;div &gt;</span><br><span class="line"> &lt;img src="/home/zhangjie/图片/ccc1.jpg" id="iid"&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;script type="text/javascript"&gt;</span><br><span class="line"> var index =1;</span><br><span class="line"> window.onload=function(){setInterval(lunbo,1000);}</span><br><span class="line"> function lunbo(){</span><br><span class="line"> var img = document.getElementById('iid');</span><br><span class="line"> index++;</span><br><span class="line"> img.src="/home/zhangjie/图片/ccc"+index+".jpg";</span><br><span class="line">  if(index===5){</span><br><span class="line"> index =1;</span><br><span class="line"> }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>如上代码可实现轮播,但是图片得自行调整</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29日日报</title>
      <link href="/2019/08/29/2019-8-29--ththth-da/"/>
      <url>/2019/08/29/2019-8-29--ththth-da/</url>
      
        <content type="html"><![CDATA[<h3 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h3><ol><li><p>今天学习了点nodejs 并且安装了nodejs 环境算是对nodejs有点基础</p></li><li><p>今天学习了制作定时器,分为定时弹出和周期性弹出</p></li><li><p>今日感觉良好,并且看了点有关服务器和客户端的知识</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css选择权简介</title>
      <link href="/2019/08/28/2019-8-28-thir-thirteenth-day/"/>
      <url>/2019/08/28/2019-8-28-thir-thirteenth-day/</url>
      
        <content type="html"><![CDATA[<h4 id="CSS样式实现方式"><a href="#CSS样式实现方式" class="headerlink" title="CSS样式实现方式"></a>CSS样式实现方式</h4><ol><li><p>内联样式</p><ul><li>单独作用在 一个元素的上的 样式 叫 内联样式 </li><li>实现是通过  元素的 style 属性 </li></ul></li><li><p>内部样式</p><ul><li>针对单独的一个页面的  样式 </li><li>实现是 通过   style 标签实现的 </li></ul></li><li><p>外部样式</p><ul><li>针对 多个页面的   一般先定义成样式文件  然后在需要的页面上进行引入 </li><li>具体事项  先有样式 文件  ***.css</li><li>使用 link 标签 或者  style 标签进行引入 </li></ul></li></ol><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><ol><li><p>元素选择器</p></li><li><p>类选择器</p></li><li><p>id选择器</p></li><li><p>伪类选择器</p></li><li><p>后代选择器</p></li><li><p>子元素选择器</p></li></ol><h4 id="常用伪类"><a href="#常用伪类" class="headerlink" title="常用伪类"></a>常用伪类</h4><ul><li><p>:link<br>向未被访问的超链接添加样式</p></li><li><p>:visited<br>向已被访问的超列检添加样式</p></li><li><p>:active<br>向被激活的元素添加样式</p></li><li><p>:hover<br>当鼠标悬停至元素上方时,向钙元素添加样式</p></li><li><p>:focus<br>当元素获取焦点时,向该元素添加样式</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28日日报</title>
      <link href="/2019/08/28/2019-8-28-thirteenth-day/"/>
      <url>/2019/08/28/2019-8-28-thirteenth-day/</url>
      
        <content type="html"><![CDATA[<h3 id="学习js…"><a href="#学习js…" class="headerlink" title="学习js…"></a>学习js…</h3><ol><li><p>今天粗略看了html,css,js,果然有点基础就是好,理解起来超级快</p></li><li><p>然后一天就过去了,我又在刚才看了点关于node.js的内容</p></li><li><p>好了,今日日报到此结束</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs安装</title>
      <link href="/2019/08/27/2019-8-27-twelth-technolog/"/>
      <url>/2019/08/27/2019-8-27-twelth-technolog/</url>
      
        <content type="html"><![CDATA[<h3 id="ubuntu下安装nodejs和npm"><a href="#ubuntu下安装nodejs和npm" class="headerlink" title="ubuntu下安装nodejs和npm"></a>ubuntu下安装nodejs和npm</h3><p><strong>第一种安装方法</strong>：</p><blockquote><p>安装nodejs ：</p></blockquote><p>sudo apt-get install nodejs</p><p>运行 nodejs -v 会弹出安装node的版本号<br></p><p>这里使用的是 nodejs 并不是常用的node ，可以通过<br></p><blockquote><p>sudo ln -s /usr/bin/nodejs /usr/bin/node</p></blockquote><p>命令让node与nodejs建立软连接，接着就可以使用 node命令<br></p><p>安装npm:<br></p><blockquote><p>sudo apt-get install npm</p></blockquote><p>测试安装是否成功: npm -v 弹出安装的版本号，即可证明安装成功</p><p><strong>第二种安装方法：</strong></p><p>先安装，nvm，即是Node Version Manager(Node版本管理器)</p><blockquote><p>curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash" target="_blank" rel="noopener">https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash</a></p></blockquote><p>或者使用 wget</p><blockquote><p>wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash" target="_blank" rel="noopener">https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash</a></p></blockquote><p>之后需要激活nvm:</p><blockquote><p>source ~/.nvm/nvm.sh</p></blockquote><p>激活完成后，安装node</p><blockquote><p>nvm install node</p></blockquote><p>安装完成后，切换到该版本</p><blockquote><p>nvm use node</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单命令</title>
      <link href="/2019/08/27/2019-8-27-eleven-day/"/>
      <url>/2019/08/27/2019-8-27-eleven-day/</url>
      
        <content type="html"><![CDATA[<h4 id="echo-显示文本行"><a href="#echo-显示文本行" class="headerlink" title="echo  //显示文本行"></a>echo  //显示文本行</h4><h4 id="echo-LANG-显示系统语言"><a href="#echo-LANG-显示系统语言" class="headerlink" title="echo $LANG  //显示系统语言"></a>echo $LANG  //显示系统语言</h4><h4 id="echo-PATH-显示系统的环境变量"><a href="#echo-PATH-显示系统的环境变量" class="headerlink" title="echo $PATH  //显示系统的环境变量"></a>echo $PATH  //显示系统的环境变量</h4><h4 id="date-显示当前时间"><a href="#date-显示当前时间" class="headerlink" title="date //显示当前时间"></a>date //显示当前时间</h4><h4 id="date-’-Y-m-d’-以yyyy-mm-dd格式显示日期"><a href="#date-’-Y-m-d’-以yyyy-mm-dd格式显示日期" class="headerlink" title="date +’%Y/%m/%d’  //以yyyy/mm/dd格式显示日期"></a>date +’%Y/%m/%d’  //以yyyy/mm/dd格式显示日期</h4><h4 id="date-’-Y-m-d’-以yyyy-mm-dd格式显示日期-1"><a href="#date-’-Y-m-d’-以yyyy-mm-dd格式显示日期-1" class="headerlink" title="date +’%Y-%m-%d’  //以yyyy-mm-dd格式显示日期"></a>date +’%Y-%m-%d’  //以yyyy-mm-dd格式显示日期</h4><h4 id="date-H-M-显示时、分"><a href="#date-H-M-显示时、分" class="headerlink" title="date +%H:%M  //显示时、分"></a>date +%H:%M  //显示时、分</h4><h4 id="date-r-test-显示test文件最后一次的修改时间"><a href="#date-r-test-显示test文件最后一次的修改时间" class="headerlink" title="date -r test  //显示test文件最后一次的修改时间"></a>date -r test  //显示test文件最后一次的修改时间</h4><h4 id="cat-etc-shells-查看shell版本"><a href="#cat-etc-shells-查看shell版本" class="headerlink" title="cat /etc/shells  //查看shell版本"></a>cat /etc/shells  //查看shell版本</h4><h4 id="hostname-显示主机名"><a href="#hostname-显示主机名" class="headerlink" title="hostname  //显示主机名"></a>hostname  //显示主机名</h4><h4 id="hostname-a-显示主机别名"><a href="#hostname-a-显示主机别名" class="headerlink" title="hostname  -a  //显示主机别名"></a>hostname  -a  //显示主机别名</h4><h4 id="hostname-d-显示主机域名"><a href="#hostname-d-显示主机域名" class="headerlink" title="hostname  -d  //显示主机域名"></a>hostname  -d  //显示主机域名</h4><h4 id="hostname-i-显示主机IP地址"><a href="#hostname-i-显示主机IP地址" class="headerlink" title="hostname  -i  //显示主机IP地址"></a>hostname  -i  //显示主机IP地址</h4><h4 id="hostname-主机名-设置主机名称"><a href="#hostname-主机名-设置主机名称" class="headerlink" title="hostname 主机名 //设置主机名称"></a>hostname 主机名 //设置主机名称</h4><h4 id="cal-显示当前月份"><a href="#cal-显示当前月份" class="headerlink" title="cal  //显示当前月份"></a>cal  //显示当前月份</h4><h4 id="查看Linux-端口"><a href="#查看Linux-端口" class="headerlink" title="查看Linux 端口"></a>查看Linux 端口</h4><h4 id="netstat-pan-grep-177-查看177端口情况"><a href="#netstat-pan-grep-177-查看177端口情况" class="headerlink" title="netstat -pan|grep 177  //查看177端口情况"></a>netstat -pan|grep 177  //查看177端口情况</h4><h4 id="netstat-nlap-查询进程占用哪些端口"><a href="#netstat-nlap-查询进程占用哪些端口" class="headerlink" title="netstat -nlap  //查询进程占用哪些端口"></a>netstat -nlap  //查询进程占用哪些端口</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简单命令</title>
      <link href="/2019/08/26/2019-8-26-dddd-day/"/>
      <url>/2019/08/26/2019-8-26-dddd-day/</url>
      
        <content type="html"><![CDATA[<h4 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h4><p>pwd 输出当前目录</p><p>uname 输出本地计算机信息</p><p>date 输出当前系统时间</p><p>date -s 可修改当前日期和时间</p><p>free 输出内存使用信息</p><p>ls 列出当前目录的内容</p><p>cd 更改当前目录</p><p>clear 清屏</p><p>su 更换用户身份</p><p>shutdown 关机</p><p>reboot 重启</p><p>mv 移动某个文件或者更改名称</p><p>rm 删除指定文件</p><p>cp 复制某个文件 </p><p>mkdir 创建一个目录</p><p>rmdir 删除一个目录</p><p>cat 文本查看</p><p>head 显示头部文本内容</p><p>tail 显示尾部文本内容</p><p>vi 进入vi编辑模式</p><p>diff 找出俩个文件的不同</p><p>grep 搜索并指定字符串</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简单命令</title>
      <link href="/2019/08/26/2019-8-26-tenth-day/"/>
      <url>/2019/08/26/2019-8-26-tenth-day/</url>
      
        <content type="html"><![CDATA[<p>####今日演讲 <a href="../../桌面/演示稿.tar.xz">演示稿.tar.xz</a><br>今天我和组员们 演讲了整理一周的报告 我讲js基础知识<br><br>感觉收货很大<br></p><p><strong>这是今天的练习</strong><br> <a href="../../桌面/练习.html">练习.html</a> </p><p>今天还学习了Linux的部分知识,速度太慢<br></p><p><em>用户和群组</em></p><blockquote><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组 </p><p>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令 </p></blockquote><p><em>打包和压缩文件</em></p><blockquote><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件</p></blockquote><p>但是要努力啊</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iotop的安装</title>
      <link href="/2019/08/23/2019-8-23-ninth-techoolog/"/>
      <url>/2019/08/23/2019-8-23-ninth-techoolog/</url>
      
        <content type="html"><![CDATA[<h3 id="iotop的简介："><a href="#iotop的简介：" class="headerlink" title="iotop的简介："></a>iotop的简介：</h3><p>iotop是一款开源、免费的用来监控磁盘I/O使用状况的类似top命令的工具，iotop可以监控进程的I/O信息。它是Python语言编写的，与iostat工具比较，iostat是系统级别的IO监控，而iotop是进程级别IO监控。目前最新的版本为iotop 0.6。其官方网址<a href="http://guichaz.free.fr/iotop/" target="_blank" rel="noopener">http://guichaz.free.fr/iotop/</a></p><h3 id="iotop的安装："><a href="#iotop的安装：" class="headerlink" title="iotop的安装："></a>iotop的安装：</h3><p><strong>注意</strong>，iotop的安装有前提条件（如果操作系统不满足这些条件，iotop无法正确安装）：</p><p>  1：内核版本为2.6.20或更高版本<br></p><p>  2：Python 2.7或更高的版本<br></p><h3 id="官方文档的详细介绍如下："><a href="#官方文档的详细介绍如下：" class="headerlink" title="官方文档的详细介绍如下："></a>官方文档的详细介绍如下：</h3><p>Linux has always been able to show how much I/O was going on (the bi and bo columns of the vmstat 1 command).<br></p><p>Iotop is a Python program with a top like UI used to show of behalf of which process is the I/O going on. It requires Python ≥ 2.7 and a Linux kernel ≥ 2.6.20 with the TASK_DELAY_ACCT CONFIG_TASKSTATS, TASK_IO_ACCOUNTING and CONFIG_VM_EVENT_COUNTERS options on.<br></p><h3 id="iotop的yum安装"><a href="#iotop的yum安装" class="headerlink" title="iotop的yum安装"></a>iotop的yum安装</h3><p>yum安装是最简单、快捷的。前提条件是你有配置yum的源配置。<br></p><p>[root@DB-Server ~]# python -V<br></p><p>Python 2.7.5<br></p><p>[root@DB-Server ~]# uname -a<br></p><p>Linux DB-Server 3.10.0-862.el7.x86_64 #1 SMP Fri Apr 20 16:44:24 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux<br></p><p>[root@DB-Server ~]# <br></p><p>[root@DB-Server ~]# yum -y install iotopbr&lt;&gt;</p><h3 id="iotop的源码安装"><a href="#iotop的源码安装" class="headerlink" title="iotop的源码安装"></a>iotop的源码安装</h3><p>wget <a href="http://guichaz.free.fr/iotop/files/iotop-0.6.tar.bz2" target="_blank" rel="noopener">http://guichaz.free.fr/iotop/files/iotop-0.6.tar.bz2</a><br></p><p>tar -xvf iotop-0.6.tar.gz <br></p><p>cd iotop-0.6<br></p><p>python setup.py build<br></p><p>python setup.py install<br><br><a href="https://www.cnblogs.com/kerrycode/p/11344506.html" target="_blank" rel="noopener">具体参考</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23日日报</title>
      <link href="/2019/08/23/2019-8-23-ninth-day/"/>
      <url>/2019/08/23/2019-8-23-ninth-day/</url>
      
        <content type="html"><![CDATA[<p>Linux下几个常见的文件查找命令：</p><ul><li>which       查看可执行文件的位置 </li><li>whereis    寻找特定文件，查看文件的位置 </li><li>locate       配合数据库查看文件位置 </li><li>find          实际搜寻硬盘查询文件名称 </li></ul><p><strong>find</strong>（用于在文件树中查找文件，并进行相应操作）</p><p>格式： find  [PATH]  [option]  [action]</p><ul><li><p>[PATH] : 所要搜索遍历的目录，默认为当前目录</p></li><li><p>[option] : 所要搜索文件的条件特征</p></li><li><p>[action] : 对搜索结果进行特殊处理</p></li></ul><p><strong>与时间有关的参数</strong></p><ul><li><p>amin  n     ：查找n分钟内被访问过的文件</p></li><li><p>cmin  n     : 查找n分钟内被修改过文件状态的所有文件</p></li><li><p>mmin  n    ： 查找n分钟内被修改过文件内容的所有文件</p></li><li><p>atime n     : 将n天内存取过的的文件列出来 </p></li></ul><p><strong>与文件权限及名称有关的参数</strong></p><ul><li><p>name [filename] : 查找文件名为filename的文件</p></li><li><p>type [TYPE]        ：查找文件类型为TYPE的文件</p></li><li><p>type选项常见的参数：</p></li></ul><p>参数|含义<br>b|块设备文件<br>c|字符设备文件<br>d|目录文件<br>f|普通文件<br>p|命名管道<br>l|符号链接</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22日日报</title>
      <link href="/2019/08/22/2019-8-22-eighth-day/"/>
      <url>/2019/08/22/2019-8-22-eighth-day/</url>
      
        <content type="html"><![CDATA[<p>三种模式: 命令模式(Command mode)  输入模式(Insert mode) 和底线命令模式(Last line mode)<br></p><p>命令模式:<br><br>启动vi/vim时 我们便进入了命令模式<br><br>按 i切换到输入模式<br><br>按 x删除当前光标所在处的字符<br><br>： 切换到底线命令模式  在最底下一行输入命令<br></p><p>输入模式: <br><br>字符按键以及Shift组合,输入字符<br><br>ENTER，回车键，换行<br><br>BACK SPACE，退格键，删除光标前一个字符<br><br>DEL，删除键，删除光标后一个字符<br><br>方向键，在文本中移动光标<br><br>HOME/END，移动光标到行首/行尾<br><br>Page Up/Page Down，上/下翻页<br><br>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线<br><br>ESC，退出输入模式，切换到命令模<br></p><p><strong>底线命令模式</strong><br>在命令模式下按下:（英文冒号）就进入了底线命令模式<br><br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多<br><br>在底线命令模式中，基本的命令有（已经省略了冒号: <br><br>q 退出程序<br><br>w 保存文件<br></p><p>按ESC键可随时退出底线命令模式<br></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png" alt="Vi/Vim工作模式"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21日日报</title>
      <link href="/2019/08/21/2019-8-21-seventh-day/"/>
      <url>/2019/08/21/2019-8-21-seventh-day/</url>
      
        <content type="html"><![CDATA[<ol><li>今天学习了同步远程仓库 : fit fetch 兄弟会 test</li><li>合并分支到主分支 : git merge 兄弟会/test</li><li>推主分支到github库 : git push -u 兄弟会/test</li><li>添加标签 : git tag v1.0</li><li>添加标签 : git tag v2.0</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git4中协议</title>
      <link href="/2019/08/20/2019-8-20-sixth-day/"/>
      <url>/2019/08/20/2019-8-20-sixth-day/</url>
      
        <content type="html"><![CDATA[<p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。<br></p><p>最基本的就是<em>本地协议（Local protocol）</em>，所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录<br></p><p>SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和Git）通常都是只读的<br></p><p>ssh-keygen -t rsa -C<br></p><p>Git 协议是一个包含在 Git 软件包中的特殊守护进程<br></p><p>HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的 post-update挂钩（hook）就可以搞定</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubantu安装QQ</title>
      <link href="/2019/08/20/2019-8-20-sixth-technology/"/>
      <url>/2019/08/20/2019-8-20-sixth-technology/</url>
      
        <content type="html"><![CDATA[<p><strong>安装 wine</strong></p><p>git clone <a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git" target="_blank" rel="noopener">https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</a><br><br>cd deepin-wine-for-ubuntu<br><br>sudo sh install.sh<br><br><strong>安装QQ</strong></p><p>wget <a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb</a><br><br>sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb<br><br>sudo apt-get install -f<br></p><p>卸载QQ请自行百度</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git变基和标签操作</title>
      <link href="/2019/08/19/2019-8-19-fifth-day/"/>
      <url>/2019/08/19/2019-8-19-fifth-day/</url>
      
        <content type="html"><![CDATA[<ol><li>变基操作，改写历史提交 把多次提交合并起来</li></ol><p>git rebase -i HEAD~3 变基之后的哈希值与之前的不同 证明变基是重新做的提交 把多次提交合并成了几次提交</p><ol start="2"><li>回撤操作</li></ol><p>git commit –amend -m “提交信息” // 回撤上一次提交并与本次工作区一起提交</p><p>git reset HEAD~2 –hard // 回撤2步</p><p>git reset –files // 从仓库回撤到暂存区</p><p>git reset HEAD // 回撤暂存区内容到工作目录</p><p>git reset HEAD –soft 回撤提交到暂存区</p><p>git reset HEAD –hard // 回撤提交 放弃变更<br>(慎用)</p><p>git reset HEAD^  // 回撤仓库最后一次提交</p><p>git reset –hard commitid // 回撤到该次提交id的位置</p><p>git push -f -u origin 分支名 所有内容都回撤完了 将回撤后的操作强制推送到远程分支</p><ol start="3"><li>标签操作</li></ol><p>git tag // 查看列出所有打过的标签名</p><p>git tag -d 标签名 // 删除对应标签</p><p>git tag 标签名字 // 在当前仓库打个标签</p><p>git tag foo -m “message” // 在当前提交上，打<br>标签foo 并给message信息注释</p><p>git tag 标签名 哈希值 -m “message” // 在某个哈希值上打标签并且写上标签的信息</p><p>git tag foo HEAD~4 // 在当前提交之前的第4个版本上 打标签foo</p><p>git push origin –tags // 把所有打好的标签推送到远程仓库</p><p>git push origin 标签名 // 把指定标签推送到远程仓库</p><p>git stash // 把暂存区的内容 暂时放在其他中 使暂存区变空</p><p>git stash list // 查看stash了哪些存储</p><p>git stash pop // 将stash中的内容恢复到当前目录，将缓存堆栈中的对应stash删除</p><p>git stash apply // 将stash中的内容恢复到当前目录，不会将缓存堆栈中的对应stash删除</p><p>git stash clear // 删除所有缓存的stash</p><p>git pull –tags // 把远程仓库的标签也拉取下来</p><p>git push origin :refs/tags/远程标签名 // 删除远程仓库的标签</p><ol start="4"><li>分支</li></ol><p>git branch 分支名 // 新建分支</p><p>git branch // 查看当前所有分支</p><p>git checkout 分支名 // 检出分支</p><p>git checkout -b 分支名 // 创建并切换分支</p><p>git branch -v // 查看分支以及提交hash值和commit信息</p><p>git merge 分支名 // 把该分支的内容合并到现有分支上</p><p>git branch -d 分支名 // 删除分支</p><p>git branch -D 分支名 // 强制删除 若没有其他分支合并就删除 d会提示 D不会</p><p>git branch -m 旧分支名 新分支名 // 修改分支名</p><p>git branch -M 旧分支名 新分支名 // 修改分支名 M强制修改 若与其他分支有冲突也会创建(慎用)</p><p>git branch -r // 列出远程分支(远程所有分支名)</p><p>git branch -a // 查看远程分支(列出远程分支以及本地分支名)</p><p>git fetch // 更新remote索引</p><p>git push -u origin 分支名 // 将本地分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push 也可解决 git建立远程分支关联时出现fatal … upstram的问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看提交信息</title>
      <link href="/2019/08/18/2019-8-18-fourth-day/"/>
      <url>/2019/08/18/2019-8-18-fourth-day/</url>
      
        <content type="html"><![CDATA[<ol><li>查看提交内容</li></ol><p>git hi -5 // 查看前5条内容</p><p>git hi –grep hello // 过滤提交信息里有hello字眼的内容</p><ol start="2"><li>修改文件名以及移动</li></ol><p>git mv a b // 把a文件名字改成b 并且直接放入<br>git add后的暂存区</p><p>git mv b ./demos/ // 把b文件移动到demos文件夹下</p><ol start="3"><li>对比工作区，暂存区，仓库的差异</li></ol><p>git diff // 查看变更 工作区与暂存区的差异比对</p><p>git diff –cached // 暂存区与提交版本的差异</p><p>git diff HEAD // 工作区与仓库中最后一次提交版本的差别</p><p>git diff 版本哈希值 版本哈希值 // 查看这2个版本哈希之间的区别</p><p>或者 git diff HEAD<del>数字 HEAD</del>数字</p><p>git tag tt HEAD~4 给倒数第5次提交打一个tag tag名字是tt</p><p>git diff tt 就是倒数第5个版本与第一个版本之间的差异</p><p>git diff –cached tt 暂存区与倒数第5个版本之间的比对</p><ol start="4"><li>查看提交信息</li></ol><p>git show HEAD // 查看最后一次提交修改的详细信息 也可以用git show 哈希值 查看对应的内容</p><p>git show HEAD^ // 查看倒数第二次的提交修改详细信息</p><p>git show HEAD^^ 或者git show HEAD~2 查看前2次变更</p><p>git show HEAD 或 git show 哈希值 或者git show tag(标签名) 都可以查看最近一次提交的详细信息</p><ol start="5"><li>查看信息</li></ol><p>git log –pretty=format:’%h %ad | %s%d [%an]’ –graph –date=short<br>// 获取git log里的树形详细信息 包括hasg 日期 提交信息 提交人等</p><p>git log –oneline //拉出所有提交信息 q是退出</p><p>git log -5 // 查看前5次的提交记录</p><p>git log –oneline -5 // 打印出的日志里面只有哈希值和修改的内容备注</p><p>git log 文件名 // 查看该文件的提交</p><p>git log –grep // 想过滤看到的内容   过滤日志</p><p>git log -n // 查看近期提交的n条信息内容</p><p>git log -p // 查看详细提交记录</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用git命令</title>
      <link href="/2019/08/17/2019-8-17-third-day/"/>
      <url>/2019/08/17/2019-8-17-third-day/</url>
      
        <content type="html"><![CDATA[<ol><li>常用git 命令</li></ol><p>git init // 初始化 在工作路径上创建主分支</p><p>git clone 地址 // 克隆远程仓库</p><p>git clone -b 分支名 地址 // 克隆分支的代码到本地</p><p>git status // 查看状态</p><p>git add 文件名 // 将某个文件存入暂存区</p><p>git add b c //把b和c存入暂存区</p><p>git add . // 将所有文件提交到暂存区</p><p>git add -p 文件名 // 一个文件分多次提交</p><p>git stash -u -k // 提交部分文件内容 到仓库 例如本地有3个文件 a b c 只想提交a b到远程仓库 </p><p>git add a b 然后 git stash -u -k 再然后git </p><p>commit -m “备注信息” 然后再push push之后 git stash pop 把之前放入堆栈的c拿出来 继续下一波操作</p><p>git commit -m “提交的备注信息”  // 提交到仓库<br>若已经有若干文件放入仓库，再次提交可以不用git add和git commit -m “备注信息” 这2步， 直接用</p><p>git commit -am “备注信息” // 将内容放至仓库 也可用git commit -a -m “备注信息”</p><p>git commit中的备注信息尽量完善 养成良好提交习惯 例如 git commit -m “变更(范围)：变更的内容”</p><ol start="2"><li>存储密码凭证 设置别名 获取config信息以及配置</li></ol><p>git config –list // 获取config信息</p><p>git config –global core.safecrlf false // 去掉git add 命令后 出现的一堆CR LF提示信息<br>其中CR是回车的意思 LF是换行</p><p>git config –global credential.helper wincred // 存储凭证 (可用于输入一次用户密码后，不再输入 有时我们已经用SSH key 绑定关联好了 但是每次git提交的时候 还是需要你输入用户名密码 在这个时候 敲入这个命令 将凭证存储起来 用户名密码就不需要再次输入了)</p><p>git config –global alias.ci commit // 将commit命令设置别名ci git commit命令将由git ci来代替</p><ol start="3"><li>查看git常用命令</li></ol><p>git helper -a // 查看全部git子命令</p><ol start="4"><li>逐行查看文件的修改历史</li></ol><p>git blame 文件名 // 查看该文件的修改历史</p><p>git blame -L 100,10 文件名 // 从100行开始，到110行 逐行查看文件的修改历史</p><ol start="5"><li>清除</li></ol><p>git clean -n // 列出打算清除的档案(首先会对工作区的内容进行提示)</p><p>git clean -f // 真正的删除</p><p>git clean -x -f // 连.gitignore中忽略的档案也删除</p><p>git status -sb (sb是 short branch) // 简洁的输出git status中的信息</p><ol start="6"><li>删除放入暂存区文件的方法（已commit后）</li></ol><p>git rm 文件名 // 将该文件从commit后撤回到add后<br>g<br>it reset HEAD^ –hard // 删除后 可以用git rm 文件名再回撤一步</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git部分用法</title>
      <link href="/2019/08/16/2019-8-16-secend-day/"/>
      <url>/2019/08/16/2019-8-16-secend-day/</url>
      
        <content type="html"><![CDATA[<ol><li>强制推送（慎用，除非你认为其他冲突等可以丢弃 或者不是很重要）</li></ol><p>git push – force</p><ol start="2"><li>创建文件等小命令</li></ol><p>touch a // 创建一个a文件</p><p>echo 1234 &gt;&gt; a // 把1234这个内容放入a文件</p><p>cat a // 打开a文件 读取出a文件中的内容</p><p>mkdir test // 创建test文件夹</p><p>rm 文件名 // 删除文件</p><p>pwd // 打印当前工作路径</p><ol start="3"><li>安装git的时候 都会安装git bash和git GUI 我们完全也可以使用git GUI来提交版本 与sourcetree等功能相同</li></ol><p>gitk // 用git命令快速打开git GUI</p><ol start="4"><li>文件信息</li></ol><p>ls // 查看当前路径下面的所有文件名</p><p>ls 文件夹名 // 查看对应文件夹中的内容</p><p>ls -l // 拉出最近git提交记录以及对应修改的文件名</p><p>ls -l -a // 拉出最近git提交记录以及对应修改的文件名，隐藏的文件也会显示</p><ol start="5"><li>cd快速切换路径</li></ol><p>cd ~ // 将工作路径快速切换到root</p><p>cd - // 将工作路径切换到上一状态</p><p>cd ../ // 切回到上一个工作路径</p><p>cd 文件夹名 // 进入某个目录</p><p>cd / // 进入根目录</p><ol start="6"><li>vim模式</li></ol><p>vim 文件名 // 新建一个文件</p><p>i 插入内容</p><p>按下esc :wq 保存并退出</p><p>按下esc :q 直接退出</p><p>vim 模式下 文件中#号开头的为注释</p><p>.project 忽略.project文件<br>*.obj 或者 *.exe 忽略一类文件 例如以.obj<br>.exe 结尾的文件</p><p>git check-ignore -v .project 查看ignore中.project的位置</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16日日报</title>
      <link href="/2019/08/16/2019-8-16-dd-day/"/>
      <url>/2019/08/16/2019-8-16-dd-day/</url>
      
        <content type="html"><![CDATA[<h5 id="HEAD：指向当前的工作路径"><a href="#HEAD：指向当前的工作路径" class="headerlink" title="HEAD：指向当前的工作路径"></a>HEAD：指向当前的工作路径</h5><h5 id="config：当前仓库的配置信息-core-用户-远程-分支等信息"><a href="#config：当前仓库的配置信息-core-用户-远程-分支等信息" class="headerlink" title="config：当前仓库的配置信息,core,用户,远程,分支等信息"></a>config：当前仓库的配置信息,core,用户,远程,分支等信息</h5><h5 id="refs-heads-存放项目所有的分支"><a href="#refs-heads-存放项目所有的分支" class="headerlink" title="refs/heads:  存放项目所有的分支"></a>refs/heads:  存放项目所有的分支</h5><h5 id="refs-tags-存放tag-（tag又名标签）"><a href="#refs-tags-存放tag-（tag又名标签）" class="headerlink" title="refs/tags :    存放tag （tag又名标签）"></a>refs/tags :    存放tag （tag又名标签）</h5><h5 id="objects：存放对象"><a href="#objects：存放对象" class="headerlink" title="objects：存放对象"></a>objects：存放对象</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15日日报</title>
      <link href="/2019/08/15/2019-8-15-first-day/"/>
      <url>/2019/08/15/2019-8-15-first-day/</url>
      
        <content type="html"><![CDATA[<ul><li>今天学习了使用 git向github上传文件<br></li><li>我特别想整好，但是又拉不下脸面，不好意思问别人<br></li><li>结果无疑是特别悲惨的 白白浪费了一天时间,也没和同学处好关系<br></li><li>所以以后不能死脑筋 <br></li><li>以后要一定快乐阿  张杰<br></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
