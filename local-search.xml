<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringAOP</title>
    <link href="undefined2019/11/29/2019-11-29-SpringAOP/"/>
    <url>2019/11/29/2019-11-29-SpringAOP/</url>
    
    <content type="html"><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p> <code>Aspect  Orientied    Programming</code>   面向切面编程(面向方面编程)<br>  它其实是对面向对象思想的一个扩展<br>  它可以在不修改原有组件 源代码的情况下 给组件增强功能</p><p> AOP 关注重点是切面   通过配置手段就可以将切面嵌入到合适的位置<br>这样 能实现组件的重复利用  解除切面和目标组件之间的耦合度   大大提供程序的灵活性和可扩展性</p><h2 id="AOP-中涉及到的概念"><a href="#AOP-中涉及到的概念" class="headerlink" title="AOP 中涉及到的概念"></a>AOP 中涉及到的概念</h2><pre><code>Aspect       切面        切面是用来封装共通业务逻辑的   用切面类型创建的对象叫切面对象JoinPoint    连接点      要被加入共通业务的位置   一般封装了方法的信息Pointcut     切点        切点是一堆连接点的集合  Target       目标        要被切入共通业务逻辑的组件 Proxy        代理        被增强之后的目标 叫代理  Advice       通知        通知是一种时机   目标方法调用开始之前   目标方法调用之后 目标方法调用前后    目标方法执行过程中一定执行    目标方法出现异常</code></pre><blockquote><p>简单总结: 切面  –  通知  –  切点    </p></blockquote><h2 id="AOP-编程的实现步骤"><a href="#AOP-编程的实现步骤" class="headerlink" title="AOP 编程的实现步骤"></a>AOP 编程的实现步骤</h2><ol><li>建立一个项目  导入jar包(ioc  aop)   拷贝配置文件到src下<br>建立一个服务类  里面定义两个方法     使用伪代码完成逻辑      使用Spring 容器创建<br>组件  并通过容器获取组件 调用方法 </li><li>定义一个切面类    共通业务逻辑是 在方法调用前打印</li><li>在Spring 容器中创建切面对象  并且通过配置手段 将切面嵌入到方法调用位置  测试   </li><li>写一个DAO 接口  ,写一个DAO 接口的实现类  实现类的代码<br>在Spring 容器中创建DAO 接口的实现类对象<br>并通过容器获取这个对象  调用上面的方法。 然后写一个切面类  里面定义一个方法  这个<br>方法可以打印系统时间  格式  yyyy-MM-dd hh:mm:ss@1970到现在的毫秒数<br>然后通过AOP的手段 将系统时间打印嵌入到 上面的DAO 方法中。</li></ol><h2 id="切点表达式的写法"><a href="#切点表达式的写法" class="headerlink" title="切点表达式的写法"></a>切点表达式的写法</h2><ol><li>bean 限定表达式<br><code>bean(符合条件的对象id)</code>    如果符合对象的id  则对象对应的类型中对应 所有的方法都将切入共通逻辑<br>   允许使用通配符  如 *Dao    既所有的以Dao 结尾的组件id 都将被匹配   </li><li>类型限定表达式<br><code>within(符合条件的类型表达式)</code>     这个表达式的最后一部分一定是类型</li><li>方法限定表达式<br><code>execution(方法限定表达式)</code>     方法限定表达式 包括  <pre><code>权限修饰     返回值类型   方法名(参数说明) throws 异常   </code></pre>其中  返回值类  方法名()  是必须的 </li></ol><h2 id="Spring-AOP-中的五种通知类型"><a href="#Spring-AOP-中的五种通知类型" class="headerlink" title="Spring AOP 中的五种通知类型"></a>Spring AOP 中的五种通知类型</h2><pre><code>&lt;aop:before            前置通知   在目标方法调用前调用 &lt;aop:after             最终通知   在目标方法调用后 一定会调用&lt;aop:after-returing   后置通知   在目标方法调用后 调用   目标方法出现异常就不调用 &lt;aop:after-throwing   异常通知   在目标方法出现异常时调用 &lt;aop:around              环绕通知   在目标方法调用前后 都会调用 </code></pre><h2 id="基于标注的AOP"><a href="#基于标注的AOP" class="headerlink" title="基于标注的AOP"></a>基于标注的AOP</h2><ol><li>建立一个项目 导入jar包(ioc aop)   拷贝配置文件到src下</li><li>开启组件扫描<br>&lt;context:component-scan   base-package=”” /&gt;</li><li>写一个 DAO 接口  </li><li>写一个DAO 的实现类 </li><li>在DAO 实现类上加对应的标注   让其在容器中创建对象  测试 </li><li>写一个切面组件   并在容器中创建对象 </li><li>开启标注形式的  aop<br>&lt;aop:aspectj-autoproxy   proxy-target-class=”true” /&gt;</li><li>在切面类上加 把切面类 变成真正的切面的标注 @Aspect<br>在切面方法上加对应的通知标注   然后在标注中写切点表达式 </li></ol><h2 id="Spring-中的通知对应的标注"><a href="#Spring-中的通知对应的标注" class="headerlink" title="Spring 中的通知对应的标注"></a>Spring 中的通知对应的标注</h2><pre><code>&lt;aop:before            前置通知   在目标方法调用前调用      @Before&lt;aop:after             最终通知   在目标方法调用后 一定会调用  @After&lt;aop:after-returning  后置通知   在目标方法调用后 调用   目标方法出现异常就不调用 @AfterReturning&lt;aop:after-throwing   异常通知   在目标方法出现异常时调用  @AfterThrowing&lt;aop:around              环绕通知   在目标方法调用前后 都会调用   @Around  </code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rest</title>
    <link href="undefined2019/11/28/2019-11-28-rest/"/>
    <url>2019/11/28/2019-11-28-rest/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-MVC-控制器中如何返回JSON"><a href="#Spring-MVC-控制器中如何返回JSON" class="headerlink" title="Spring MVC 控制器中如何返回JSON"></a>Spring MVC 控制器中如何返回JSON</h2><ol><li>搭建一个基于标注的 Spring  MVC</li><li>设计一个控制器方法<br><code>@RequestMapping(&quot;/请求路径&quot;)</code><br><code>@ResponseBody</code><br>返回值类型就是JSON转换前对应的类型     方法名(){<br> return  类型对应的对象；<br>}<br><code>@ReponseBody</code>  需要依赖于 JSON转换包 </li></ol><h2 id="什么是rest"><a href="#什么是rest" class="headerlink" title="什么是rest"></a>什么是rest</h2><p><strong><code>REST</code>即表述性状态传递（英文：Representational State Transfer，简称REST）</strong><br>它可以提高系统的可伸缩性   降低组件之间的耦合度   便于分布应用程序的设计和开发<br>具体做了两个方法的规范  </p><ol><li>对URL的风格做了规范   </li><li>把原来基于操作的设计  </li><li>转换成了基于资源的设计 </li></ol><p>对http协议的请求方式做了规范<br>     get   查询       post  增加       put  更新        delete 删除 </p><h2 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h2><p>  符合rest 设计风格和规范的应用程序设计 叫restful</p><h2 id="Spring-MVC-对-rest的支持"><a href="#Spring-MVC-对-rest的支持" class="headerlink" title="Spring MVC  对 rest的支持"></a>Spring MVC  对 rest的支持</h2><ol><li><p>建立基于标注的 Spring MVC</p></li><li><p>对控制器方法做设计<br><code>@RequestMapping(value=&quot;/请求路径/{路径变量}&quot;,method=RequestMethod.请求方式枚举值)</code><br>public  返回值类型   方法名(@PathVariable(“路径变量名”) 类型  变量{</p><p> }<br>如果要返回JSON  则加 @ResponseBody    —-  依赖json转换包 </p></li><li><p>由于rest风格的请求路径上  没有后缀   所有 DispatcherServlet  上 需要使用  /<br>所有的静态资源 都将被拦截处理   所以要放行静态资源<br>在spring 配置文件中 加 &lt;mvc:default-servlet-handler /&gt;</p></li></ol><h2 id="基于rest的修改"><a href="#基于rest的修改" class="headerlink" title="基于rest的修改"></a>基于rest的修改</h2><ol><li>先把 post 请求 改成 put 请求 </li><li>前端<br>需要把  post 请求改成 put<br>需要加ajax的请求设置   contentType:”application/json”<br>当有上面的设置时  要求参数必须以 json字符串进行传递     把json对象 转换成 json字符串<br><code>eval(&#39;(&#39; + jsonStr +&#39;)&#39;)</code>   JSON.parse(json字符串)<br><code>JSON.stringify(json对象)</code>  可以把json对象转换成json字符串</li><li>服务端<br>把post 请求改成  put<br>还需要对象类型的参数上 加 <code>@RequestBody</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="undefined2019/11/27/2019-11-27-SpringMVC/"/>
    <url>2019/11/27/2019-11-27-SpringMVC/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-MVC-控制器中接收页面请求参数"><a href="#Spring-MVC-控制器中接收页面请求参数" class="headerlink" title="Spring  MVC 控制器中接收页面请求参数"></a>Spring  MVC 控制器中接收页面请求参数</h2><ol><li>在控制器方法上定义 HttpServletRequest 参数 然后使用 request 获取 </li><li>直接定义和页面参数相同的控制器参数  参数名相同则容器自动获取 </li><li>当页面参数  和 控制器参数不一致  如何解决?<br><code>@RequestParam(&quot;参数名&quot;)</code>  可以让请求参数  和 控制器参数对应 </li><li>定义对象类型的参数 —  请求参数名 和 set方法保持对应 </li></ol><h2 id="Spring-控制器中-如何将数据传递给页面"><a href="#Spring-控制器中-如何将数据传递给页面" class="headerlink" title="Spring 控制器中 如何将数据传递给页面"></a>Spring 控制器中 如何将数据传递给页面</h2><ol><li>使用域对象 向页面传输<br><code>request</code>   <code>session</code>   <code>ServletContext</code><br><code>setAttribute(&quot;key&quot;,value)</code></li><li>使用 ModelAndView  进行数据传递<br><code>getModel().put(key,value)</code><br><code>getModelMap().addAttribute(key,value)</code></li><li>使用 Model  进行数据传输<br><code>addAttribute(&quot;key&quot;,value)</code></li><li>使用ModelMap 传递数据<br><code>addAttribute(key,value)</code><br><code>put(key,value)</code></li><li>使用默认的传输机制<br>当定义复杂的自定义控制器参数时  则控制器会自动把这个类型的数据放入<code>request</code>中<br>默认是类名首字母小写  可以使用 <code>@ModelAttribute(&quot;名字&quot;)</code>  改变默认规范  </li></ol><h2 id="Spring-控制器中如何实现重定向"><a href="#Spring-控制器中如何实现重定向" class="headerlink" title="Spring 控制器中如何实现重定向?"></a>Spring 控制器中如何实现重定向?</h2><ol><li>当控制器方法返回 String 类型时<br>在请求路径前  加 redirect:</li><li>当控制器方法返回ModelAndView 时<br><code>RedirectView</code>  结合请求来完成     </li></ol><h2 id="中文乱码的处理"><a href="#中文乱码的处理" class="headerlink" title="中文乱码的处理"></a>中文乱码的处理</h2><p>  tomcat8 中  get 请求没有乱码问题<br>  tomcat8 中  post 请求 乱码的处理  </p><blockquote><p>原来的方式依然可用  但是必须完全遵守之前的方式<br>    request.setCharacterEncoding(“utf-8”);<br>    request.getParameter(“acc_no”)</p></blockquote><blockquote><p>使用编码过滤器   Spring 框架提供的 </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="undefined2019/11/26/2019-11-26-SpringMVC/"/>
    <url>2019/11/26/2019-11-26-SpringMVC/</url>
    
    <content type="html"><![CDATA[<h2 id="MVC的五大核心组件"><a href="#MVC的五大核心组件" class="headerlink" title="MVC的五大核心组件"></a>MVC的五大核心组件</h2><pre><code>DispatcherServlet       请求入口HandlerMapping          请求的转发 让请求和控制器建立一一对应的关系Controller              真正处理请求的组件ModelAndView            封装数据信息和视图信息的对象ViewResolver            视图处理器</code></pre><h2 id="Spring-MVC编写步骤"><a href="#Spring-MVC编写步骤" class="headerlink" title="Spring MVC编写步骤"></a>Spring MVC编写步骤</h2><ol><li>建立项目  导入jar包(ico mvc) 斌拷贝配置文件到src下  在WEB-INF下建立一个jsp页面</li><li>在WEB-INF下 的web.xml中 配置DispatcherServlet 并使用初始化参数 关联Spring 的配置文件contextConfigLocation</li><li>在Spring配置文件中 配置HandlerMapping的实现类SimpleUrlHandlerMapping  并且配置请求和控制器的对应关系</li><li>编写一个控制器的实现类  实现Controller接口 在接口方法中 返回ModelAndView 同时在容器中创建控制器对象</li><li>在Spring 配置文件中 配置 ViewResolver 的实现类 InternalResourceViewResolver 需要配置前缀和后缀</li></ol><h2 id="使用Spring-MVC-访问WEB-INF-下的jsp"><a href="#使用Spring-MVC-访问WEB-INF-下的jsp" class="headerlink" title="使用Spring MVC 访问WEB-INF 下的jsp"></a>使用Spring MVC 访问WEB-INF 下的jsp</h2><h2 id="基于标注的Spring-MVC"><a href="#基于标注的Spring-MVC" class="headerlink" title="基于标注的Spring MVC"></a>基于标注的Spring MVC</h2><ol><li>建立一个项目 导入jar包 (ioc aop mvc) 拷贝配置文件到src下 并在WEB-INF下建立jsp文件</li><li>在web.xml中配置 DispatcherServlet 并通过初始化参数 contextConfigLocation 关联Spring 配置文件</li><li>开启组件扫描 和 标注形式的mvc<br>&lt;context:component-san base-package=”” /&gt;<br>&lt;mvc:annotation-driven /&gt;<br>底层创建了一个 RequestMappingHandlerMapping 的组件</li><li>写一个java类 不用实现Controller接口<br>@RequestMapping(“/请求路径”);<br>控制器方法的返回值可以是 String 也可以是 ModelAndView 方法名随意 参数随意<br>在类上加上对于的标注 @Controller 可以把普通类 变成Controller对象</li><li>配置视图处理器</li></ol><h3 id="applicationContext-配置如下"><a href="#applicationContext-配置如下" class="headerlink" title="applicationContext 配置如下:"></a>applicationContext 配置如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置HandlerMapping的实现类--&gt;</span><br><span class="line">    &lt;bean id=&quot;handerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span><br><span class="line">        &lt;!-- 让请求和控制器建立一一对应关系 --&gt;</span><br><span class="line">        &lt;property name=&quot;mappings&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;toHello.do&quot; &gt;testController&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启组件扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.xdl&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line">    &lt;!-- 开启标注形式的mvc--&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置视图处理器--&gt;</span><br><span class="line">    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="undefined2019/11/25/2019-11-2-jspneizhiduixiang/"/>
    <url>2019/11/25/2019-11-2-jspneizhiduixiang/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringDAO</title>
    <link href="undefined2019/11/25/2019-11-25-SpringDAO/"/>
    <url>2019/11/25/2019-11-25-SpringDAO/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-DAO-对JDBC的改进"><a href="#Spring-DAO-对JDBC的改进" class="headerlink" title="Spring DAO 对JDBC的改进"></a>Spring DAO 对JDBC的改进</h2><pre><code>简化了DAO 实现类组件的编写  对jdbc的操作步骤 做了简化和封装 提供了基于AOP的事务管理  对JDBC中的异常 做了封装   把原来的检查异常 封装成了继承自 运行异常的一个异常类  `DataAccessException` </code></pre><h2 id="SpringDAO的核心类"><a href="#SpringDAO的核心类" class="headerlink" title="SpringDAO的核心类"></a>SpringDAO的核心类</h2><ul><li>JdbcTemplate    <code>Jdbc</code>模板类<br>自动加载驱动   自动获取连接   自动获取sql执行环境    以及 自动释放资源 <ul><li>JdbcDaoSupport   <code>JdbcDAO</code> 的支持类<br>这个类 可以提供模板对象</li></ul></li></ul><h2 id="不继承JdbcDaoSupport"><a href="#不继承JdbcDaoSupport" class="headerlink" title="不继承JdbcDaoSupport"></a>不继承JdbcDaoSupport</h2><blockquote><p>不继承JdbcDaoSupport的方式 完成对数据库的访问<br> 和之前的不同在于 需要我们自己在容器中创建一个模板对象<br>(模板对象依赖于 dataSource)<br> 再把模板 注入给 DAO 的实现类  使用自己的模板完成对应的操作</p></blockquote><p>Spring 的声明式事务<br>    通过Spring 的配置 讲操作纳入到事务管理之中<br>    解除了事务管理代码 和  业务代码的耦合度<br>    当不需要事务管理时  可以从配置文件中将其移除</p><h2 id="Spring-声明式事务的实现步骤"><a href="#Spring-声明式事务的实现步骤" class="headerlink" title="Spring 声明式事务的实现步骤"></a>Spring 声明式事务的实现步骤</h2><ol><li><p>开启声明式事务<br>  tx:annotation-driven   transaction-manager=”事务管理器id”<br> proxy-target-class=”false” /&gt;<br> proxy-target-class  如果是false 代表优先使用sun公司的代理机制生成代理<br> proxy-target-class  如果是true  代表使用CGLIB的代理机制生成代理 </p></li><li><p>在Spring 容器中创建一个事务管理器对象—-  依赖于dataSource  </p> <bean id="事务管理器id" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">   <property name="dataSource" ref="dataSource">  </property></bean></li><li><p>在需要事务管理的类或者方法上加事务管理标注<br>@Transactional  </p><h2 id="Transactional-的属性"><a href="#Transactional-的属性" class="headerlink" title="@Transactional 的属性"></a>@Transactional 的属性</h2><p> rollbackFor    Spring 的声明式事务 默认只针对运行时异常进行事务回滚<br> noRollbackFor   针对指定的运行时异常 不回滚<br> isolation      事务隔离级别  </p></li></ol><h2 id="三大读问题"><a href="#三大读问题" class="headerlink" title="三大读问题"></a>三大读问题</h2><pre><code>脏读       一个事务读取到了另外一个事务没有提交的数据       不可重复读  一个事务在开始时 读取了一份数据    另外一个事务修改了这份数据 并进行了提交当第一个事务再次读取数据时 发现数据发了改变。幻读    一个事务统计了整张表的所有数据    另外一个事务增加了数据 并进行了提交   当再次统计数据时 数据发生了改变         readOnly    只读事务  只有当事务语句都是查询时 才能使用这个属性的值是true默认这个属性的值是false  propagation  事务传播特性  一个方法 去调用另外一个事务方法时 </code></pre><h2 id="事务表现"><a href="#事务表现" class="headerlink" title="事务表现"></a>事务表现</h2><pre><code>Propagation.REQUIRED  如果当前方法没有事务  则 会开启新事务   如果当前方法有事务  则将事务加入到当前事务之中propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</code></pre><h2 id="applicationContext配置"><a href="#applicationContext配置" class="headerlink" title="applicationContext配置"></a>applicationContext配置</h2><pre><code>如下:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;  xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;xsi:schemaLocation=&quot;    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd    http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd    http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.1.xsd    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd    http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd&quot;&gt;  &lt;!--  开启组件扫描  --&gt;&lt;context:component-scan base-package=&quot;com.xdl&quot;&gt;&lt;/context:component-scan&gt;&lt;!--  配置连接池对象  --&gt;&lt;bean  id=&quot;dataSource&quot;  class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot;  value=&quot;oracle.jdbc.OracleDriver&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;url&quot;&gt;         &lt;value&gt;jdbc:oracle:thin:@127.0.0.1:1521:xe&lt;/value&gt;     &lt;/property&gt;    &lt;property name=&quot;username&quot; value=&quot;system&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot;  value=&quot;123456&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!--  创建一个模板对象  --&gt;&lt;bean  id=&quot;jdbcTemplate&quot;  class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;     &lt;constructor-arg  index=&quot;0&quot;  ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;    &lt;!--  开启声明式事务  --&gt;&lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot;     proxy-target-class=&quot;false&quot;/&gt;&lt;!--  创建一个事务管理器  --&gt;&lt;bean  id=&quot;transactionManager&quot;     class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日报哦</title>
    <link href="undefined2019/11/23/2019-11-23-ribao/"/>
    <url>2019/11/23/2019-11-23-ribao/</url>
    
    <content type="html"><![CDATA[<p>最近学习状况良好<br>教室学习气氛也良好<br>真是不可多得的学习好日子<br>欢乐时光就要开始了  </p>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DI实现</title>
    <link href="undefined2019/11/22/2019-11-22-DIImplements/"/>
    <url>2019/11/22/2019-11-22-DIImplements/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是DI"><a href="#什么是DI" class="headerlink" title="什么是DI"></a>什么是DI</h2><blockquote><p>Dependence  Injection   依赖注入<br>把一个组件的值  设置给另外一个组件的过程 叫依赖注入<br>  <code>DI</code>  解决的问题就是组件的装配问题 </p></blockquote><h2 id="DI的三种实现方式"><a href="#DI的三种实现方式" class="headerlink" title="DI的三种实现方式"></a>DI的三种实现方式</h2><ol><li><p>setter 注入<br>参考类型对应的set方法    来进行值的设置<br>在bean 标记中 出现如下配置  <property name="属性名" value="值"> </property>属性名<br>这是设置值 所以参考的是 set方法去掉set 然后首字母小写<br>如果要赋值复杂的值 则需要使用 ref, value 能赋值的类型有  八种基本类型 和 封装类   String  枚举</p></li><li><p>构造器注入<br>参考的是构造方法的参数   只要构造方法的参数能匹配上 则直接调用对应的带参构造<br>在bean 标记中 出现如下配置   把上面的    property 标记 换成   constructor-arg<br>注意我们可以使用 index  替换 name,index 代表参数的编号   编号0开始 </p></li><li><p>自动化注入<br>主要解决复杂值的注入问题<br>只要在bean 标记中 使用  autowire 属性 指定自动化注入的方式即可<br>autowire   的取值有  byName  byType   constructor<br>byName  参考的是属性名<br>byType  参考的是成员变量的类型<br>constructor  参考的是构造方法</p></li></ol><h2 id="参数的注入"><a href="#参数的注入" class="headerlink" title="参数的注入"></a>参数的注入</h2><blockquote><p>简单值的注入   </p></blockquote><p>  简单值包括 八种基本类型  和 对应的封装类   String   枚举<br>  使用连接池的jar包 创建 dataSource 对象     使用容器获取数据源对象(连接池对象)  并通过这个对象<br>  获取数据库连接  </p><blockquote><p>复杂值的注入</p></blockquote><p>  把set注入  或者构造器注入中的 value  改成 ref<br>  或者自动化注入 </p><blockquote><p>集合参数的注入 </p></blockquote><p>  java 中有 <code>List</code>  <code>Map</code>  <code>Set</code>  <code>Properties</code>   可以在Spring 配置文件中 配置对应的标记让其创建出对应的对象</p><pre><code>List     &lt;list&gt;         &lt;value&gt; 值 &lt;/value&gt;    &lt;/list&gt;Set      &lt;set&gt;        &lt;value&gt; 值 &lt;/value&gt;    &lt;/set&gt;Map     &lt;map&gt;        &lt;entry  key=&quot;&quot;   value=&quot;&quot; /&gt;     &lt;/map&gt; Properties     &lt;props&gt;        &lt;prop key=&quot;15966667777&quot;&gt;小泽&lt;/prop&gt;         &lt;prop key=&quot;15966667778&quot;&gt;伟杰&lt;/prop&gt;         &lt;prop key=&quot;15966667779&quot;&gt;小马&lt;/prop&gt;     &lt;/props&gt;</code></pre><h2 id="集合参数的单独定义"><a href="#集合参数的单独定义" class="headerlink" title="集合参数的单独定义"></a>集合参数的单独定义</h2><p>   一个集合参数可以被单独定义出来 然后让其他对象的属性 进行引用   </p><pre><code>&lt;util:list  id=&quot;&quot;    &lt;util:set   id=&quot;&quot;    &lt;util:map   id=&quot;&quot;    &lt;util:properties  id=&quot;&quot;      </code></pre><h2 id="Spring-的EL表达式"><a href="#Spring-的EL表达式" class="headerlink" title="Spring 的EL表达式"></a>Spring 的EL表达式</h2><p>  和之前的区别是 从Spring 容器中取值  语法是 把之前的 <code>$</code> 换成 <code>#</code>   </p>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DI(Dependence Injection)</title>
    <link href="undefined2019/11/21/2019-11-21-Spring/"/>
    <url>2019/11/21/2019-11-21-Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="bean-对象的延迟实例化"><a href="#bean-对象的延迟实例化" class="headerlink" title="bean 对象的延迟实例化"></a>bean 对象的延迟实例化</h2><pre><code>在Spring 容器中  对象默认的作用域是单例的    Spring容器对单例对象 默认是容器启动时创建  可以通过bean 标记的 lazy-init=&quot;true&quot;  让其使用到的时候创建容器启动时不创建。</code></pre><h2 id="什么是DI"><a href="#什么是DI" class="headerlink" title="什么是DI"></a>什么是DI</h2><pre><code>Dependence  Injection   依赖注入(依赖注射)把一个组件的值  设置给另外一个组件的过程 叫依赖注入</code></pre><h2 id="DI的三种实现方式"><a href="#DI的三种实现方式" class="headerlink" title="DI的三种实现方式"></a>DI的三种实现方式</h2><p>setter注入<br>构造器注入<br>自动化注入  </p>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="undefined2019/11/20/2019-11-20-Spring/"/>
    <url>2019/11/20/2019-11-20-Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-框架的构成"><a href="#Spring-框架的构成" class="headerlink" title="Spring 框架的构成"></a>Spring 框架的构成</h2><pre><code>IOC   控制反转      它是Spring框架的核心 DAO   数据访问对象模块   它是对JDBC的封装和简化WebMVC  它是Spring 对 java web的支持 以及  MVC设计模式的支持AOP    面向切面编程    它是对面向对象的扩展 ORM    对象关系映射(是以面向对象的思想访问数据库)  Mybatis</code></pre><h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC?"></a>什么是IOC?</h2><pre><code>  Inverstion   Of  Control  控制反转   程序中需要某个对象时  由原来的new的方式  改成了由容器来进行 创建 和 管理  以及维护组件关系。 这样做的好处是 可以大大降低组件之间的耦合度。 </code></pre><h2 id="Spring-容器"><a href="#Spring-容器" class="headerlink" title="Spring 容器"></a>Spring 容器</h2><pre><code>任何的java 类  都可以在Spring容器中创建对象  并由容器进行管理 以及维护组件关系Spring容器实现了 IOC 和 AOP 机制Spring 容器的类型  BeanFactory 或者是 ApplicationContext类型</code></pre><h2 id="使用Spring容器-完成IOC的步骤"><a href="#使用Spring容器-完成IOC的步骤" class="headerlink" title="使用Spring容器 完成IOC的步骤"></a>使用Spring容器 完成IOC的步骤</h2><pre><code>建立一个项目  导入jar包(ioc相关jar包)   拷贝Spring配置     文件到src下在SPring配置文件中 配置对象创建的说明  &lt;bean id=&quot;对象的引用名&quot; class=&quot;包名.类名&quot;&gt; &lt;/bean&gt;创建Spring 容器对象 创建对象时需要指定配置文件使用对应的API 获取对象  </code></pre><p>  —- 以从容器中获取一个日期对象为例    </p><h2 id="Spring-容器创建对象的三种方式"><a href="#Spring-容器创建对象的三种方式" class="headerlink" title="Spring 容器创建对象的三种方式"></a>Spring 容器创建对象的三种方式</h2><pre><code>构造器方式实例化 &lt;bean  id=&quot;标识符&quot;  class=&quot;包名.类名&quot;&gt; &lt;/bean&gt;    默认调用类型对应的无参构造方法静态工厂方法实例化 本质上是类型调用对应的静态方法 来获取一个对象     类型名.静态方法名()比如在java 代码中创建一个 Calendar 类型的对象 &lt;bean id=&quot;标识符&quot;  class=&quot;包名.工厂类名&quot;  factory-method=&quot;静态方法名&quot;&gt; &lt;/bean&gt;实例工厂方法实例化 本质上是利用一个已经存在的对象 来创建出另外一个类型的对象 &lt;bean id=&quot;标识符&quot;    factory-method=&quot;实例方法名&quot;  factory-bean=&quot;工厂对象的id&quot;&gt; &lt;/bean&gt;  </code></pre><h2 id="Spring-中对象的作用域"><a href="#Spring-中对象的作用域" class="headerlink" title="Spring 中对象的作用域"></a>Spring 中对象的作用域</h2><pre><code>Spring 中 对象默认的作用域 是 单例的   如果希望每次请求 都获取不同的对象则可以使用 bean标记中的 scope 属性指定作用域。scope 默认的取值是 singleton 设置成 prototype 则为非单例的。 当然这里也有request  session 作用域 这到web部分才会涉及。</code></pre><h2 id="Spring-容器中的对象的初始化和销毁"><a href="#Spring-容器中的对象的初始化和销毁" class="headerlink" title="Spring 容器中的对象的初始化和销毁"></a>Spring 容器中的对象的初始化和销毁</h2><pre><code>初始化 一个对象被容器创建之后  可以通过  beans标记中的 default-init-method 属性来指定初始化方法，由于这样影响的范围比较大(影响配置文件中所有的对象) 所以对象对应的类型中如果没有对应的初始化方法程序也不会报错。也可以通过bean 标记中的init-method 属性来指定初始化方法,这种方式 只会影响到一个对象  所以对象对应的类型中如果没有对应的初始化方法程序就会报错。销毁 当一个对象即将消亡时  可以通过  beans标记中的 default-destroy-method 属性来指定销毁方法，由于这样影响的范围比较大(影响配置文件中所有的对象) 所以对象对应的类型中如果没有对应的销毁方法程序也不会报错。也可以通过bean 标记中的destroy-method 属性来指定销毁方法,这种方式 只会影响到一个对象  所以对象对应的类型中如果没有对应的销毁方法程序就会报错 但是销毁方法只针对单例模式的对象。</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>久违的日报</title>
    <link href="undefined2019/11/19/2019-11-19-ribao/"/>
    <url>2019/11/19/2019-11-19-ribao/</url>
    
    <content type="html"><![CDATA[<h2 id="当然了-点开也是日报"><a href="#当然了-点开也是日报" class="headerlink" title="当然了 点开也是日报"></a>当然了 点开也是日报</h2><ol><li>因为没有什么可写的  </li><li>因为太久没写了</li><li>所以只好凑凑数</li><li>所以今天学了Spring的三种创建Bean对象的方式,分别是:<ul><li>构造器方式实例化 </li><li>静态工厂方法实例化 </li><li>实例工厂方法实例化  </li></ul></li></ol><p>而且可以熟练使用，ok 总结完毕</p>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fileter &amp; Listener</title>
    <link href="undefined2019/11/18/2019-11-18-ListenerAndFilter/"/>
    <url>2019/11/18/2019-11-18-ListenerAndFilter/</url>
    
    <content type="html"><![CDATA[<p>#Fileter &amp; Listener</p><p>###web 三大组件</p><pre><code>Servlet是web的三大组件之一 .1.    Servlet2.    Fileter     过滤器3.    Listener 监听器</code></pre><h3 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h3><pre><code>过滤的是请求 . 面向切面编程思想 .  使用步骤:    1.    编写一个类 , 实现Filter接口    2.    通过web.xml 或 注解的方式, 配置过滤器的过滤地址.</code></pre><h5 id="doFilter中的请求与响应对象-为什么不是http的"><a href="#doFilter中的请求与响应对象-为什么不是http的" class="headerlink" title="doFilter中的请求与响应对象 为什么不是http的 ?"></a>doFilter中的请求与响应对象 为什么不是http的 ?</h5><pre><code>过滤器在早期设计时, 不只是针对HTTP请求. 针对所有协议的请求都可以进行过滤.因为我们现在都是使用HTTP协议, 所以很感觉怪异想要操作Http相关的请求对象 与 响应对象 怎么办?   只需要将请求对象强制转换为 HttpServletRequest  将响应对象 强制转换为 HttpServletResponse 即可</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h5 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h5><pre><code>public class UserFilter implements Filter {    /**     * 当过滤器即将销毁时     */    @Override    public void destroy() {        // TODO Auto-generated method stub    }    /**     * 当匹配的请求出现时, 执行. 且执行在 servlet/jsp/html等等所有的服务器资源之前.     */    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain fc)            throws IOException, ServletException {        HttpServletRequest req = (HttpServletRequest) request;        HttpServletResponse res = (HttpServletResponse) response;        //1.    先得到session        HttpSession session = req.getSession();        //2.    判断session中是否存在帐号        if(session.getAttribute(&quot;username&quot;)!=null) {            //3.    存在则放行            fc.doFilter(request, response);        }else {            //4.    不存在则拦截 , 并响应给用户拦截的原因            res.sendRedirect(&quot;userError.jsp&quot;);        }    }    /**     * 当过滤器初始化时     */    @Override    public void init(FilterConfig arg0) throws ServletException {    }}</code></pre><h5 id="WEB-XML代码"><a href="#WEB-XML代码" class="headerlink" title="WEB.XML代码"></a>WEB.XML代码</h5><pre><code>&lt;filter&gt; &lt;filter-name&gt;uf&lt;/filter-name&gt; &lt;filter-class&gt;cn.xdl.demo1.UserFilter&lt;/filter-class&gt;</code></pre>    <filter-mapping>      <filter-name>uf</filter-name>      <url-pattern>/home.jsp</url-pattern>  </filter-mapping>  <filter-mapping>      <filter-name>uf</filter-name>      <url-pattern>/userCenter.jsp</url-pattern>  </filter-mapping><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><pre><code>当多个过滤器的 过滤地址重复时, 就形成了过滤器链, 用户的一次请求, 需要经过多次过滤放行.过滤器链的执行顺序是:    web.xml中配置的顺序:        按照xml中配置的先后顺序 来执行的 , web.xml中配置代码靠前的 ,优先执行.    注解配置的顺序:        按照类名的自然排序 , 排序执行;        注意:    注解配置的过滤器, 一定执行在web.xml过滤器之后        例如:                类名Filter1 执行在类名Filter2之前.            类名Aaa  执行在 类名 Aab之前</code></pre><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><pre><code>事件驱动, 监听的是tomcat产生的事件: 两类事件:    1.    生命周期相关事件     2.    域对象中数据的变化事件</code></pre><h5 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h5><pre><code>用于监听ServletContext的创建 和 销毁    因为ServletContext的创建, 就表示项目的启动.  ServletContext的销毁 就表示项目的关闭.    所以此监听器 ,是用于监听项目的启动 和 关闭的 .        我们常在项目启动时, 进行资源初始化的操作 . 准备一些后续项目中会用到的资源.    在项目关闭时, 进行资源的释放操作 . 解除资源的占用句柄 . 案例:@WebListenerpublic class Listener1 implements ServletContextListener {    /**     * 用于监听应用关闭     */    public void contextDestroyed(ServletContextEvent arg0)  {          // TODO Auto-generated method stub    }    /**     * 用于监听应用启动     */    public void contextInitialized(ServletContextEvent arg0)  {          // TODO Auto-generated method stub    }}</code></pre><h3 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h3><pre><code>@WebListenerpublic class ServletContextAttributeListener1 implements ServletContextAttributeListener {    /**     */    public void attributeAdded(ServletContextAttributeEvent e)  {         //从事件对象中, 得到增加的数据 (键和值)        String key = e.getName();        Object value = e.getValue();        System.out.println(&quot;添加的数据key:&quot;+key+&quot; , 数据值:&quot;+value);    }    /**     * 当删除数据时     */    public void attributeRemoved(ServletContextAttributeEvent e)  {         //从事件对象中, 得到删除的数据 (键和值)        String key = e.getName();        Object value = e.getValue();        System.out.println(&quot;删除的数据key:&quot;+key+&quot; , 数据值:&quot;+value);    }    /**     * 当数据被替换时     */    public void attributeReplaced(ServletContextAttributeEvent e)  {         //从事件对象中,  得到被替换的旧值        String key = e.getName();        Object oldValue = e.getValue();        //从事件对象中, 可以得到ServletContex对象        Object newValue = e.getServletContext().getAttribute(key);        System.out.println(&quot;替换的数据key:&quot;+key+&quot; , 旧的值:&quot;+oldValue+&quot; , 新的值:&quot;+newValue);    }}</code></pre><h3 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h3><pre><code>用于监听session的创建与销毁 .因为我们服务器中每一个session 表示一次用户的会话.一个客户端就会创建一个单独的session.  可以将session的数量, 理解为在线用户的数量. 所以我们经常在session创建与销毁的监听中,  计算当前在线的人数.案例:    @WebListener    public class HttpSessionListener1 implements HttpSessionListener {        /**         * session的创建         */        public void sessionCreated(HttpSessionEvent e)  {             CountUtil.add();        }        /**         * session的销毁         */        public void sessionDestroyed(HttpSessionEvent e)  {             CountUtil.remove();        }    }    public class CountUtil {        private static int count = 0;        private static ArrayList&lt;Integer&gt; countNum = new ArrayList&lt;Integer&gt;();        private static Random r = new Random();        public static void add() {            //5-10的随机数字            int num = r.nextInt(25)+25;            //计数            count+=num;            //将本次计数的值 存储到集合中            countNum.add(num);        }        public static void remove() {            //获取并删除最后 一次 计数的  数量值            int num = countNum.remove(countNum.size()-1);            count-=num;        }        public static int get() {            return count;        }    }</code></pre><h3 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h3><pre><code>用于监听session中的数据的增加, 删除 ,修改/** *监听用户会话状态的变化 */@WebListenerpublic class HttpSessionAttributeListener1 implements HttpSessionAttributeListener {    /**     *     当session中数据增加     */    public void attributeAdded(HttpSessionBindingEvent e)  {         String key = e.getName();        Object value = e.getValue();        System.out.println(&quot;session中增加了数据:  key=&quot;+key+&quot; , value=&quot;+value);    }    /**     *  当session中数据删除     */    public void attributeRemoved(HttpSessionBindingEvent e)  {         String key = e.getName();        Object value = e.getValue();        System.out.println(&quot;session中删除了数据:  key=&quot;+key+&quot; , value=&quot;+value);    }    /**     *     当session中数据被替换     */    public void attributeReplaced(HttpSessionBindingEvent e)  {         String key = e.getName();        Object oldValue = e.getValue();        Object newValue = e.getSession().getAttribute(key);        System.out.println(&quot;session中替换了数据:  key=&quot;+key+&quot; , 旧的值=&quot;+oldValue+&quot;, 新的值=&quot;+newValue);    }}</code></pre><h3 id="尝试使用微信-JS-SDK-中的功能"><a href="#尝试使用微信-JS-SDK-中的功能" class="headerlink" title="尝试使用微信 JS SDK 中的功能"></a>尝试使用微信 JS SDK 中的功能</h3><pre><code>https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="undefined2019/11/16/2019-11-16-Ajax/"/>
    <url>2019/11/16/2019-11-16-Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>一种用于网页 异步 请求的技术.</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><pre><code>用于与服务器进行异步交互  以及 局部页面的刷新.</code></pre><h3 id="Ajax的GET使用步骤"><a href="#Ajax的GET使用步骤" class="headerlink" title="Ajax的GET使用步骤"></a>Ajax的GET使用步骤</h3><pre><code>1.    创建一个 异步请求的对象     var xhr = new XMLHttpRequest();2.    设置请求的方式, 以及 请求的地址    xhr.open(&quot;GET&quot;,&quot;请求地址&quot;);3.    设置请求结果产生时 的 事件处理函数 (当请求状态发生改变时, 执行的函数)    xhr.onreadystatechange = function(){        //此方法在一次ajax中, 会执行五次. 分别表示五种状态        //每次的状态值, 从xhr.readyState属性中得到.        //状态值:        //0.    请求初始化中 , 它的触发, 在new对象时, 此方法不会执行        //1.    请求正在发送, 它的触发在open函数执行时, 此方法如果在open前指定, 则状态发生时 方法执行        //2.    请求发送完毕        //3.    服务器开始响应         //4.    响应完毕, 内容已经得到了.        //请求也存在状态码 , 例如: 404表示资源找不到  500表示服务器内部错误. 200表示成功 302表示重定向..        //请求状态码, 通过xhr.status得到. 如果是200 表示请求成功        if(xhr.readyState == 4){            if(xhr.status == 200){                //成功得到结果                //得到的结果 ,在xhr.responseText中. 是文本内容.            }else{                //请求失败                //提示失败            }        }    }4.    发送请求 (null是参数, 因为GET请求,参数在网址中拼接了, 所以这里传递的是null)    xhr.send(null);</code></pre><h3 id="Ajax的POST请求使用步骤"><a href="#Ajax的POST请求使用步骤" class="headerlink" title="Ajax的POST请求使用步骤"></a>Ajax的POST请求使用步骤</h3><pre><code>1.    创建一个 异步请求的对象     var xhr = new XMLHttpRequest();2.    设置请求的方式, 以及 请求的地址    xhr.open(&quot;POST&quot;,&quot;请求地址&quot;);3.    设置请求结果产生时 的 事件处理函数 (当请求状态发生改变时, 执行的函数)    xhr.onreadystatechange = function(){        if(xhr.readyState == 4){            if(xhr.status == 200){                //成功得到结果                //得到的结果 ,在xhr.responseText中. 是文本内容.            }else{                //请求失败                //提示失败            }        }    }4.    设置请求头部    xhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);5.    发送请求    xhr.send(参数列表);</code></pre><h3 id="使用IE浏览器8-操作上述的案例"><a href="#使用IE浏览器8-操作上述的案例" class="headerlink" title="使用IE浏览器8 操作上述的案例"></a>使用IE浏览器8 操作上述的案例</h3><pre><code>GET或POST请求 都需要修改第1步:    var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre><h3 id="GSON-jar"><a href="#GSON-jar" class="headerlink" title="GSON.jar"></a>GSON.jar</h3><pre><code>&quot;{&quot;name&quot;:&quot;张三&quot;}&quot;;作用:    将Java中的对象 快速的转换为 JSON格式的字符串.    将JSON格式的字符串, 转换为Java的对象.转换JSON字符串的步骤:    1.    引入JAR包    2.    在需要转换JSON字符串的位置编写如下代码即可:        String json = new Gson().toJSON(要转换的对象);案例:    Book b = BookDao.find();    String json = new Gson().toJson(b);    System.out.println(json);</code></pre><h3 id="转换Java对象的步骤"><a href="#转换Java对象的步骤" class="headerlink" title="转换Java对象的步骤"></a>转换Java对象的步骤</h3><pre><code>    1.    引入JAR包    2.    在需要转换Java对象的位置, 编写如下代码:        对象 = new Gson().fromJson(JSON字符串,对象类型.class);案例:    String json = &quot;{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;金苹果\&quot;,\&quot;author\&quot;:\&quot;小泽马\&quot;,\&quot;info\&quot;:\&quot;嘿嘿嘿嘿嘿嘿\&quot;,\&quot;price\&quot;:198.0}&quot;;    Book book = new Gson().fromJson(json, Book.class);    System.out.println(book);</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSTL</title>
    <link href="undefined2019/11/15/2019-11-15-JSTL/"/>
    <url>2019/11/15/2019-11-15-JSTL/</url>
    
    <content type="html"><![CDATA[<h3 id="通过重写URL-得到session"><a href="#通过重写URL-得到session" class="headerlink" title="通过重写URL , 得到session"></a>通过重写URL , 得到session</h3><pre><code>//1.    重写普通的网址  , 通常是超链接/表单中使用的网址//url = response.encodeUrl(url);//2.    重写重定向的网址, 这种网址用于重定向url = response.encodeRedirectUrl(url);</code></pre><h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><pre><code>作用:    用于快速的从域对象中取出数据, 并将结果输出到网页.    也可以用于一些运算, 运算的结果也会输出到网页格式:    ${表达式}</code></pre><h5 id="例如-用于运算"><a href="#例如-用于运算" class="headerlink" title="例如:  用于运算:"></a>例如:  用于运算:</h5><pre><code>运算的结果:${ 1+2+3+4+5 }</code></pre><h5 id="用于取出域对象中的数据"><a href="#用于取出域对象中的数据" class="headerlink" title="用于取出域对象中的数据"></a>用于取出域对象中的数据</h5><pre><code>访问存储数据的格式:    ${存储的key}访问存储的对象属性值:    静态取值:${存储的key.属性名}    静态取值:${存储的key[&quot;属性名&quot;]}    动态取值:${存储的key[属性名的key]}访问集合/数组中的对象    静态取值:${存储的key[下标].属性名}    静态取值:${存储的key[下标][&quot;属性名&quot;]}    动态取值:${存储的key[下标][属性名的key]}有时我们需要使用变量的值. 可以将其先存储到域对象中, 再在el表达式中使用存储的key来操作例如:    &lt;%        User[] data = {new User(&quot;root1&quot;,&quot;123&quot;),new User(&quot;root2&quot;,&quot;223&quot;),new User(&quot;root3&quot;,&quot;323&quot;),new User(&quot;root4&quot;,&quot;423&quot;),};        pageContext.setAttribute(&quot;users&quot;, data);        pageContext.setAttribute(&quot;a&quot;,&quot;username&quot;);    %&gt;    &lt;%for(int i=0;i&lt;data.length;i++){        pageContext.setAttribute(&quot;index&quot;, i);    %&gt;        静态取值:    ${ users[index].username }    &lt;%} %&gt;</code></pre><h3 id="EL表达式-取出数据的流程"><a href="#EL表达式-取出数据的流程" class="headerlink" title="EL表达式 取出数据的流程."></a>EL表达式 取出数据的流程.</h3><pre><code>取出的顺序:    范围从小到大步骤:    1.    先从pageContext中寻找数据是否存在    2.    当pageContext中不存在此数据时 , 去request中寻找数据是否存在    3.    当request中不存在此数据时, 去session中寻找数据是否存在    4.    当session中不存在此数据时, 去application中寻找数据是否存在.    5.    当application中不存在此数据时, 向网页输出 长度为0的字符串 (是&quot;&quot; , 不是null)在上述的流程中, 一旦某一个步骤寻找到了数据 , 就会将数据输出到网页中, 且后续流程不再执行.</code></pre><h3 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h3><pre><code>用于在JSP中引入标签库 .语法格式:    &lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt;属性:    prefix:    是引入的标签库的名称, 用于区分多个标签库.  在使用此标签库中的标签时, 需在标签前添加标签库名称:        例如:    我们引入一个标签库, prefix=a ,则其中的标签在使用时:  &lt;a:标签名&gt;&lt;/a:标签&gt;        uri:    用于匹配标签库. 在引入的tld文件中存在一个uri属性值,  我们uri属性与tld文件中的属性相同时, 则引入这个文件描述的库.</code></pre><h3 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h3><pre><code>是一套JSP的标准标签库. 对JSP的标签进行了扩展. </code></pre><h5 id="IF标签"><a href="#IF标签" class="headerlink" title="IF标签"></a>IF标签</h5><pre><code>作用:    用于判断元素是否显示格式:    &lt;库的名称:if test=&quot;&quot;&gt;&gt;&lt;/库的名称:if&gt;    test属性值:        可以是boolean值, 或运算结果为boolean的el表达式 .案例:    &lt;%-- &lt;heiheihei:if test=&quot;true&quot;&gt;        从前有座山    &lt;/heiheihei:if&gt;    &lt;heiheihei:if test=&quot;false&quot;&gt;        山上有座庙    &lt;/heiheihei:if&gt; --%&gt;    &lt;%        pageContext.setAttribute(&quot;flag&quot;, false)    ;    %&gt;    &lt;heiheihei:if test=&quot;${ flag }&quot;&gt;        从前有座山    &lt;/heiheihei:if&gt;    &lt;%        pageContext.setAttribute(&quot;flag&quot;,true);    %&gt;    &lt;heiheihei:if test=&quot;${ flag }&quot;&gt;        山上有座庙    &lt;/heiheihei:if&gt;</code></pre><h5 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose+when+otherwise标签"></a>choose+when+otherwise标签</h5><pre><code>类似Java中的:    switch+case+default这三个标签, 只有when是由test属性的 ,属性值是boolean值, 允许使用el表达式传入作用:    用于多分支 显示 .案例:    &lt;%        pageContext.setAttribute(&quot;flag&quot;,100);    %&gt;    &lt;heiheihei:choose&gt;        &lt;heiheihei:when test=&quot;${ flag== 1}&quot;&gt;            拔毛烧开水 , 铁锅炖大鹅         &lt;/heiheihei:when&gt;        &lt;heiheihei:when test=&quot;${ flag== 2}&quot;&gt;            英雄不问出处, 流氓不论岁数        &lt;/heiheihei:when&gt;        &lt;heiheihei:when test=&quot;${ flag== 3}&quot;&gt;            衣带渐宽终不悔        &lt;/heiheihei:when&gt;        &lt;heiheihei:when test=&quot;${ flag== 4}&quot;&gt;            好吃不过饺子 , 好闻不过包子        &lt;/heiheihei:when&gt;        &lt;heiheihei:otherwise&gt;            二十四桥明月夜 , 玉人何处教吹箫 .        &lt;/heiheihei:otherwise&gt;    &lt;/heiheihei:choose&gt;</code></pre><h5 id="forEach标签"><a href="#forEach标签" class="headerlink" title="forEach标签"></a>forEach标签</h5><pre><code>用于遍历集合 或 数组元素格式:    &lt;标签库名称:forEach items=&quot;&quot; var=&quot;&quot;&gt;    &lt;/标签库名称:forEach&gt;属性:    items    :    要遍历的数组 或 集合 必须通过el表达式传递    var        :    在循环遍历时, 从数组或集合中取出的每一个元素会被存储到pageContext中, key就是var的值案例:    &lt;%        ArrayList&lt;String&gt; d = new ArrayList&lt;&gt;();        d.add(&quot;拔毛烧开水 , 铁锅炖大鹅 &quot;);        d.add(&quot;英雄不问出处, 流氓不论岁数 &quot;);        d.add(&quot;衣带渐宽终不悔 &quot;);        d.add(&quot;好吃不过饺子 , 好闻不过包子 &quot;);        d.add(&quot;二十四桥明月夜 , 玉人何处教吹箫 . &quot;);        d.add(&quot;厚积薄发&quot;);        d.add(&quot;日月之行若出其中&quot;);        d.add(&quot;锄禾日当午 , 复方草珊瑚&quot;);        //将集合存储到域对象pageContext中, 便于EL表达式取出使用        pageContext.setAttribute(&quot;data&quot;,d);    %&gt;    &lt;heiheihei:forEach items=&quot;${ data }&quot; var=&quot;x&quot;&gt;        &lt;h4&gt;${x }&lt;/h4&gt;    &lt;/heiheihei:forEach&gt;</code></pre><h3 id="如何自定义标签库"><a href="#如何自定义标签库" class="headerlink" title="如何自定义标签库"></a>如何自定义标签库</h3><pre><code>自定义标签库的类:    两种实现方式:        1.    继承SimpleTagSupport         2.    继承TagSupport</code></pre><h3 id="SimpleTagSupport案例"><a href="#SimpleTagSupport案例" class="headerlink" title="SimpleTagSupport案例"></a>SimpleTagSupport案例</h3><pre><code>public class MyTag1 extends SimpleTagSupport {    private static ArrayList&lt;String&gt; d = new ArrayList&lt;&gt;();    static {        d.add(&quot;拔毛烧开水 , 铁锅炖大鹅 &quot;);        d.add(&quot;英雄不问出处, 流氓不论岁数 &quot;);        d.add(&quot;衣带渐宽终不悔 &quot;);        d.add(&quot;好吃不过饺子 , 好闻不过包子 &quot;);        d.add(&quot;二十四桥明月夜 , 玉人何处教吹箫 . &quot;);        d.add(&quot;厚积薄发&quot;);        d.add(&quot;日月之行若出其中&quot;);        d.add(&quot;锄禾日当午 , 复方草珊瑚&quot;);        d.add(&quot;栽种思想，成就行为； 栽种行为，成就习惯； 栽种习惯，成就性格； 栽种性格，成就命运。 ——李嘉诚&quot;);        d.add(&quot;他即使有千般不好，万般辜负，毕竟是我爱过的人。 ——辛夷坞&quot;);        d.add(&quot;世界上最宽阔的是海洋，比海洋更宽阔的是天空，比天空更宽阔的是人的心灵。 ——雨果&quot;);        d.add(&quot;一个民族有一群仰望星空的人，他们才有希望 ——黑格尔&quot;);        d.add(&quot;乌云遮不住太阳，邪恶终将被打倒，真正的胜利永远属于正义。 ——海伦凯勒&quot;);        d.add(&quot;当大浪退去时，我们才知道谁在裸泳 ——巴菲特&quot;);        d.add(&quot;天若有情天亦老，人间正道是沧桑。 ——毛泽东&quot;);        d.add(&quot;上善若水，水善利万物而不争。 ——老子&quot;);        d.add(&quot;钉子有两个长处：一个是“挤”劲，一个是“钻”劲。我们在学习上，也要提倡这种“钉子”精神，善于挤和钻。 ——雷锋&quot;);        d.add(&quot;与其用华丽的外衣装饰自己，不如用知识武装自己 ——马克思&quot;);        d.add(&quot;向死而生的意义是：当你无限接近死亡，才能深切体会生的意义。 ——马丁·海德格尔&quot;);        d.add(&quot;机会不会上门来找人，只有人去找机会。 ——狄更斯&quot;);        d.add(&quot;“原则”是“偏见”的另一个名称。 ——马克·吐温&quot;);        d.add(&quot;人生实如钟摆，在痛苦与倦怠之间摆动。 ——叔本华&quot;);        d.add(&quot;对于世界而言，你是一个人；但是对于某个人，你是他的整个世界 ——狄更斯&quot;);        d.add(&quot;在事情未成功之前，一切总看似不可能。 ——曼德拉&quot;);    }    /**     * 当用户使用此标签     */    @Override    public void doTag() throws JspException, IOException {        //1.    先得到向网页输出数据的 输出流        JspWriter jw = getJspContext().getOut();        //2.    得到要输出的文本        String text = getText();        //3.    将文本输出        jw.write(text);        jw.flush();    }    public String getText() {        //生成随机数, 从集合中随机取出一句名言        Random r = new Random();        int index = r.nextInt(d.size());        return d.get(index);    }}</code></pre><h3 id="TagSupport-案例"><a href="#TagSupport-案例" class="headerlink" title="TagSupport 案例:"></a>TagSupport 案例:</h3><pre><code>public class MyTag2 extends TagSupport {    /*    @Override        public int doAfterBody() throws JspException {            // TODO Auto-generated method stub            return super.doAfterBody();        }        @Override        public int doEndTag() throws JspException {            // TODO Auto-generated method stub            return super.doEndTag();        }*/        /**         * 总数量         */        private int length;        /**         * 一页显示的数量         */        private int pageSize;        public int getLength() {            return length;        }        public void setLength(int length) {            this.length = length;        }        public int getPageSize() {            return pageSize;        }        public void setPageSize(int pageSize) {            this.pageSize = pageSize;        }        @Override        public int doStartTag() throws JspException {            //总页数            int num = length/pageSize + (length%pageSize==0?0:1);            String html = &quot;&lt;div class=\&quot;page\&quot;&gt;&quot;                    + &quot;&lt;button&gt;首页&lt;/button&gt;&amp;nbsp;&quot;                    + &quot;&lt;button&gt;上一页&lt;/button&gt;&amp;nbsp;&quot;;                if(num &lt; 5) {                    for(int i=0;i&lt;num;i++) {                        html = html+&quot;&lt;button&gt;&quot;+(i+1)+&quot;&lt;/button&gt;&quot;;                    }                }else {                    html = html+&quot;&lt;button&gt;1&lt;/button&gt;&quot;;                    html = html+&quot;&lt;button&gt;2&lt;/button&gt;&quot;;                    html = html+&quot;&lt;button&gt;3&lt;/button&gt;&quot;;                    html = html+&quot; ... &quot;;                    html = html+&quot;&lt;button&gt;&quot;+num+&quot;&lt;/button&gt;&quot;;                }                    html = html+ &quot;&amp;nbsp;&lt;button&gt;下一页&lt;/button&gt;&amp;nbsp;&quot;                    + &quot;&lt;button&gt;末页&lt;/button&gt;&amp;nbsp;&quot;                    + &quot;&lt;/div&gt;&quot;;            JspWriter jw = pageContext.getOut();            try {                jw.write(html);                jw.flush();            } catch (IOException e) {                e.printStackTrace();            }            return super.doStartTag();        }    }</code></pre><h3 id="xld文件"><a href="#xld文件" class="headerlink" title="xld文件:"></a>xld文件:</h3><pre><code>xld文件存储在web-inf中!案例:    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;    &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;        version=&quot;2.0&quot;&gt;        &lt;!-- 标签库的描述 --&gt;        &lt;description&gt;            这个标签库编写的目的是为了 , 不知道为啥.        &lt;/description&gt;        &lt;!-- 设置标签库名称 --&gt;        &lt;display-name&gt;xdl&lt;/display-name&gt;        &lt;!-- 描述标签库的版本 --&gt;        &lt;tlib-version&gt;10.1&lt;/tlib-version&gt;          &lt;!-- 描述标签库的短名称 --&gt;        &lt;short-name&gt;xdl&lt;/short-name&gt;        &lt;!-- 用于匹配的uri --&gt;        &lt;uri&gt;http://www.dsb.com/heiheihei&lt;/uri&gt;        &lt;!-- 向标签库中 添加一个标签 --&gt;        &lt;tag&gt;            &lt;!-- 对于标签的解释, 在使用时会提示给用户 --&gt;            &lt;description&gt;这个标签用于向网页中随机生成一条名言&lt;/description&gt;            &lt;!-- 标签名称 --&gt;            &lt;name&gt;heihei&lt;/name&gt;            &lt;!-- 标签的Java类的全名 --&gt;            &lt;tag-class&gt;cn.xdl.tag.MyTag1&lt;/tag-class&gt;            &lt;!-- 标签是否允许包含内容                可以设置的值 :    JSP , 表示允许存在JSP代码                可以设置的值:    empty , 表示为空             --&gt;            &lt;body-content&gt;empty&lt;/body-content&gt;        &lt;/tag&gt;        &lt;!-- 向标签库中 添加一个标签 --&gt;        &lt;tag&gt;            &lt;!-- 对于标签的解释, 在使用时会提示给用户 --&gt;            &lt;description&gt;这个标签用于向网页中加入分页标签&lt;/description&gt;            &lt;!-- 标签名称 --&gt;            &lt;name&gt;page&lt;/name&gt;            &lt;!-- 标签的Java类的全名 --&gt;            &lt;tag-class&gt;cn.xdl.tag.MyTag2&lt;/tag-class&gt;            &lt;!-- 标签是否允许包含内容                可以设置的值 :    JSP , 表示允许存在JSP代码                可以设置的值:    empty , 表示为空             --&gt;            &lt;body-content&gt;empty&lt;/body-content&gt;            &lt;!-- 描述属性 --&gt;            &lt;attribute&gt;                &lt;!-- 属性的描述 --&gt;                &lt;description&gt;这个属性用于设置总数量&lt;/description&gt;                &lt;!-- 属性名 , 与类中的名称必须一致 --&gt;                &lt;name&gt;length&lt;/name&gt;                &lt;!-- 属性是否必须传递 --&gt;                &lt;required&gt;true&lt;/required&gt;                &lt;!-- 是否支持el表达式传递 --&gt;                &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;                &lt;!-- 属性的类型 --&gt;                &lt;type&gt;int&lt;/type&gt;            &lt;/attribute&gt;            &lt;!-- 描述属性 --&gt;            &lt;attribute&gt;                &lt;!-- 属性的描述 --&gt;                &lt;description&gt;这个属性用于一页展示的数量&lt;/description&gt;                &lt;!-- 属性名 , 与类中的名称必须一致 --&gt;                &lt;name&gt;pageSize&lt;/name&gt;                &lt;!-- 属性是否必须传递 --&gt;                &lt;required&gt;true&lt;/required&gt;                &lt;!-- 是否支持el表达式传递 --&gt;                &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;                &lt;!-- 属性的类型 --&gt;                &lt;type&gt;int&lt;/type&gt;            &lt;/attribute&gt;        &lt;/tag&gt;    &lt;/taglib&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP内置对象</title>
    <link href="undefined2019/11/14/2019-11-14-jspneizhiduixiang/"/>
    <url>2019/11/14/2019-11-14-jspneizhiduixiang/</url>
    
    <content type="html"><![CDATA[<h3 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h3><pre><code>用于将一个JSP 或 HTML文件 引入到另一个JSP中.格式:    &lt;%@ include file=&quot;引入的路径&quot; %&gt;</code></pre><h3 id="include-动作"><a href="#include-动作" class="headerlink" title="include 动作"></a>include 动作</h3><pre><code>用于将一个 JSP 或 HTML文件 引入到另一个JSP中.格式:    &lt;jsp:include page=&quot;引入的路径&quot; flush=&quot;true&quot;/&gt;</code></pre><h3 id="include-指令-与-include动作得到区别"><a href="#include-指令-与-include动作得到区别" class="headerlink" title="include 指令 与 include动作得到区别"></a>include 指令 与 include动作得到区别</h3><pre><code>include指令:        在JSP程序的转换时期, 将被引入的JSP文件嵌入到include指令的位置, 然后统一编译执行 (最终生成了一个.java文件)include动作:        在JSP程序的转换时期, 被引入的文件不会嵌入到include动作的位置, 而是等客户端请求时, 再临时将被引入的文件以额外的servlet的方式加载到响应中, (最终生成的是多个.java文件)</code></pre><h3 id="JSP的内置对象-隐含对象"><a href="#JSP的内置对象-隐含对象" class="headerlink" title="JSP的内置对象 (隐含对象)"></a>JSP的内置对象 (隐含对象)</h3><pre><code>内置对象指的是:    JSP引擎在转换JSP文件时, 帮我们的代码在执行之前 创建的一些 供我们使用的对象, 内置对象具备大量的JSP中的常用功能 ,  使用JSP内置对象可以大大的简化我们的开发流程.</code></pre><h2 id="JSP的九大内置对象"><a href="#JSP的九大内置对象" class="headerlink" title="JSP的九大内置对象"></a>JSP的九大内置对象</h2><pre><code>request:    类型:    HttpServletRequest    作用:    请求对象, 包含了请求相关的信息和参数.response:    类型:    HttpServletResponse    作用:    响应对象, 包含了一些用于响应的功能.out:    类型:    JSPWriter    作用:    是打印流,  用于向响应体中输出数据。session：    类型：    HttpSession    作用：    会话对象， 用于状态管理以及 会话跟踪。application:    类型:    ServletContext    作用:    Servlet的上下文,一个应用内存中同时只有一个上下文对象. 用于多个Servlet/JSP之间通信 , ------config:    类型:    ServletConfig    作用:    Servlet的配置对象, 用于配置一些初始的键值对信息.pageContext:    类型:    PageContext    作用:    页面的上下文 , 每一个JSP都拥有一个上下文对象, 用于多段代码之间进行通信.exception:    类型:    Throwable    作用:    当页面的page指令中 isErrorPage属性值为true时, 才会存在此对象, 用于收集错误信息!            通常此对象值为null , 只有其他页面指定errorPage=当前页面时, 且其他页面发生BUG后,跳转到此页面时,对象才不为nullpage:    类型:    Object    作用:    指当前JSP页面自身 , 在JSP引擎生成的代码中 , page对象的赋值代码为:            Object page = this;</code></pre><h2 id="JSP的四大域对象"><a href="#JSP的四大域对象" class="headerlink" title="JSP的四大域对象"></a>JSP的四大域对象</h2><pre><code>九大隐含对象中, 包含了四个较为特殊的隐含对象, 这四个对象我们称其为域对象, 它们都具备存储数据 / 删除数据 / 获取数据 的方法:    存储数据:        setAttribute(String key ,Object value);    获取数据:        Object value = getAttribute(String key);    删除数据:        removeAttribute(String key);这四个域对象 , &apos;域&apos; 指的是作用域 ! 分别是:    pageContext    :    页面的上下文            作用域:    一个JSP页面    request        :    请求对象                作用域:    一次请求    (请求可以被转发 , 一次请求可能包含多个JSP页面)    session        :    会话对象                作用域:    一次会话    (一次会话可能包含多次请求)    application    :    servlet上下文对象    作用域:    一次服务(服务器的启动到关闭)    (一次服务可能包含多次会话)</code></pre><h3 id="JSP-useBean动作"><a href="#JSP-useBean动作" class="headerlink" title="JSP useBean动作"></a>JSP useBean动作</h3><pre><code>作用:    向四大域对象中, 存储bean对象.格式:        &lt;jsp:useBean             id=&quot;存储时的key&quot;            scope=&quot;page/request/session/application&quot;            class=&quot;要存储的对象类型&quot;&gt;        &lt;/jsp:useBean&gt;</code></pre><h3 id="JSP-useBean-setProperty动作"><a href="#JSP-useBean-setProperty动作" class="headerlink" title="JSP useBean + setProperty动作"></a>JSP useBean + setProperty动作</h3><pre><code>作用:    向四大域对象中, 存储bean对象. 且设置属性值格式:        &lt;jsp:useBean             id=&quot;存储时的key&quot;            scope=&quot;page/request/session/application&quot;            class=&quot;要存储的对象类型&quot;&gt;        &lt;/jsp:useBean&gt;        &lt;jsp:setProperty name=&quot;存储时的key&quot; property=&quot;属性名&quot; value=&quot;属性值&quot;/&gt;        //setProperty动作可以出现多次案例:    &lt;jsp:useBean id=&quot;p&quot; scope=&quot;page&quot; class=&quot;cn.xdl.bean.Person&quot;&gt;&lt;/jsp:useBean&gt;    &lt;jsp:setProperty name=&quot;p&quot; property=&quot;name&quot; value=&quot;刘健健&quot;/&gt;    &lt;jsp:setProperty name=&quot;p&quot; property=&quot;age&quot; value=&quot;18&quot;/&gt; </code></pre><h3 id="JSP-useBean-setProperty动作-快速获取表单提交的内容"><a href="#JSP-useBean-setProperty动作-快速获取表单提交的内容" class="headerlink" title="JSP useBean+ setProperty动作 快速获取表单提交的内容"></a>JSP useBean+ setProperty动作 快速获取表单提交的内容</h3><pre><code>格式:    &lt;jsp:useBean             id=&quot;存储时的key&quot;            scope=&quot;page/request/session/application&quot;            class=&quot;要存储的对象类型&quot;&gt;        &lt;/jsp:useBean&gt;    &lt;jsp:setProperty name=&quot;存储时的key&quot; property=&quot;属性名&quot;/&gt;注意:    如果setProperty动作中 , property的值即是对象的属性名, 又是我们用户请求的参数的名称的话, 会自动将参数获取到并赋值给对象</code></pre><h3 id="JSP-getProperty动作"><a href="#JSP-getProperty动作" class="headerlink" title="JSP getProperty动作"></a>JSP getProperty动作</h3><pre><code>作用:    从四大域对象中 取出某个对象的属性, 并显示到网页中语法格式:    &lt;jsp:getProperty name=&quot;对象的key&quot; property=&quot;属性名&quot;&gt;案例:    &lt;jsp:useBean id=&quot;per&quot; scope=&quot;session&quot; class=&quot;cn.xdl.bean.Person&quot;&gt;&lt;/jsp:useBean&gt;    &lt;jsp:setProperty property=&quot;name&quot; name=&quot;per&quot; value=&quot;刘健&quot;/&gt;    &lt;jsp:setProperty property=&quot;age&quot; name=&quot;per&quot; value=&quot;28&quot;/&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;jsp:getProperty property=&quot;name&quot; name=&quot;per&quot;/&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP引擎</title>
    <link href="undefined2019/11/13/2019-11-13-jspjichu/"/>
    <url>2019/11/13/2019-11-13-jspjichu/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>Java Server Pages  是Java的动态网页技术 </code></pre><h3 id="JSP引擎"><a href="#JSP引擎" class="headerlink" title="JSP引擎"></a>JSP引擎</h3><pre><code>引擎原理:     JSP引擎用于将JSP文件, 转换为Servlet    1.    在服务器启动时 , JSP引擎读取.jsp文件.    2.    将文件转换为Servlet的代码 , 并给servlet添加映射地址为 jsp的文件名称.    3.    当用户浏览器访问 jsp文件名称时,  其实请求的不是jsp文件, 而是生成的servlet    4.    servlet负责给浏览器进行响应.例如:     demo4.jsp文件:        &lt;body&gt;            &lt;h3&gt;我们的第一个JSP文件&lt;/h3&gt;            &lt;%                for(int i=0;i&lt;100;i++){                    %&gt;                    &lt;div&gt;从前有座山&lt;/div&gt;                    &lt;%                }            %&gt;        &lt;/body&gt;    demo4_jsp.java        PrintWriter out = response.getWriter();                out.println(&quot;&lt;body&gt;&quot;);        out.println(&quot;&lt;h3&gt;我们的第一个JSP文件&lt;/h3&gt;&quot;);                for(int i=0;i&lt;100;i++){        out.println(&quot;&lt;div&gt;从前有座山&lt;/div&gt;&quot;);                    }        out.println(&quot;&lt;/body&gt;&quot;);</code></pre><h3 id="JSP语法结构"><a href="#JSP语法结构" class="headerlink" title="JSP语法结构"></a>JSP语法结构</h3><pre><code>JSP文件保存的路径:    webContent目录下JSP文件 可以包含HTML代码, Java代码, 以及JSP特有的标记.</code></pre><h5 id="Java代码-声明区"><a href="#Java代码-声明区" class="headerlink" title="Java代码 声明区"></a>Java代码 声明区</h5><pre><code>指的是Java的成员代码位置,  在JSP声明区中编写的Java代码, 会生成到servlet的成员位置.语法:    &lt;%!        这里用于编写Java代码, 且会生成到声明区    %&gt;</code></pre><h5 id="Java代码-执行区"><a href="#Java代码-执行区" class="headerlink" title="Java代码 执行区"></a>Java代码 执行区</h5><pre><code>指的是Servlet的service方法中. 用户每次请求 都会执行语法:    &lt;%        Java代码    %&gt;</code></pre><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><pre><code>用于快速的将Java代码中的变量输出到网页中.语法:    &lt;%=变量名%&gt;转换的Java:    out.print(变量名);</code></pre><h5 id="JSP中如何编写注释"><a href="#JSP中如何编写注释" class="headerlink" title="JSP中如何编写注释"></a>JSP中如何编写注释</h5><pre><code>因为JSP文件包含了三种语法结构 (java/html/jsp)所以 ,三种语法结构的注释 都可以起到注释的效果:html注释:            &lt;!--     html的注释 --&gt;        在JSP中, HTML的注释会被JSP引擎认为是HTML代码 , 会转换为out.write(&quot;&lt;!-- --&gt;&quot;);Java注释:        单行:    //        多行:    /*  */        文档:    /** */        在JSP中, Java的注释 会被JSP引擎认为是Java代码 ,会原封不动的放到_jsp.java文件中.JSP注释:        &lt;%-- JSP注释 --%&gt;        在JSP引擎将jsp文件 转换为.java文件时, 会忽略JSP注释的部分.</code></pre><h3 id="JSP-三大指令"><a href="#JSP-三大指令" class="headerlink" title="JSP 三大指令"></a>JSP 三大指令</h3><pre><code>指令的格式:    &lt;%@ 指令名称 属性名=值 属性名2=值 ... 属性n=值 %&gt;</code></pre><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><pre><code>用于设置页面完整格式:&lt;%@ page    language=&quot;java&quot;    extends=&quot;继承的类&quot;    buffer=&quot;数值|none&quot; -- 缓冲大小 ,none表示不缓冲 ,默认是8kb    session=&quot;true|false&quot; --true:自动创建session  false时表示不自动创建    autoFlush=&quot;true|false&quot; --true:缓冲器自动清除, 默认true    isThreadSafe=&quot;true|false&quot; --&lt;%%&gt;中的代码 是否是同步的 , true表示同步, 默认false    contentType=&quot;text/html;charset=utf-8&quot; -- 内容类型以及编码格式    errorPage=&quot;网页地址&quot; -- 当JSP代码出错误, 页面由指定地址进行显示 *    isErrorPage=&quot;true|false&quot; --true:当前页面是处理错误的页面. 只有为true时, 才可以查看异常信息. *    import=&quot;导包列表&quot; -- 属性值是一个或多个导入的包 , 包于包之间使用逗号隔开即可   %&gt;</code></pre><h3 id="指定项目全局错误页面"><a href="#指定项目全局错误页面" class="headerlink" title="指定项目全局错误页面"></a>指定项目全局错误页面</h3><pre><code>编写项目的web.xml在根节点中, 加入子节点:    &lt;error-page&gt;        &lt;error-code&gt;404&lt;/error-code&gt;        &lt;location&gt;处理404的页面地址&lt;/location&gt;    &lt;/error-page&gt;    &lt;error-page&gt;        &lt;error-code&gt;500&lt;/error-code&gt;        &lt;location&gt;处理500的页面地址&lt;/location&gt;    &lt;/error-page&gt;</code></pre><h4 id="模仿jsp引擎将jsp代码转化为servlet代码"><a href="#模仿jsp引擎将jsp代码转化为servlet代码" class="headerlink" title="模仿jsp引擎将jsp代码转化为servlet代码"></a>模仿jsp引擎将jsp代码转化为servlet代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 模拟Tomcat中的 JSP引擎</span><br><span class="line"> * @author lwj</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">static Scanner input = new Scanner(System.in);</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//边读边写</span><br><span class="line">System.out.println(&quot;请输入要转换的HTML路径:&quot;);</span><br><span class="line">String htmlPath = input.nextLine();</span><br><span class="line">System.out.println(&quot;请输入要保存的Servlet路径&quot;);</span><br><span class="line">String servletPath = input.nextLine();</span><br><span class="line"></span><br><span class="line">//1.创建输入流 , 读取HTML文件</span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(htmlPath), &quot;UTF-8&quot;));</span><br><span class="line">//2.创建输出流, 用于生成servlet.java文件</span><br><span class="line">PrintWriter pw = new PrintWriter(servletPath);</span><br><span class="line">//3.先打印Servle头部的一些信息</span><br><span class="line">pw.println(&quot;package servlet;&quot;);</span><br><span class="line">pw.println(&quot;&quot;);</span><br><span class="line">pw.println(&quot;import java.io.IOException;&quot;);</span><br><span class="line">pw.println(&quot;import javax.servlet.ServletException;&quot;);</span><br><span class="line">pw.println(&quot;import javax.servlet.annotation.WebServlet;&quot;);</span><br><span class="line">pw.println(&quot;import javax.servlet.http.HttpServlet;&quot;);</span><br><span class="line">pw.println(&quot;import javax.servlet.http.HttpServletRequest;&quot;);</span><br><span class="line">pw.println(&quot;import javax.servlet.http.HttpServletResponse;&quot;);</span><br><span class="line">pw.println(&quot;/**&quot;);</span><br><span class="line">pw.println(&quot; * 由引擎转换的Servlet类&quot;);</span><br><span class="line">pw.println(&quot; */&quot;);</span><br><span class="line">pw.println(&quot;@WebServlet(\&quot;/servlet.do\&quot;)&quot;);</span><br><span class="line">pw.println(&quot;public class HeiHeiServlet extends HttpServlet &#123;&quot;);</span><br><span class="line">pw.println(&quot;    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&quot;);</span><br><span class="line">pw.println(&quot;response.setContentType(\&quot;text/html;charset=utf-8\&quot;);&quot;);</span><br><span class="line"></span><br><span class="line">//边读边写</span><br><span class="line">String text = null;</span><br><span class="line">while((text = br.readLine())!=null) &#123;</span><br><span class="line">if(text.contains(&quot;&lt;%&quot;)) &#123;</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(text);</span><br><span class="line">while(true) &#123;</span><br><span class="line">text = br.readLine();</span><br><span class="line">sb.append(text);</span><br><span class="line">if(text.contains(&quot;%&gt;&quot;)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String javaCode = sb.toString().replace(&quot;&lt;%&quot;, &quot;&quot;);</span><br><span class="line">javaCode = javaCode.replace(&quot;%&gt;&quot;, &quot;&quot;);</span><br><span class="line">pw.println(javaCode);</span><br><span class="line">pw.flush();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">text = text.replace(&quot;\&quot;&quot;, &quot;&apos;&quot;);//&quot;  \&quot;</span><br><span class="line">pw.println(&quot;    response.getWriter().append(\&quot;&quot;+text+&quot;\&quot;);&quot;);</span><br><span class="line">pw.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pw.println(&quot;    &#125;&quot;);</span><br><span class="line">pw.println(&quot;&#125;&quot;);</span><br><span class="line">pw.close();</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(&quot;Java文件生成完毕了&quot;);</span><br><span class="line"></span><br><span class="line">//C:\code\29\code1\day11_JSP\WebContent\demo1.html</span><br><span class="line">//C:\Users\lwj\Desktop\视频\后端\day05_JSP\HeiHeiServlet.java</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie与Session</title>
    <link href="undefined2019/11/12/2019-11-12-cookieandsession/"/>
    <url>2019/11/12/2019-11-12-cookieandsession/</url>
    
    <content type="html"><![CDATA[<h2 id="会话跟踪-状态管理"><a href="#会话跟踪-状态管理" class="headerlink" title="会话跟踪 ( 状态管理 )"></a>会话跟踪 ( 状态管理 )</h2><pre><code>HTTP协议是无状态的 , 我们的服务器在与客户端进行交互时, 没有记忆.两种方式来实现状态管理:    1.    Cookie技术:        将状态 , 存储到客户端中      2.    Session技术:        将id存储在客户端中,  将状态存储在服务器中.</code></pre><h3 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h3><pre><code>技术实现步骤以及原理:    1.    当服务器向客户端响应时 , 可以向响应头部加入Cookie , 每一个Cookie表示一个键值对.    2.    浏览器在接收到响应后, 如果存在Cookie , 则会将Cookie存储在文本文件中 (.txt)        存储时, 会存储的信息有:    服务器的域 , 路径 , Cookie键 ,Cookie的值, 存储时长...    3.    当浏览器向客户端请求时, 会遍历 Cookie的文本文件, 将匹配新请求地址的Cookie 携带上, 放在请求头部, 发送给服务器 !        Cookie匹配的规则:                当cookie存储的域相同时,  路径匹配时 才会将Cookie发送给服务器.</code></pre><h4 id="如何创建Cookie"><a href="#如何创建Cookie" class="headerlink" title="如何创建Cookie"></a>如何创建Cookie</h4><pre><code>Cookie在Java中的体现 就是一个表示键值对的 Java类, 类名为: Cookie .格式:    Cookie cookie = new Cookie(String name,String value);    Cookie cookie = new Cookie(String name,String value);    cookie.setMaxAge(Integer.MAX_VALUE);    cookie.setPath(&quot;/&quot;);    response.addCookie(cookie);</code></pre><h4 id="如何将Cookie添加到响应头部"><a href="#如何将Cookie添加到响应头部" class="headerlink" title="如何将Cookie添加到响应头部"></a>如何将Cookie添加到响应头部</h4><pre><code>通过响应对象, 将Cookie添加到响应头部格式:    response.addCookie(Cookie cookie);一次响应, 可以添加n个cookie  .如果浏览器中已经存储过与某个Cookie的name相同的Cookie , 再次存储时会覆盖value</code></pre><h4 id="如何从请求头部-得到之前存储的所有Cookie"><a href="#如何从请求头部-得到之前存储的所有Cookie" class="headerlink" title="如何从请求头部 得到之前存储的所有Cookie"></a>如何从请求头部 得到之前存储的所有Cookie</h4><pre><code>因为一个域 和 路径下, 可能存在多个Cookie  , 所以获取的不是单个Cookie , 而是一个数组:Cookie[] cookies = request.getCookies();//    如果从未存储过, 则返回的数组值是 null </code></pre><h4 id="得到Cookie后-如何取出其中的键和值"><a href="#得到Cookie后-如何取出其中的键和值" class="headerlink" title="得到Cookie后, 如何取出其中的键和值."></a>得到Cookie后, 如何取出其中的键和值.</h4><pre><code>获取Cookie的键:    String name = cookie.getName();获取Cookie的值:    String value = cookie.getValue();</code></pre><h4 id="如何调整Cookie存储时长"><a href="#如何调整Cookie存储时长" class="headerlink" title="如何调整Cookie存储时长."></a>如何调整Cookie存储时长.</h4><pre><code>cookie.setMaxAge(int 秒);    传入的值:        -    负数        :    默认-1 , 表示浏览会话结束时 删除.        -    正数        :    存活的秒数, 例如: 60*60*24*365*10 表示十年.        -    0        :    经常用于覆盖一个cookie时使用, 作用为0秒后删除 (立即删除)</code></pre><h4 id="Cookie存储时-路径问题的解决"><a href="#Cookie存储时-路径问题的解决" class="headerlink" title="Cookie存储时, 路径问题的解决."></a>Cookie存储时, 路径问题的解决.</h4><pre><code>路径匹配的规则:    -    Cookie的替换:    只能由相同域 , 相同路径的 完成替换.    -    Cookie的获取:    只能由相同域 , 相同路径或子路经 获取例如:    A地址:        localhost/x/a.do    B地址:        localhost/x/b.do    C地址:        localhost/c.do    A存储数据时:    a/b可以获取 ,a/b可以替换.   c不能获取 也不能替换.    C存储数据时: a/b/c可以获取 , c可以替换.Cookie的路径问题, 经常影响我们的开发 . JavaWeb 给我们提供了一个Cookie的方法, 用于设置Cookie的路径.通常我们会将cookie的路径设置为/ (根路径)格式:    cookie.setPath(&quot;/&quot;);</code></pre><h3 id="Cookie的优缺点"><a href="#Cookie的优缺点" class="headerlink" title="Cookie的优缺点:"></a>Cookie的优缺点:</h3><pre><code>缺点:    1.    Cookie存储的数据类型有限制 , 只能是字符串    2.    数据存储的大小 ,有限制, 最大为4kb    3.    数据存储在用户的计算机上 , 不安全    4.    受限于用户的浏览器设置, 当浏览器禁止使用Cookie时 , cookie就无法再存储了.优点:    数据存储在客户端 , 分散了服务器的压力. </code></pre><h3 id="Session技术-会话"><a href="#Session技术-会话" class="headerlink" title="Session技术 (会话)"></a>Session技术 (会话)</h3><pre><code>基于Cookie实现的技术 ,  是Java中的一个键值对的容器.  就像我们常用的Map集合.技术原理:    1.    浏览器访问服务器时, 服务器可以选择创建Session对象.    2.    session对象在创建时, 会生成一个id , 我们称其为sessionid , sessionid是Session的密钥, 是唯一的 !    3.    session创建完毕后, 会自动将sessionid以cookie的形式 存储到用户的浏览器中.    4.    当浏览器再次访问服务器时, 会自动携带sessionid 发送给服务器.    5.    服务器得到sessionid后, 会去自动匹配找到对应的session对象, 供用户使用.</code></pre><h4 id="如何获取session对象"><a href="#如何获取session对象" class="headerlink" title="如何获取session对象"></a>如何获取session对象</h4><pre><code>在Java中, session是一个Java对象, 对象的类型为:  HttpSession获取Session对象的格式:    格式1.    无参方法:            HttpSession session = request.getSession();            内部调用了 一参方法, 且传入true    格式2.    一参方法            HttpSession session = request.getSession(boolean isNew);            用于获取session  参数:            true:    根据当前浏览器传入的sessionid ,寻找session对象并返回 . 如果不存在 , 则创建新的session并返回            false:    根据当前浏览器传入的sessionid ,寻找session对象并返回 . 如果不存在 , 则返回null;</code></pre><h4 id="session的常用方法"><a href="#session的常用方法" class="headerlink" title="session的常用方法"></a>session的常用方法</h4><pre><code>1.    存储数据    session.setAttribute(String key,Object value);2.    获取数据    Object value = session.getAttribute(String key);3.    删除数据    session.removeAttribute(String key);4.    销毁session (应用场景:    百分之99的情况是: 退出登录)    session.invalidate();</code></pre><h4 id="session的存活时长"><a href="#session的存活时长" class="headerlink" title="session的存活时长"></a>session的存活时长</h4><pre><code>session的默认时长为:    30分钟! 指的是:    举例用户的上一次访问大于30分钟后, session自动删除.设置Session时长:    方式1.    修改单个session的时长:            session.setMaxInactiveInterval(int 秒);    方式2.    修改tocmat下, 所有session的默认时长:            独立环境:    寻找到tomcat/conf/web.xml文件            开发环境:    寻找到Servers项目中的 web.xml            修改web.xml中  session-config节点                &lt;session-config&gt;                    &lt;session-timeout&gt;数值分钟&lt;/session-timeout&gt;                &lt;/session-config&gt;</code></pre><h4 id="session的优缺点"><a href="#session的优缺点" class="headerlink" title="session的优缺点"></a>session的优缺点</h4><pre><code>优点:    1.    数据存储在服务器中, 安全.    2.    session存储时的值类型为: Object , 可以存储任意类型数据.    3.    可存储的数据大小, 理论上是无上限的. 缺点:    数据在服务器的内存中存储, 内存通常是有限的, 会对服务器造成大量的压力. 很容易耗尽服务器资源.</code></pre><h3 id="Cookie结束-和-Session技术-不是互斥的"><a href="#Cookie结束-和-Session技术-不是互斥的" class="headerlink" title="Cookie结束 和 Session技术 不是互斥的"></a>Cookie结束 和 Session技术 不是互斥的</h3><pre><code>Cookie和session是结合使用的.    通常:        对于安全不敏感的数据 . 建议使用Cookie存储        对于安全敏感的数据, 建议使用session存储        对于安全敏感, 且较大的数据, 存储在数据库.</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet请求与响应</title>
    <link href="undefined2019/11/11/2019-11-11-servlet/"/>
    <url>2019/11/11/2019-11-11-servlet/</url>
    
    <content type="html"><![CDATA[<h3 id="HttpGET请求-与-HttpPOST请求的区别"><a href="#HttpGET请求-与-HttpPOST请求的区别" class="headerlink" title="HttpGET请求 与 HttpPOST请求的区别:"></a>HttpGET请求 与 HttpPOST请求的区别:</h3><pre><code>GET请求:    -    请求的参数 ,以键值对的形式    存储在网址中 ,在网址中, 编写在?后, 由1个或多个键值对组成, 键与值之间使用等号连接, 多个键值对之间使用&amp;分割.    -    只能传输字符串类型的参数.    -    网址的最大长度为4kb 通常支持的文字 2048 个文字    -    数据传输不安全    tomcat8+版本    :    GET请求不会乱码POST请求:    -    请求的数据, 以键值对的形式存储在请求体中,     -    请求体是一个单独的数据包 , 较GET请求而言, 安全.    -    可以传输任意类型的数据    -    数据的大小 ,理论上是无上限的.    tomcat8+版本    :    Post请求默认编码为 ISO-8859-1 (不支持中文)</code></pre><h3 id="什么样的请求是GET"><a href="#什么样的请求是GET" class="headerlink" title="什么样的请求是GET"></a>什么样的请求是GET</h3><pre><code>以我们目前所学习的技术来说 , 除了表单提交时method=&quot;POST&quot; ,其他的访问方式都是GET请求例如:    -    点击超链接 访问    -    通过js:    window.location.href=&apos;&apos; 访问    -    浏览器中输入网址 + 回车    -    表单提交时 ,method=&quot;GET&quot; 或 默认    -    ajax的get请求    -    Java代码的URL类的GET请求.</code></pre><h3 id="什么样的请求时PSOT"><a href="#什么样的请求时PSOT" class="headerlink" title="什么样的请求时PSOT"></a>什么样的请求时PSOT</h3><pre><code>1.    表单提交时method=&quot;POST&quot;2.    ajax的post请求3.    Java代码的URL类的POST请求.</code></pre><h5 id="请求的乱码问题"><a href="#请求的乱码问题" class="headerlink" title="请求的乱码问题"></a>请求的乱码问题</h5><pre><code>解决乱码的两种格式:    格式1.        可用于tomcat8版本之前的GET请求乱码 以及 所有版本的POST请求乱码:        解决方案:    将乱码的文字, 按照乱码的编码ISO-8859-1转换为字节数组, 再按照正常的编码UTF-8组装为 文字;        案例:        //1.    接收用户传递的参数        String username = request.getParameter(&quot;username&quot;);        //解决乱码        {            //1.    将乱码的文字, 通过ISO-8859-1编码 打碎成字节数组            byte[] bytes = username.getBytes(&quot;ISO-8859-1&quot;);            //2.    通过UTF-8编码, 将字节数组 重新组装为 正常文字            username = new String(bytes, &quot;UTF-8&quot;);        }    格式2.        格式1 解决乱码适用于参数较少的情况, 如果参数过多, 解决起来极其麻烦.        tomcat为我们提供了 设置请求体编码的方式:        格式:    request.setCharacterEncoding(&quot;UTF-8&quot;);        注意:    只有POST请求 ,才有请求体!                解决请求乱码的代码, 必须运行在获取参数之前    </code></pre><h5 id="响应的乱码问题"><a href="#响应的乱码问题" class="headerlink" title="响应的乱码问题"></a>响应的乱码问题</h5><pre><code>方式1.    设置网页的内容类型, 以及 网页的编码格式:    response.setContentType(&quot;text/html;charset=utf-8&quot;);方式2.    设置网页的编码格式 (因为没有设置网页内容类型为html , 所以浏览器解析时也是乱码)    response.setCharacterEncoding(&quot;UTF-8&quot;);    注意:        设置响应乱码的两种方式, 都必须写在 响应内容之前 !</code></pre><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题 :"></a>线程安全问题 :</h3><pre><code>Servlet的service方法, 每次被请求时, 调用.这个调用很特殊 , 是在新的子线程中调用的 , 当service方法执行完毕, 子线程死亡了.可以简单的理解为: service方法每次执行都是一个新的线程.    @WebServlet(&quot;/s1.do&quot;)    public class Servlet1 extends HttpServlet {        //剩余票数        private int count = 10;        Object o = new Object();        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            synchronized (o) {                if(count&gt;0) {                    try {                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;恭喜你, 有票, 正在出票...&quot;);                    count--;                    System.out.println(&quot;出票完成, 剩余票数:&quot;+count);                }else {                    System.out.println(&quot;很遗憾, 无票&quot;);                }            }        }    }</code></pre><h3 id="请求的-转发"><a href="#请求的-转发" class="headerlink" title="请求的 转发"></a>请求的 转发</h3><pre><code>概念:    一个web组件 将未处理完毕的请求, 通过tomcat转交给另一个web组件处理.步骤:    1.    获取请求转发器            RequestDispatcher rd  = request.getRequestDispatcher(&quot;转发的地址&quot;);    2.    通过转发器 发起转发            rd.forward(request,response);简写步骤:    request.getRequestDispatcher(&quot;转发的地址&quot;).forward(request,response);转发流程:    步骤1.    当浏览器访问服务器中tomcat时    步骤2.    tomcat将请求信息, 与响应工具进行封装, 传递给我们的Servlet的service方法进行处理    步骤3.    我们在service方法中, 得到请求转发器, 通过请求转发器 告知 tomcat , 请求转发的地址.    步骤4.    tomcat接收到请求转发需求, 会重新封装请求信息, 将请求对象 与 响应对象 传递给 转发地址的Servlet的service方法进行处理特点:    1.    转发过程中, 多个Servlet之间共享一份请求信息, 共享一个响应对象.    2.    转发只能发生在同一个服务器中. (转发无法实现跨域)    3.    无论转发发生多少次 ,对于浏览器来说! 只发起过一次请求 , 并且只接到了一次响应.    4.    相对于重定向来说, 效率更高.</code></pre><h3 id="请求的-重定向"><a href="#请求的-重定向" class="headerlink" title="请求的 重定向"></a>请求的 重定向</h3><pre><code>概念:    响应时 , 告知浏览器新的请求地址, 浏览器接收到 自动请求新的地址 !步骤:    response.sendRedirect(&quot;重定向地址&quot;);重定向流程:    步骤1.    当浏览器访问服务时, 服务器对浏览器响应一个302的状态码, 以及一个location的地址    步骤2.    HTTP协议约定 , 当浏览器接收到302状态码时 ,会自动寻找location地址, 并发起新的请求.    (相当于 控制用户浏览器 自动完成页面的跳转操作.)特点    1.    重定向会产生新的请求 和 新的响应.     2.    使用重定向, 可以在多个服务器之间发生( 可以实现跨域操作 )    3.    浏览器地址栏的内容 会发生改变.    4.    相对于请求转发而言, 效率较低.</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><pre><code>1.    在一次用户的操作中, 可以无限制的进行转发和重定向, 但是记住: 一定要存在出口.    2.    当servlet中的请求已经被转发 / 重定向后,  在此servlet后续的代码中不能再进行响应 !</code></pre><h3 id="HttpServletRequest-类常用操作"><a href="#HttpServletRequest-类常用操作" class="headerlink" title="HttpServletRequest 类常用操作:"></a>HttpServletRequest 类常用操作:</h3><pre><code>1.    获取访问的客户端ip地址    String ip = request.getRemoteAddr();2.    获取客户端访问的地址 (有可能因为服务器映射了多个域名, 多个用户的访问地址 不同)    request.getRequestURI();3.    获取服务器的名称 (通常获取的是ip)    request.getServerName();4.    获取端口号    request.getServerPort();5.    获取请求的方式    String method = request.getMethod();6.    获取get请求的参数列表 (网址中?后面的部分)    String params = request.getQueryString();三个将请求对象 作为数据容器使用的方法:    1.    存储数据            request.setAttribute(String key,Object value);    2.    获取数据            Object value = request.getAttribute(String key);        3.    删除数据            request.removeAttribute(String key);</code></pre><h3 id="ServletContext-上下文"><a href="#ServletContext-上下文" class="headerlink" title="ServletContext 上下文"></a>ServletContext 上下文</h3><pre><code>每一个Servlet都是一个独立的用于处理请求的 对象.为了便于多个Servlet之间的数据交流 . javaWeb提供了一个上下文对象ServletContext !我们在任何的Servlet代码中, 都可以获得这个ServletContext对象 , 且每一个Servlet获取的都是同一份ServletContext对象.上下文对象, 类似于我们SE所学习的MAP集合, 是一个键值对的容器.  作用: ServletContext是Servlet之间通信的桥梁, 用于多个Servlet之间信息的共享.</code></pre><h3 id="如何从Servlet中得到上下文对象"><a href="#如何从Servlet中得到上下文对象" class="headerlink" title="如何从Servlet中得到上下文对象"></a>如何从Servlet中得到上下文对象</h3><pre><code>格式:    ServletContext context = getServletContext();</code></pre><h3 id="ServletContext的常用方法"><a href="#ServletContext的常用方法" class="headerlink" title="ServletContext的常用方法"></a>ServletContext的常用方法</h3><pre><code>1.    存储数据    context.setAttribute(String key,Object value);2.    获取数据    Object value = context.getAttribute(String key);3.    删除数据    context.removeAttribute(String key);4.    获取项目运行时的 文件夹 绝对路径     String path = context.getRealPath(&quot;/&quot;);//因为一个项目 只有一个ServletContext对象, 且在项目启动时创建了,项目销毁时销毁. //所以我们在一次项目启动的过程中, 一个Servlet存储的数据, 任何Servlet都可以获取到.</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet简介</title>
    <link href="undefined2019/11/09/2019-11-9-servlet/"/>
    <url>2019/11/09/2019-11-9-servlet/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议:"></a>HTTP协议:</h3><pre><code>超文本传输协议 , 是一个应用层的网络传输协议 !特点:    1.    简单, 快速.    2.    无连接协议 , 每次连接服务器只处理一次客户端的请求 ,处理完毕, 立即断开.    3.    无状态协议 , 处理请求, 以及进行响应时 ,没有记忆能力 !    4.    支持多种不同的数据提交方式 ,GET/POST 等等    5.    数据传输很灵活, 支持任意数据类型 .</code></pre><h3 id="HTTP协议的组成部分"><a href="#HTTP协议的组成部分" class="headerlink" title="HTTP协议的组成部分"></a>HTTP协议的组成部分</h3><pre><code>1.    请求         请求由四部分组成:            -    请求头                    请求头部的信息, 由一个个的键值对组成 , 描述的是有关客户端的信息.            -    请求体                    GET请求没有请求体. 当请求方式为POST时 ,存在请求体, 请求体是用于存储数据的数据容器 !            -    请求空行                    请求头部与请求体之间的一行空白            -    请求行                    由一个个的键值对组成, 描述的是:描述了请求的方式,远端服务器地址 ,以及所使用的协议版本等信息.2.    响应        响应由三部分组成:            -    响应头                    响应头部的信息, 由一个个的键值对组成, 描述的是有关服务器的信息.            -    响应体                    服务器给客户端回复的主体内容 .            -    响应行                    描述了响应的协议版本, 响应状态码, 以及响应成功或失败的相关解释.</code></pre><h4 id="开发环境下-代码部署到服务器后-访问的路径"><a href="#开发环境下-代码部署到服务器后-访问的路径" class="headerlink" title="开发环境下: 代码部署到服务器后, 访问的路径:"></a>开发环境下: 代码部署到服务器后, 访问的路径:</h4><pre><code>http://ip地址:端口号/项目名/文件名.后缀名</code></pre><h4 id="HttpServlet-类"><a href="#HttpServlet-类" class="headerlink" title="HttpServlet 类"></a>HttpServlet 类</h4><pre><code>简介:    是JavaWeb中的 三大组件之一 .    本质上:     就是一个运行在tomcat中的  java类作用:    用于处理客户端的请求, 以及对客户端进行响应 .步骤:    1.    编写一个类, 继承自HttpServlet    2.    重写父类的service(HttpServletRequest request,HttpServletResponse response)方法    3.    在service方法中 对用户进行响应.案例:    public class Servlet1 extends HttpServlet{        /**         * @param request :        请求对象 , 包含了请求相关的所有信息         * @param response :    响应对象 , tomcat提供的用于给客户端响应内容的 各种工具.         */        @Override        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            //1.    设置响应的 编码格式 以及 响应的内容类型            response.setContentType(&quot;text/html;charset=utf-8&quot;);            //2.    获取用于打印响应体的 打印流            PrintWriter pw = response.getWriter();            //3.    打印一些准备响应的内容            pw.println(&quot;&lt;h1&gt;从前有座山 , 山上有座尼姑庵 ! 庵里有个老尼姑 ...&lt;/h1&gt;&quot;);            pw.flush();            //当service方法执行完毕后, tomcat会将我们准备好的响应体发送给浏览器        }    }</code></pre><h3 id="将编写好的servlet-映射到一个网址上"><a href="#将编写好的servlet-映射到一个网址上" class="headerlink" title="将编写好的servlet  映射到一个网址上:"></a>将编写好的servlet  映射到一个网址上:</h3><pre><code>web3.0之前版本:    修改项目中的配置文件 web.xml    在web.xml根节点中 加入:        1.    servlet节点 ,用于将serlvet类告知tomcat            &lt;servlet&gt;                &lt;servlet-name&gt;任意的标识符,给servlet起别名&lt;/servlet-name&gt;                &lt;servlet-class&gt;包名.类名&lt;servlet-class&gt;            &lt;/servlet&gt;        2.    servlet-mapping , 通过别名告知tomcat ,某servlet的映射网址            映射网址 ,通常以/开头 , 例如:        /demo1  , 访问网址: http://ip地址:端口号/项目名/demo1               &lt;servlet-mapping&gt;                &lt;servlet-name&gt;要添加映射网址的别名&lt;/servlet-name&gt;                &lt;url-pattern&gt;/映射的网址&lt;/url-pattern&gt;            &lt;/servlet-mapping&gt;web3.0+    版本:    通过WebServlet注解:    案例:    @WebServlet(&quot;/hello2&quot;)    public class Servlet2 extends HttpServlet{        /**         * @param request :        请求对象 , 包含了请求相关的所有信息         * @param response :    响应对象 , tomcat提供的用于给客户端响应内容的 各种工具.         */        @Override        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            //1.    设置响应的 编码格式 以及 响应的内容类型            response.setContentType(&quot;text/html;charset=utf-8&quot;);            //2.    获取用于打印响应体的 打印流            PrintWriter pw = response.getWriter();            //3.    打印一些准备响应的内容            pw.println(&quot;&lt;script&gt;alert(&apos;恭喜你, 获得奖品: 苹果笔记本电脑一台 , 现金1980 ,请输入银行卡密码领取&apos;)&lt;/script&gt;&quot;);            pw.println(&quot;&lt;input &gt;&lt;button onclick=&apos;alert(\&quot;哈哈哈哈哈哈哈,你真信啊\&quot;)&apos;&gt;提交&lt;/button&gt;&quot;);            pw.flush();            //当service方法执行完毕后, tomcat会将我们准备好的响应体发送给浏览器        }    }</code></pre><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><pre><code>指的是 Servlet从创建 到 消亡的 周期!Servlet的创建时机:    默认情况 , 当用户第一次访问Servlet的映射地址时  . 对象创建.Servlet的销毁时机:    当tomcat关闭, 或 项目从tomcat删除时. Servlet被销毁.三个方法的体现:    1.    init方法        :    此方法在对象创建后, 执行.    2.    service方法    :    服务方法,当用户每一次访问时, 执行,  用于处理用户的请求, 以及对用户进行响应 .    3.    destroy方法    :    当tomcat关闭 或 项目从tomcat删除时 执行;    </code></pre><h3 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h3><pre><code>是Servlet的配置对象, 每一个Servlet都拥有一个ServletConfig .我们在web.xml中 进行Servlet配置时. 可以向一个Servlet中 添加初始化的参数. 这些参数以键值对的形式存储在ServletConfig中在web.xml中 , 向ServletConfig 存储数据的格式:    &lt;servlet&gt;        ...        &lt;!-- init-param标签可以存在多个, 每一个init-param都表示一个键值对 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;键&lt;/param-name&gt;            &lt;param-value&gt;值&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;在Servlet中 得到ServletConfig对象的方式:         方式1与方式2是互斥的.    方式1.        在Servlet中, 重写生命周期init(ServletConfig config)方法 , 使用方法参数中的config对象    方式2.        在Servlet的任意代码位置 , 通过getServletConfig();方法. 得到对象从ServletConfig 取出数据的格式:    String value = config对象.getInitParameter(String name);</code></pre><h3 id="调整-Servlet的创建时机"><a href="#调整-Servlet的创建时机" class="headerlink" title="调整 Servlet的创建时机"></a>调整 Servlet的创建时机</h3><pre><code>在web.xml中 . 配置servlet时.&lt;servlet&gt;    &lt;servlet-name...    &lt;servlet-class...    &lt;load-on-startup&gt;数字&lt;/load-on-startup&gt;&lt;/servlet&gt;load-on-startup:     取值为数字: (默认值为-1)        当值为负数时:    懒汉模式, 第一次请求时加载 ,         当值≥0时 , 描述的是请求的顺序, 值越小越早加载.        如果多个servlet值相同:    按照web.xml中servlet的配置顺序 自上而下加载.</code></pre><h3 id="如何接收用户-表单-的参数"><a href="#如何接收用户-表单-的参数" class="headerlink" title="如何接收用户 表单 的参数"></a>如何接收用户 表单 的参数</h3><pre><code>1.    根据一个name , 接收单个参数         String value = request.getParameter(String name);    2.    根据一个name , 接收一组参数        String[] values = request.getParameterValues(String name);</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连接池</title>
    <link href="undefined2019/11/08/2019-11-8-jdbc/"/>
    <url>2019/11/08/2019-11-8-jdbc/</url>
    
    <content type="html"><![CDATA[<p><code>DBCP(DataBase connection pool)</code>,数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要2个包：commons-dbcp.jar,commons-pool.jar,配置文件 db.properties 如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=oracle.jdbc.OracleDriver</span><br><span class="line">url=jdbc:oracle:thin:@localhost:1521:xe</span><br><span class="line">username=system</span><br><span class="line">password=254615</span><br><span class="line">initialSize=10</span><br><span class="line">maxActive=50</span><br><span class="line">minIdle=5</span><br><span class="line">maxWait=60000</span><br></pre></td></tr></table></figure><p>Properties文件 是以键值对形式存放数据，一个键对应且只对应一个值，键与值都不能有空格<br><strong>DBCP连接池</strong>如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">mport java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbcp.BasicDataSourceFactory;</span><br><span class="line"></span><br><span class="line">public class DBCPUtil &#123;</span><br><span class="line"></span><br><span class="line">private static DataSource dataSource;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">//在类加载时, 读取配置文件, 配置连接池</span><br><span class="line">//1.创建Properites对象</span><br><span class="line">Properties ppt = new Properties();</span><br><span class="line">//2.读取配置文件, </span><br><span class="line">InputStream is = DBCPUtil.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);</span><br><span class="line">//3.将配置文件 加载到Properties对象中</span><br><span class="line">try &#123;</span><br><span class="line">ppt.load(is);</span><br><span class="line">//4.通过连接池工厂类, 创建连接池</span><br><span class="line">dataSource = BasicDataSourceFactory.createDataSource(ppt);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于从连接池中 获取一个连接对象</span><br><span class="line"> * @return 连接对象 , 如果获取失败返回null</span><br><span class="line"> */</span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return dataSource.getConnection();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 用于释放资源</span><br><span class="line"> * @param conn连接对象</span><br><span class="line"> * @param state 执行环境</span><br><span class="line"> * @param result 结果集</span><br><span class="line"> */</span><br><span class="line">public static void close(Connection conn , Statement state ,ResultSet result) &#123;</span><br><span class="line">if(result!=null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">result.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(state!=null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">state.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(conn!=null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Druid连接池</strong>如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class DruidUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static DataSource dataSource;</span><br><span class="line">    static &#123;</span><br><span class="line">        InputStream is = DruidUtil.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);</span><br><span class="line">        Properties pro = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            return dataSource.getConnection();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sourceCloes(Connection conn, Statement st, ResultSet rs)&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (conn!=null) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (st!=null) &#123;</span><br><span class="line">                st.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (rs!=null) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议使用Druid连接池，因为Druid是最大最好的连接池 而且它是阿里出品哦 - ( ゜- ゜)つロ</p>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC事务</title>
    <link href="undefined2019/11/07/2019-11-7-jdbc/"/>
    <url>2019/11/07/2019-11-7-jdbc/</url>
    
    <content type="html"><![CDATA[<h3 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h3><pre><code>在dos命令行操作oracle时 , 执行DML , 需要结束事务 (commit提交 或 rollback回退)在JDBC中, 事务是自动提交的, 每执行一条DML语句, 事务就自动提交一次. 我们可以通过JDBC的事务API , 开始事务的手动提交, 将多条DML语句看作一个整体, 要么一起成功, 要么一起失败.</code></pre><h4 id="JDBC事务操作格式"><a href="#JDBC事务操作格式" class="headerlink" title="JDBC事务操作格式:"></a>JDBC事务操作格式:</h4><pre><code>注意:    开启事务的手动提交 ,是通过连接对象完成的.         某个数据连接对象的事务开启手动提交后, 这个连接对象的事务需要手动控制.  其他连接对象不受影响.操作方法:    1.    开始事务的手动提交:            conn.setAutoCommit(boolean flag);            参数含义:    true表示自动提交 . false表示手动提交.    2.    提交事务:            conn.commit();    3.    回退事务:            rollback();</code></pre><h4 id="事务案例"><a href="#事务案例" class="headerlink" title="事务案例:"></a>事务案例:</h4><pre><code>    public class Demo {    public static void main(String[] args) throws Exception {        //1.    加载数据库的驱动        Class.forName(&quot;oracle.jdbc.OracleDriver&quot;);        //2.    获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:XE&quot;, &quot;system&quot;, &quot;123&quot;);        //2.1    设置连接对象的事务 为 手动提交        conn.setAutoCommit(false);        //3.    开始描述逻辑        System.out.println(&quot;金刚: 转账中...&quot;);        //3.1    减少金刚账户的余额 500 | 3.1.1    预编译SQL执行环境        PreparedStatement state = conn.prepareStatement(&quot;update user33 set money=500 where id=2&quot;);        //3.1.2    执行SQL语句        boolean success = state.executeUpdate()&gt;0?true:false;        if(success) {            System.out.println(&quot;后台逻辑: 金刚余额减少完毕.&quot;);            if(1==2) {                conn.rollback();                throw new RuntimeException(&quot;后台服务器... 停电了&quot;);            }            //3.2    增加豪杰账户的余额 500             //3.2.1    预编译SQL执行环境            PreparedStatement state2 = conn.prepareStatement(&quot;update user33 set money=600 where id=1&quot;);            //3.2.2    执行SQ语句            boolean success2 = state2.executeUpdate()&gt;0?true:false;            if(success2) {                System.out.println(&quot;后台逻辑: 豪杰余额增加完毕&quot;);                conn.commit();            }            state2.close();        }        state.close();    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC访问数据库</title>
    <link href="undefined2019/11/06/2019-11-6-jdbc/"/>
    <url>2019/11/06/2019-11-6-jdbc/</url>
    
    <content type="html"><![CDATA[<h2 id="JDBC访问数据库的步骤"><a href="#JDBC访问数据库的步骤" class="headerlink" title="JDBC访问数据库的步骤"></a>JDBC访问数据库的步骤</h2><ol><li>加载驱动<br>  Class.forName(“包名.驱动名”)  </li><li>获取连接<br>  DriverManager.getConnection(url,username,password)  <pre><code>比如连接oracle 的url 是  jdbc:oracle:thin:@127.0.0.1:1521:xe</code></pre></li><li>定义sql 并获取sql的执行环境 Statement (PrepareadStatement)<br>   conn.createStatement() 这里以后会使用 prepareadStatement   </li><li>执行sql 处理sql 返回值<br> select  返回ResultSet  遍历       st.executeQuery<br> dml     返回int  代表影响的数据行数  st.executeUpdate  </li><li>释放资源<br> Connection    Statement   ResultSet  等  close()</li></ol><p>使用PreparedStatement  替换  Statement    </p><ul><li>可以防止拼接的sql注入   原理就是你输入的数据不拼接 直接作为真实数据</li><li>由于采用预编译  会提前生成sql的执行计划  提高执行效率</li><li>拼接sql 每次sql是不同的  这会给数据库服务器的sql缓冲造成冲击  无法实现批处理 </li><li>由于不拼接sql  程序员出错的概率会降低  提高编码质量和速度 </li></ul><h3 id="工具类的思想"><a href="#工具类的思想" class="headerlink" title="工具类的思想"></a>工具类的思想</h3><p> 负责获取数据库的连接    以及资源的释放   提高代码复用度 </p><h3 id="配置文件的思想"><a href="#配置文件的思想" class="headerlink" title="配置文件的思想"></a>配置文件的思想</h3><p>  可以不修改源代码的情况下 修改参数数据 </p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p> 什么是DAO<br>  <code>Data Access  Object</code>   数据访问对象<br>     它是对数据访问过程 封装的对象<br> 如何编写DAO   </p><ol><li>根据需求编写DAO 对应的接口   </li><li>使用DBUtil 工具类  结合JDBC编程的五步  实现接口中对应的方法  </li></ol>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序快速排序简单代码实现</title>
    <link href="undefined2019/11/05/2019-11-5-suanfa/"/>
    <url>2019/11/05/2019-11-5-suanfa/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class TestSort &#123;</span><br><span class="line"></span><br><span class="line">//冒泡排序算法将参数指定的数组元素进行排序</span><br><span class="line">public static void bubble(int[] arr)&#123;</span><br><span class="line">//1.使用外层for循环来控制比较的轮数</span><br><span class="line">for(int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class="line">//声明boolean类型的变量作为标志位</span><br><span class="line">boolean flag = true;</span><br><span class="line">//2.使用内层for循环来控制针对当前轮比较的次数</span><br><span class="line">for(int j = 0; j &lt; arr.length-i; j++)&#123;</span><br><span class="line">//3.若第一个元素比第二个元素大，则交换两个元素的位置</span><br><span class="line">if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">int temp = arr[j];</span><br><span class="line">arr[j] = arr[j+1];</span><br><span class="line">arr[j+1] = temp;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//若该位置flag的数值还是true，则证明本轮比较中没有发生任何的交换</span><br><span class="line">if(flag) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//快速排序算法实现</span><br><span class="line">public static void quick(int[] arr, int left, int right)&#123;</span><br><span class="line">//1.计算中间元素的下标并使用该元素作为基准值单独保存</span><br><span class="line">int p = (left+right)/2;</span><br><span class="line">int pivot = arr[p];</span><br><span class="line">//2.分别使用左右两边的元素依次与基准值比较大小，将所有小于基准值的元素放在左边,</span><br><span class="line">//  将所有大于等于基准值的元素放在右边</span><br><span class="line">int i = left;</span><br><span class="line">int j = right;</span><br><span class="line">for( ; i &lt; j; )&#123;</span><br><span class="line">//若左边有元素并且左边元素小于基准值时，则使用下一个元素与基准值比较</span><br><span class="line">while(i &lt; p &amp;&amp; arr[i] &lt; pivot)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">//直到左边有元素但左边元素不再小于基准值时，则将该元素放到p指向的位置</span><br><span class="line">//p指向该元素原来的位置</span><br><span class="line">if(i &lt; p)&#123;</span><br><span class="line">arr[p] = arr[i];</span><br><span class="line">p = i;</span><br><span class="line">&#125;</span><br><span class="line">//若右边有元素并且右边元素大于等于基准值时，则使用下一个元素比较</span><br><span class="line">while(j &gt; p &amp;&amp; arr[j] &gt;= pivot)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">//直到右边有元素但右边元素不再大于等于基准值时，则将该元素放到p指向的位置</span><br><span class="line">//p指向该元素原来的位置</span><br><span class="line">if(j &gt; p)&#123;</span><br><span class="line">arr[p] = arr[j];</span><br><span class="line">p = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//3.直到左右两边元素的下标重合时，将基准值放到重合的位置</span><br><span class="line">arr[p] = pivot;</span><br><span class="line">//4.使用递归的思想分别对左右两边的分组进行再次分组</span><br><span class="line">if(p - left &gt; 1)&#123;</span><br><span class="line">quick(arr, left, p-1);</span><br><span class="line">&#125;</span><br><span class="line">if(right - p &gt; 1)&#123;</span><br><span class="line">quick(arr, p+1, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">int[] arr = &#123;20, 10, 25, 5, 15, 30, 8, 20, 3&#125;;</span><br><span class="line">//调用排序算法实现排序</span><br><span class="line">//TestSort.bubble(arr);</span><br><span class="line">//TestSort.quick(arr, 0, arr.length-1);</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">//打印排序后数组中的所有元素</span><br><span class="line">System.out.print(&quot;排序后的结果是：&quot;);</span><br><span class="line">for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计原则与设计模式</title>
    <link href="undefined2019/11/04/2019-11-4-shejiyuanze/"/>
    <url>2019/11/04/2019-11-4-shejiyuanze/</url>
    
    <content type="html"><![CDATA[<h2 id="常用的设计原则"><a href="#常用的设计原则" class="headerlink" title="常用的设计原则"></a>常用的设计原则</h2><h3 id="软件-项目开发的流程"><a href="#软件-项目开发的流程" class="headerlink" title="软件/项目开发的流程"></a>软件/项目开发的流程</h3><p>   需求分析文档 =&gt; 概要设计文档 =&gt; 详细设计文档 =&gt; 编码和测试 =&gt; 安装和调试<br>=&gt; 维护和升级</p><h3 id="常用的设计原则-1"><a href="#常用的设计原则-1" class="headerlink" title="常用的设计原则"></a>常用的设计原则</h3><p>   <strong>开闭原则</strong> </p><ul><li>对扩展开放，对修改关闭<ul><li>实现热插拔的效果，从而提高软件的可维护性</li></ul></li></ul><p>如：<br>  <figure class="highlight plain"><figcaption><span>class Person&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">   </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line">public class SubPerson extends Person&#123;</span><br><span class="line">    private boolean gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   <strong>里氏代换原则</strong></p><ul><li>任何父类可以出现的地方，子类一定可以出现</li><li>尽量多使用继承和多态的方式编程</li></ul><p>如：<br>   <figure class="highlight plain"><figcaption><span>static void draw(Shape s)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">       s.show();</span><br><span class="line">   &#125;</span><br><span class="line">   draw(new Rect(1, 2, 3, 4));</span><br><span class="line">  </span><br><span class="line">   依赖倒转原则 - 尽量依赖于抽象类和接口，而不是具体实现类</span><br><span class="line">                - 抽象类对子类具有强制性和规范性</span><br><span class="line">如：</span><br><span class="line">   public abstract class Account&#123;</span><br><span class="line">       public abstract double getLixi();</span><br><span class="line">   &#125; </span><br><span class="line">   public class FixedAccount extends Account&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public double getLixi()&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ```        </span><br><span class="line">   **接口隔离原则** </span><br><span class="line">   - 尽量依赖于多个小接口而不是一个大接口  </span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">   ```public interface FlyAnimal&#123;</span><br><span class="line">       public abstract void fly();</span><br><span class="line">   &#125;</span><br><span class="line">   public interface RunAnimal&#123;</span><br><span class="line">       public abstract void run();</span><br><span class="line">   &#125;</span><br><span class="line">   public class Dog implements RunAnimal&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>   <strong>迪米特法则</strong></p><ul><li><p>一个实体应当尽量少与其它实体之间发生相互作用。</p></li><li><p>高内聚低耦合</p></li><li><p>所谓高内聚就是指一个实体应该将该实体拥有的所有功能内聚于该实体的内部。</p></li><li><p>所谓低耦合就是指一个实体应该尽量减少与其它实体的关联度。</p><p> <strong>合成复用原则</strong> </p></li><li><p>应该尽量使用合成复用的方式而不是继承。</p></li></ul><p>如：<br>  <figure class="highlight plain"><figcaption><span>class A&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   public void show()&#123; ... &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">public class B&#123;</span><br><span class="line">   private A a;</span><br><span class="line">   public B(A a)&#123;</span><br><span class="line">      this.a = a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void test()&#123;</span><br><span class="line">       a.show(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h2><p> <strong>基本概念</strong><br>   设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结  </p><p><strong>基本分类</strong><br>   创建型模式 - 工厂方法模式、抽象工厂模式、单例设计模式(要求会写)<br>   结构型模式 - 装饰器模式、代理模式(要求看懂)<br>   行为型模式 - 模板方法模式、观察者模式(以后讲到)  </p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性查找与二分查找简单代码实现</title>
    <link href="undefined2019/11/02/2019-11-2-suanfa/"/>
    <url>2019/11/02/2019-11-2-suanfa/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class TestFind &#123;</span><br><span class="line"></span><br><span class="line">//线性查找算法</span><br><span class="line">//要求从参数指定的数组中查找参数指定的元素并返回下标</span><br><span class="line">public static int find(int[] arr, int data)&#123;</span><br><span class="line">for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">if(arr[i] == data)&#123;</span><br><span class="line">return i; //表示查找成功</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1; //表示查找失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二分查找算法</span><br><span class="line">//要求从参数指定的数组中查找参数指定的元素并返回下标</span><br><span class="line">public static int findBinary(int[] arr, int left, int right, int data)&#123;</span><br><span class="line">/*</span><br><span class="line">if(left &lt;= right)&#123;</span><br><span class="line">//1.计算中间元素的下标并单独记录</span><br><span class="line">int p = (left + right)/2;</span><br><span class="line">//2.使用目标元素与中间元素比较大小，若相等则查找成功</span><br><span class="line">if(data == arr[p])&#123;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">//3.若目标元素小于中间元素，则在中间元素的左边进行查找，使用递归的方式</span><br><span class="line">if(data &lt; arr[p])&#123;</span><br><span class="line">return findBinary(arr, left, p-1, data);</span><br><span class="line">&#125;</span><br><span class="line">//4.若目标元素大于中间元素，则在中间元素的右边进行查找，使用递归的方式</span><br><span class="line">return findBinary(arr, p+1, right, data);</span><br><span class="line">&#125;</span><br><span class="line">return -1; //表示查找失败</span><br><span class="line">*/</span><br><span class="line">//练习：使用while循环实现二分查找算法</span><br><span class="line">while(left &lt;= right)&#123;</span><br><span class="line">//1.计算中间元素的下标并单独记录</span><br><span class="line">int p = (left + right)/2;</span><br><span class="line">//2.使用目标元素与中间元素比较大小，若相等则查找成功</span><br><span class="line">if(data == arr[p])&#123;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">//3.若目标元素小于中间元素，则在中间元素的左边进行查找，使用递归的方式</span><br><span class="line">if(data &lt; arr[p])&#123;</span><br><span class="line">right = p-1;</span><br><span class="line">&#125;</span><br><span class="line">//4.若目标元素大于中间元素，则在中间元素的右边进行查找，使用递归的方式</span><br><span class="line">if(data &gt; arr[p])&#123;</span><br><span class="line">left = p+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1; //表示查找失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">int[] arr = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line">int num = 30;</span><br><span class="line">//int pos = TestFind.find(arr, num);</span><br><span class="line">int pos = TestFind.findBinary(arr, 0, 4, num);</span><br><span class="line">if(-1 == pos)&#123;</span><br><span class="line">System.out.println(&quot;元素&quot; + num + &quot;不存在！&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;元素&quot; + num + &quot;所在的下标是：&quot; + pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>11月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本查找算法和排序算法</title>
    <link href="undefined2019/11/01/2019-11-1-suanfa/"/>
    <url>2019/11/01/2019-11-1-suanfa/</url>
    
    <content type="html"><![CDATA[<h2 id="常用的查找算法"><a href="#常用的查找算法" class="headerlink" title="常用的查找算法"></a>常用的查找算法</h2><h3 id="线性-顺序查找算法"><a href="#线性-顺序查找算法" class="headerlink" title="线性/顺序查找算法"></a>线性/顺序查找算法</h3><p><strong>算法流程</strong>  </p><ol><li>使用目标元素与样本数列中的元素从前向后依次比较大小；  </li><li>若找到与目标元素相等的元素，则表示查找成功；  </li><li>若所有元素与目标元素比较完毕也没有相等的元素，则表示查找失败；  </li></ol><h3 id="二分-折半查找算法"><a href="#二分-折半查找算法" class="headerlink" title="二分/折半查找算法"></a>二分/折半查找算法</h3><p><strong>算法流程</strong>  </p><ol><li>假定样本数列中的所有元素从小到大有序排列；  </li><li>使用目标元素与样本数列中的中间元素比较大小，若相等则查找成功；  </li><li>若目标元素小于中间元素，则应该去中间元素的左边进行查找；  </li><li>若目标元素大于中间元素，则应该去中间元素的右边进行查找；  </li><li>直到处理完毕所有元素也没有相等的元素，则表示查找失败；  </li></ol><h2 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h2><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><p><strong>算法流程</strong>  </p><ol><li>比较相邻位置两个元素的大小，若第一个元素比第二个大则交换两个元素的位置；  </li><li>从开始的第一对一直比较到结尾的最后的一对，经过这一步，最后的元素将是这组<br>  元素的最大值；  </li><li>重复步骤b持续对越来越少的元素进行比较，直到处理完毕所有元素为止；<br>  (任何相邻位置的两个元素都不再需要交换为止)</li></ol><h3 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h3><p><strong>算法流程</strong></p><ol><li>取出第一个元素，可以认定该元素已经有序；</li><li>取出下一个元素，让取出的元素与左边的有序数列从右向左依次比较大小；</li><li>若取出的元素小于左边的元素，则将左边的元素右移也就是赋值到下一个元素的位置；</li><li>若取出的元素大于等于左边的元素，则将取出的元素插入到左边元素的右边；</li><li>重复步骤b，直到处理完毕所有元素为止；</li></ol><h3 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h3><p><strong>算法流程</strong>  </p><ol><li>取出第一个元素并假定该元素是这组元素中的最小值使用min记录下标；  </li><li>使用min记录的最小值与后续元素依次比较大小；  </li><li>若后续元素中出现比min记录的最小值还小的元素，则使用min记录该元素的下标；  </li><li>直到min记录的最小值与后续所有元素比较完毕后，交换min记录的最小值和最开始<br>  假定最小值的元素位置；</li><li>经过这一步，最起始的元素将是这组元素中的最小值，取出下一个元素重复步骤a，<br>  直到处理完毕所有元素为止；</li></ol><h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p><strong>算法流程</strong></p><ol><li>选择中间元素作为基准值并单独保存起来；  </li><li>分别使用左右两边的元素依次与基准值比较大小，将所有小于基准值的元素放在左边，<br>  将所有大于等于基准值的元素放在右边，这个过程叫做分组；</li><li>分别对左右两边的分组进行再次分组，使用递归的思想；</li></ol>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射机制</title>
    <link href="undefined2019/10/31/2019-10-31-fanshe/"/>
    <url>2019/10/31/2019-10-31-fanshe/</url>
    
    <content type="html"><![CDATA[<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>如：<br>   Person p = new Person(); - 表示声明Person类型的引用指向Person类型的对象<br>   p.show();                - 表示调用show方法  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   通常情况下编写的代码都是固定的，运行的结果也是固定的，若编写代码时不确定会创建什么类型的对象以及调用什么样的方法，由运行时传入的参数决定，这种技术就叫动态编程或反射机制。<br>   反射机制是目前主流框架的底层原理。</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p><strong>基本概念</strong><br>   java.lang.Class类的实例用于表示正在运行Java程序中的类和接口，也就是用于代表一种数据类型<br>   该类没有公共构造方法，该类的实例由Java虚拟机和类加载器自动构造  </p><p><strong>获取Class对象的方式</strong><br>   a.使用数据类型.class的方式获取对应类型的Class对象；<br>   b.使用对象.getClass()的方式获取对应类型的Class对象；<br>   c.使用包装类.TYPE的方式获取对应基本数据类型的Class对象；<br>   d.使用Class.forName()的方式获取对应类型的Class对象；  </p><p><strong>常用的方法</strong><br>  <code>static Class&lt;?&gt; forName(String className)</code><br>       - 用于获取参数字符串指定类型的Class对象并返回<br> <code>T newInstance()</code></p><ul><li><p>用于创建此Class对象所表示类的新实例/对象  </p></li><li><p>若此Class对象代表String类，则调用该方法表示创建String类型的对象  </p></li><li><p>若此Class对象代表Person类，则调用该方法表示创建Person类型的对象  </p><p><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>   </p><pre><code>- 用于获取此Class对象所表示类中参数指定的公共构造方法  </code></pre><p><code>Constructor&lt;?&gt;[] getConstructors()</code>  </p><pre><code>- 用于获取此Class对象所表示类中所有的公共构造方法  </code></pre><p><code>Field getDeclaredField(String name)</code></p><pre><code>- 用于获取此Class对象所表示类中参数指定的成员变量  </code></pre><p><code>Field[] getDeclaredFields()</code> </p><pre><code>- 用于获取此Class对象所表示类中所有成员变量  </code></pre><p><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>  </p><pre><code>- 用于获取此Class对象所表示类中指定的公共成员方法  </code></pre><p><code>Method[] getMethods()</code></p><pre><code>- 用于获取此Class对象所表示类中所有的公共成员方法  </code></pre></li></ul><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p><strong>基本概念</strong><br>  <code>java.lang.reflect.Constructor</code>类用于描述获取到的单个构造方法的相关信息  </p><p>(2)常用的方法<br>  <code>T newInstance(Object... initargs)</code><br>      - 使用此Constructor对象代表的构造方法来构造对象，参数用于初始化对象的成员变量  </p><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p><strong>基本概念</strong><br> <code>java.lang.reflect.Field</code>类用于描述获取到的单个成员变量信息 </p><p><strong>常用的方法</strong><br>  <code>Object get(Object obj)</code><br>       - 用于获取参数对象obj中此Field对象所描述成员变量的数值并返回<br>  <code>void set(Object obj, Object value)</code><br>       - 用于设置参数对象obj中此Field对象所描述成员变量的数值为value<br> <code>void setAccessible(boolean flag)</code><br>       - 用于设置是否取消Java语言的访问检查  </p><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p><strong>基本概念</strong><br>  <code>java.lang.reflect.Method</code>类用于描述获取到的单个成员方法信息 </p><p><strong>常用的方法</strong><br>  <code>Object invoke(Object obj, Object... args)</code><br>       - 使用参数对象obj来调用此Method对象所描述的成员方法，实参传递args </p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于UDP的编程模型</title>
    <link href="undefined2019/10/30/2019-10-30-udp/"/>
    <url>2019/10/30/2019-10-30-udp/</url>
    
    <content type="html"><![CDATA[<h3 id="基于udp协议的编程模型"><a href="#基于udp协议的编程模型" class="headerlink" title="基于udp协议的编程模型"></a>基于udp协议的编程模型</h3><p> <strong>编程模型</strong><br>接收方：<br>   (1)创建    DatagramSocket类型的对象并提供端口号；<br>   (2)创建DatagramPacket类型的对象用于接收数据并记录；<br>   (3)调用receive()方法接收数据内容；<br>   (4)关闭Socket；<br>发送方：<br>   (1)创建DatagramSocket类型的对象；<br>   (2)创建DatagramPacket类型的对象并提供接收方的通信地址和端口号；<br>   (3)调用send()方法发送数据内容；<br>   (4)关闭Socket；  </p><h3 id="相关类和方法的解析"><a href="#相关类和方法的解析" class="headerlink" title="相关类和方法的解析"></a>相关类和方法的解析</h3><p><strong>DatagramSocket类</strong><br>  <code>java.net.DatagramSocket</code>类用于描述发送/接收数据的套接字(码头)<br>  <code>DatagramSocket()</code> - 使用无参方式构造对象<br> <code>DatagramSocket(int port)</code> - 根据参数指定端口构造对象<br>   <code>void receive(DatagramPacket p)</code> - 用于接收数据并记录到参数指定的数据报中<br>   <code>void send(DatagramPacket p)</code>- 用于发送参数指定的数据报内容<br> <code>void close()</code></p><p><strong>DatagramPacket类</strong><br>   <code>java.net.DatagramPacket</code>类用于描述发送/接收的数据报(集装箱)<br>   <code>DatagramPacket(byte[] buf, int length)</code> - 用于接收数据报到参数中记录<br>  <code>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code><br>       - 用于将参数指定的内容发送到参数指定的位置<br>   <code>InetAddress getAddress()</code> - 用于获取发送方/接收方的通信地址<br>  <code>int getPort()</code> - 用于获取发送方/接收方的端口号<br>  <code>int getLength()</code> - 用于获取发送/接收到的数据长度  </p><p><strong>InetAddress类</strong><br>   <code>java.net.InetAddress</code>类用于描述通信地址信息<br> <code>static InetAddress getLocalHost()</code> - 用于获取本地主机的通信地址<br>  <code>static InetAddress getByName(String host)</code> - 用于获取指定主机的通信地址</p><h2 id="tcp协议和udp协议的比较"><a href="#tcp协议和udp协议的比较" class="headerlink" title="tcp协议和udp协议的比较"></a>tcp协议和udp协议的比较</h2><p><strong>tcp协议</strong></p><ul><li>传输控制协议，是一种面向连接的协议，类似于打电话</li><li>建立连接 =&gt; 进行通信 =&gt; 断开连接</li><li>在通信的整个过程中全程保持连接</li><li>该协议保证了数据传输的可靠性和有序性</li><li>是一种全双工的字节流通信方式</li><li>服务器压力比较大，资源消耗比较多，并且发送数据的效率相对比较低</li></ul><p><strong>udp协议</strong></p><ul><li>用户数据报协议，是一种非面向连接的协议，类似于写信</li><li>在通信的整个过程中不保持连接</li><li>不保证数据传输的可靠性和有序性</li><li>是一种全双工的数据报通信方式</li><li>服务器压力比较小，资源消耗比较少，并且发送数据的效率相对比较高</li></ul>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于TCP的编程模型</title>
    <link href="undefined2019/10/29/2019-10-29-tcp/"/>
    <url>2019/10/29/2019-10-29-tcp/</url>
    
    <content type="html"><![CDATA[<h3 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h3><p>  为了保证数据传输的可靠和安全等，ISO将数据的传递从逻辑上划分为以下七层：<br>     <em>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</em><br>  当发送数据时，需要按照上述七层进行层层加包然后发送出去<br>  当接收数据时，需要按照上述七层相反的次序层层拆包再解析出来   </p><p><strong>常用的协议</strong><br>   http - 超文本传输协议，用于浏览网页时使用<br>   ftp  - 文件传输协议，用于上传和下载文件时使用<br>   tcp  - 传输控制协议，用于网络通信时使用<br>   udp  - 用户数据报协议，用于网络通信时使用<br>   ip   - 互联网协议，是上述协议的底层协议  </p><p>   协议 - 本质上就是一种规则，用于约定双方通信的机制 </p><p> *<em>IP地址 *</em><br>如：<br>   192.168.1.1  - 是绝大多数路由器的登录地址，进行MAC地址的过滤  </p><p>   IP地址是互联网中的唯一地址标识，本质上是由32位二进制组成的整数，叫做IPv4，当然也有128位二进制组成的整数，叫做IPv6，目前的主流是IPv4.<br>   日常生活中采用点分十进制表示法进行IP地址的描述，也就是让每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开<br>如：<br>   0x01 02 03 04(十六进制) =&gt; 1.2.3.4 </p><p>查看IP地址的方式:<br>    windows系统：在dos窗口中使用ipconfig或者ipconfig/all命令查看<br>    linux系统：  在终端窗口中使用ifconfig或者/sbin/ifconfig命令查看  </p><p><strong>端口号</strong><br>   IP地址 - 可以定位到具体某一台设备<br>   端口号 - 可以定位到具体某一个进程<br>   网络编程需要提供：IP地址 + 端口号  </p><p>   端口号本质上是由16位二进制组成的整数，<br>范围是：<code>0 ~ 65535</code>，其中0 ~ 1024之间的端口号一般被系统占用，<br>因此编程从1025开始使用  </p><p><strong>基于tcp协议的编程模型</strong><br><em>编程模型</em><br>服务器：<br>   (1)创建ServerSocket类型的对象并提供端口号；<br>   (2)等待客户端的连接请求，调用accept()方法；<br>   (3)使用输入输出流进行通信；//////////BufferedReader bu = new BufferedReader(new InputStreamReader  (so.getInputStream()));<br>   (4)关闭Socket；<br>客户端：<br>   (1)创建Socket类型的对象并提供服务器的IP地址和端口号；<br>   (2)使用输入输出流进行通信；<br>   (3)关闭Socket;  </p><p><strong>相关类和方法的解析</strong></p><h3 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h3><p>  <code>java.net.ServerSocket</code>类是用于描述服务器的套接字(大插排)<br>  <code>ServerSocket(int port)</code>- 根据参数指定的端口号构造对象<br>  <code>Socket accept()</code>- 侦听并接收到此套接字的连接请求<br> <code>void close()</code></p><h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h3><p> <code>java.net.Socket</code>类用于描述客户端的套接字(小插排)，是两台设备间通信的端点<br>  <code>Socket(String host, int port)</code> - 根据参数指定的主机名和端口号构造对象<br>  <code>InputStream getInputStream()</code> - 用于获取该套接字的输入流<br>  <code>OutputStream getOutputStream()</code> - 用于获取该套接字的输出流<br> <code>void close()</code></p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread类</title>
    <link href="undefined2019/10/28/2019-10-28-synchronized/"/>
    <url>2019/10/28/2019-10-28-synchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="线程的状态和方法"><a href="#线程的状态和方法" class="headerlink" title="线程的状态和方法"></a>线程的状态和方法</h2><h3 id="线程的主要状态-了解、笔试题"><a href="#线程的主要状态-了解、笔试题" class="headerlink" title="线程的主要状态(了解、笔试题)"></a>线程的主要状态(了解、笔试题)</h3><p>   <strong>新建状态</strong> - 当线程对象使用new关键字创建完毕后进入的状态<br>            - 此时线程还没有开始执行<br>   <strong>就绪状态</strong> - 当线程对象调用start()方法后进入的状态<br>            - 此时线程依然没有开始执行<br>   <strong>运行状态</strong> - 当线程调度器调度就绪线程后进入的状态<br>            - 此时线程开始执行<br>            - 当时间片执行完毕后线程的任务没有完成时回到就绪状态<br>   <strong>消亡状态</strong> - 当时间执行完毕后线程的任务已经完成时进入的状态<br>            - 此时线程已经终止<br>   <strong>阻塞状态</strong> - 当线程执行的过程中发生了阻塞事件后进入的状态，如：sleep()方法<br>            - 当阻塞状态解除后回到就绪状态  </p><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><p>   <code>static void sleep(long millis)</code> - 用于使得调用线程休眠参数指定的毫秒数<br>   <code>int getPriority()</code>- 用于获取线程的优先级<br>  <code>void setPriority(int newPriority)</code> - 用于设置线程的优先级<br>      - 优先级高的线程不一定先执行，但是该线程获得CPU时间片的机会更多一些<br>  <code>void join()</code>- 用于等待调用线程终止<br> <code>void join(long millis)</code> - 用于等待线程的最长时间为参数指定的毫秒数<br>  <code>boolean isDaemon()</code> - 用于判断该线程是否为守护线程<br> <code>void setDaemon(boolean on)</code> - 用于设置该线程为守护线程  </p><ul><li>该方法必须在启动线程前调用  <ul><li>当所有非守护线程结束后，则守护线程会随之结束，此时Java虚拟机退出  </li></ul></li></ul><h3 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h3><p><em>基本概念</em><br>   当多个线程同时访问同一种共享资源时可能会造成数据的不一致等问题，此时就需要对多个线程之间进行协调和通信，该机制就叫线程的同步机制<br>如：<br>    03年以前   开户   存折<br>    03年       开户   存折   银行卡   对应同一个账户</p><p><em>解决方案</em><br>   引发问题：由程序可知，当两个线程同时对同一个账户进行取款时会导致账户余额不合理！<br>   引发原因：线程一还没有执行完毕取款操作时，线程二已经开始执行<br>   解决方案：让多个线程的并发操作修改为串行操作即可<br>   带来缺点：串行操作的范围应该越小越好，否则会影响多线程的执行效率<br>   <br><br><em>实现方式</em><br>   Java语言中提供了synchronized关键字来表示同步锁/对象锁，来保证线程操作的原子性，而具体使用方式如下：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     synchronized(对象的引用)&#123;</span><br><span class="line">         编写所有需要锁定的代码;</span><br><span class="line">     &#125;</span><br><span class="line">   (2)使用同步方法的方式实现</span><br><span class="line">     使用synchronized关键字修饰整个方法，表示锁定该方法的所有代码；</span><br><span class="line">     该方式等价于：</span><br><span class="line">         synchronized(this)&#123; 方法体的代码; &#125;</span><br><span class="line">(e)</span><br></pre></td></tr></table></figure></p><p><strong>原理分析</strong><br>   当多个线程启动后会同时抢占共享资源，若其中一个线程抢到了同步锁则其它线程进入阻塞状态，直到该线程执行完毕所有锁定代码后自动释放同步锁，而阻塞的所有线程重新抢占同步锁，抢不到的线程继续阻塞  </p><p><strong>死锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    public void run()&#123;</span><br><span class="line"></span><br><span class="line">        synchronized(a)&#123;  //持有对象锁a，等待对象锁b</span><br><span class="line">           synchronized(b)&#123;</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">线程二执行的代码：</span><br><span class="line">    public void run()&#123;</span><br><span class="line"></span><br><span class="line">        synchronized(b)&#123;  //持有对象锁b，等待对象锁a</span><br><span class="line">           synchronized(a)&#123;</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>注意：</em><br>   在以后的开发中尽量不要使用同步语句块的嵌套结构    </p><p><strong>Object类中的方法</strong><br>  <code>void wait()</code> - 用于使得当前线程进入等待状态，直到其它线程调用唤醒的方法为止<br>  <code>void wait(long timeout)</code><br>       - 用于使得当前线程进入等待状态，直到其它线程唤醒或参数指定的毫秒时间过去为止<br> <code>void notify()</code>- 用于唤醒等待的单个线程<br> <code>void notifyAll()</code> - 用于唤醒等待的所有线程  </p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread类</title>
    <link href="undefined2019/10/26/2019-10-26-throad/"/>
    <url>2019/10/26/2019-10-26-throad/</url>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   <em>程序</em> - 数据结构 + 算法，主要指存放在硬盘上的可执行文件<br>   <em>进程</em> - 主要指运行在内存中的程序</p><p>   目前主流的操作系统都支持多进程，是为了让操作系统可以同时执行多个任务，但进程是重量级的，新建进程对系统资源的消耗比较大，因此进程的数量比较局限<br>   线程是进程内部的程序流，也就是说操作系统支持多进程，而每个进程的内部又支持多线程，并且线程是轻量级的，会共享所在进程的资源，因此以后主流的开发都采用多线程技术<br>   多线程技术是采用时间片轮转法来保证并发执行的效果，所谓并发就是指宏观并行微观串行的机制。</p><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p><strong>创建的方式</strong><br>   <code>java.lang.Thread</code>类用于描述线程，Java虚拟机允许运行多个执行线程，而线程的创建和启动方式如下:</p><ol><li>自定义类继承Thread类并重写run()方法，创建该类的对象调用start()方法  </li><li>自定义类实现Runnable接口并重写run()方法，创建该类的对象作为实参来构造<br>  Thread类的对象，然后使用Thread类对象调用start()方法  </li></ol><p><strong>相关的方法</strong><br>   <code>Thread()</code> - 使用无参形式构造对象<br>   <code>Thread(String name)</code> - 根据参数指定的名称来构造对象<br>   <code>Thread(Runnable target)</code> - 根据参数指定的引用来构造对象<br>   <code>Thread(Runnable target, String name)</code> - 根据参数指定引用和名称来构造对象<br>   <code>void run()</code> - 若使用Runnable接口构造对象后调用该方法，则最终调用Runnable引用<br>        指向实现类中的run()方法，否则调用该方法则表示啥也不干<br>   <code>void start()</code> - 用于启动线程，Java虚拟机会自动调用该线程的run()方法  </p><p><strong>原理分析</strong></p><ol><li>执行main()方法的线程叫做主线程，执行run()方法的线程叫做子/新线程  </li><li>对于start()方法调用代码以及之前的代码来说，由主线程执行一次，当start()方法<br>  调用结束后，则线程的个数瞬间由1个变成了2个，其中新启动的线程去执行run()方法，<br>  原来的主线程继续向下执行，两个线程各自独立运行  </li><li>当run()方法结束后则子线程结束，当main()方法结束后则主线程结束，两个线程的<br>  执行先后次序没有明确的规定，由系统调度算法来决定  </li></ol><p><strong><em>注意</em></strong>：<br>   继承方式创建和启动线程的代码相对简单，但Java语言中只支持单继承，若该类继承Thread类后则无法继承其它类，而实现接口的方式虽然代码复杂，但不影响该类继承其它类以及实现其它接口，因此以后的开发中推荐使用实现接口的方式<br><strong>线程的编号和名称</strong><br>   <code>long getId()</code> - 用于获取线程的标识符/编号<br>  <code>String getName()</code>- 用于获取线程的名称<br>   <code>void setName(String name)</code>- 用于更改线程的名称<br>   <code>static Thread currentThread()</code> - 用于获取当前正在执行线程的引用并返回  </p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O流(二)</title>
    <link href="undefined2019/10/25/2019-10-25-IoLiu/"/>
    <url>2019/10/25/2019-10-25-IoLiu/</url>
    
    <content type="html"><![CDATA[<h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><ol><li><p>基本概念<br>java.io.FileOutputStream类主要用于写入图像数据之类的原始字节流到输出流中。</p></li><li><p>常用的方法<br><code>FileOutputStream(String name)</code> - 根据参数指定的文件名来构造对象<br><code>FileOutputStream(String name, boolean append)</code> </p><pre><code>以追加的方式根据文件名构造对象  </code></pre><p><code>void write(int b)</code></p><pre><code>用于将参数指定的单个字节写入输出流  </code></pre><p><code>void write(byte[] b, int off, int len)</code></p><pre><code>用于将数组b中下标从off开始的len个字节写入输出流  </code></pre><p><code>void write(byte[] b)</code></p><pre><code>用于将数组b中所有字节写入输出流    //  String转换字节数组：&quot;Hello&quot;.getBytes()  </code></pre><p><code>void close()</code></p><pre><code>用于关闭流并释放有关的资源  </code></pre></li></ol><h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><ol><li><p>基本概念<br>java.io.FileInputStream类主要用于从输入流中读取图像数据之类的字节流 </p></li><li><p>常用的方法<br><code>FileInputStream(String name)</code>  根据参数指定的文件名来构造对象<br><code>int read()</code>   用于读取单个字节   </p><pre><code>若读取到文件末尾则返回-1，否则返回实际读到的数据内容  </code></pre><p><code>int read(byte[] b, int off, int len)</code> 数组转字符串 用于从输入流中读取len个字节的数据放入数组b中下标从off开始的位置   </p><pre><code>若读取到文件末尾则返回-1，否则返回实际读到的字节个数   </code></pre><p><code>int read(byte[] b)</code></p><pre><code>用于从输入流中读取b.length个字节的数据放入数组b中   </code></pre><p><code>int available()</code></p><pre><code>用于获取该输入流所关联文件的大小   </code></pre><p><code>void close()</code></p></li></ol><h3 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h3><ol><li><p>基本概念<br>java.io.DataOutputStream类用于将Java基本数据类型的变量写入输出流中。</p></li><li><p>常用的方法<br>DataOutputStream(OutputStream out) - 根据参数指定的引用构造对象。</p><pre><code>- 其中OutputStream类是个抽象类，实参需要传递子类的对象。            例；；；；；；；； DataOutputStream da=new DataOutputStream(                                                                                                 new FileOutputStream(地址))；</code></pre><p>void writeInt(int v) </p><pre><code>- 用于将参数指定的整数以4字节的方式写入输出流中，先写入高字节。- 127: 0000 0000   0000 0000   0000 0000   0111 1111          高               =&gt;                 低</code></pre><p>void close()</p><h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3></li><li><p>基本概念<br>java.io.DataInputStream类用于从输入流中读取Java基本数据类型的内容 </p></li><li><p>常用的方法<br>DataInputStream(InputStream in)  根据参数指定的引用来构造对象 </p><pre><code>其中InputStream类是个抽象类，实参需要传递子类的对象  </code></pre><p>int readInt() </p><pre><code>用于读取4个字节的整数数据并返回  </code></pre><p>void close() </p></li></ol><h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><ol><li><p>基本概念<br>java.io.ObjectOutputStream类主要用于将Java语言的对象整体写入输出流中<br>只能将支持 java.io.Serializable 接口的对象写入流中<br>类通过实现 java.io.Serializable 接口以启用其序列化功能<br>所谓序列化将一个对象所依赖的相关信息有效组织成字节序列的转化过程 </p></li><li><p>常用的方法<br>ObjectOutputStream(OutputStream out)   根据参数指定的引用来构造对象</p><pre><code>其中OutputStream类是个抽象类，实参需要传递子类的对象  </code></pre><p>void writeObject(Object obj) </p><pre><code>用于将参数指定的对象整体写入输出流中  </code></pre><p>void close()</p></li></ol><h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><ol><li><p>基本概念<br>java.io.ObjectInputStream类主要用于从输入流中读取一个对象整体  </p></li><li><p>常用的方法<br>ObjectInputStream(InputStream in)   根据参数指定的引用来构造对象  </p><pre><code>其中InputStream类是抽象类，实参需要传递子类的对象  </code></pre><p>Object readObject()   </p><pre><code>用于从输入流中读取一个对象并返回  无法通过返回值来判断是否读取到文件的末尾  </code></pre><p>void close()  </p></li></ol><p><strong>当需要将多个对象写入文件时，通常建议先将多个对象放入一个集合中，然后将该集合整体看做一个对象写入文件中，此时只需要从文件中读取一次就可以读出所有内容</strong>  </p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O流(一)</title>
    <link href="undefined2019/10/24/2019-10-24-IoLiu/"/>
    <url>2019/10/24/2019-10-24-IoLiu/</url>
    
    <content type="html"><![CDATA[<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><ol><li><p>基本概念<br>I/O就是Input/Output的简写，也就是输入/输出的含义<br>I/O流就是指像流水一样不间断地进行读写数据的状态  </p></li><li><p>基本分类<br>按照数据读写的单位不同分为：字节流 和 字符流<br>其中字节流主要指以字节为单位进行读写的过程，可以读写任意类型的文件<br>其中字符流主要指以字符(2个字节)为单位进行读写的过程，只能读写文本文件  </p><p>按照数据流动的方向不同分为：输入流 和 输出流(站在程序的角度)<br>其中输入流主要指从文件中读取数据内容输入到程序中<br>其中输出流主要指将程序中的数据内容输出到文件中，也就是写入文件  </p></li><li><p>基本框架<br>字节流的顶层父类：InputStream类 和 OutputStream类<br> InputStream类的常用子类：  </p><pre><code>FileInputStream类、DataInputStream类、ObjectInputStream类    </code></pre><p> OutputStream类的常用子类：  </p><pre><code>FileOutputStream类、  DataOutputStream类、  ObjectOutputStream类`</code></pre><p>字符流的顶层父类：Reader类  和  Writer类<br>Reader类的常用子类：  </p><pre><code>BufferedReader类、InputStreamReader类   </code></pre><p>Writer类的常用子类：  </p><pre><code>BufferedWriter类、  OutputStreamWriter类   </code></pre></li></ol><h3 id="部分常用方法"><a href="#部分常用方法" class="headerlink" title="部分常用方法"></a>部分常用方法</h3><p><strong>BufferedReader类</strong></p><ol><li><p>基本概念<br>java.io.BufferedReader类主要用于从输入流中读取单个字符、字符数组以及一行字符串</p></li><li><p>常用的方法<br><code>BufferedReader(Reader in)</code>   根据参数指定的引用构造对象 </p><pre><code>其中Reader类是个抽象类，实参需要传递子类的对象  </code></pre><p><code>int read()</code>   用于从输入流中读取单个字符    若读取到文件末尾则返回-1，否则返回实 际读取到的数据内容对应的整数值<br><code>int read(char[] cbuf, int off, int len)</code> </p><pre><code>用于从输入流中读取len个字符放入数组cbuf中下标从off开始的位置    若读取到文件末尾则返回-1，否则返回实际读取到的字符数  </code></pre><p><code>int read(char[] cbuf)</code></p><pre><code>用于从输入流中读取cbuf.length个字符到数组cbuf中    </code></pre><p><code>String readLine()</code></p><pre><code>用于从输入流中读取一行字符串内容。若读取到文件末尾则返回null        </code></pre><p><code>void close()</code>                       </p></li></ol><p><strong>PrintStream类</strong></p><ol><li><p>基本概念<br>java.io.PrintStream类主要用于实现各种数据的打印并自动刷新 </p></li><li><p>常用的方法<br><code>PrintStream(OutputStream out)</code>   根据参数指定的引用构造对象  </p><pre><code>- 其中OutputStream类是个抽象类，实参需要传递子类的对象   </code></pre><p><code>void print(String s)</code><br>用于打印参数指定的字符串内容<br><code>void println(String x)</code></p><pre><code>用于打印参数字符串后终止该行 </code></pre><p><code>void close()</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的异常机制</title>
    <link href="undefined2019/10/23/2019-10-23-Exception/"/>
    <url>2019/10/23/2019-10-23-Exception/</url>
    
    <content type="html"><![CDATA[<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   异常就是”不正常”的含义，在Java语言中主要指运行阶段发生的错误,Java中错误有俩种：<br>   Error类主要描述比较严重通常无法编码解决的错误<br>   Exception类主要描述轻微可以编码解决的错误，如：0作为除数  </p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p>   java.lang.Exception类是所有异常的超类，具体分类如下：<br>       RuntimeException异常 - 运行时异常，也叫做非检测性异常<br>       IOException和其它异常 - 其他异常，也叫做检测性异常<br>             所谓检测性异常就是在编译阶段能够被编译器检测出来并给出提示的异常<br>   RuntimeException异常的主要子类：</p><ul><li>ArithmeticException - 算术异常</li><li>ArrayIndexOutOfBoundsException - 数组下标越界异常</li><li>NullPointerException - 空指针异常</li><li>ClassCastException - 类型转换异常</li><li>NumberFormatException - 数字格式异常</li></ul><p><strong>注意</strong>：<br>   当程序执行过程中发生异常又没有手动处理时，则由Java虚拟机采用默认方式处理，而默认处理方式：打印异常的名称、异常的原因、异常发生位置后终止程序，导致后续代码无法执行   </p><h3 id="异常的避免"><a href="#异常的避免" class="headerlink" title="异常的避免"></a>异常的避免</h3><p>   对于绝大多数的非检测性异常可以直接使用if条件判断来避免该异常的发生。</p><h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><ol><li>语法格式<br>try{<br>   编写所有可能发生异常的语句；<br>}<br>catch(异常类型 变量名){<br>   编写针对该类异常处理的语句；<br>}<br>…<br>finally{<br>   编写无论是否发生异常都应该执行的语句；<br>}</li><li>注意事项<br>a.若需要多个catch分支时，切记小类型的异常放在大类型的前面。<br>b.懒人的写法：<pre><code>catch(Exception e){ ...}</code></pre>c.finally{}中的代码主要用于进行善后工作的处理，如：关闭打开的文件、删除文件等</li></ol><h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><ol><li><p>基本概念<br>在某些特殊场合中无法处理或不便于处理发生的异常，此时就需要将异常转移给该方法的调用者处理，这种方式就叫异常的抛出。</p></li><li><p>语法格式<br>访问控制符 返回值类型 方法名称(形参列表) throws 异常类型1,异常类型2,…{}</p></li><li><p>方法重写的原则<br>a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类。<br>b.要求方法权限不能变小，可以相同或变大。<br>c.要求不能抛出更大的异常。</p></li></ol><p><strong>注意</strong>：<br>   子类重写的方法可以抛出与父类一样的异常、更小的异常以及不抛出异常，但不能抛出更大的异常或平级不一样的异常。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li><p>基本概念<br>虽然Java官方提供了大量异常类但没有专门针对年龄不合理的异常类，若希望使用这种针对性的异常就需要程序员自己写一个异常类。</p></li><li><p>实现流程<br>a.自定义XXXException继承Exception或者其子类；<br>b.提供两个版本的构造方法：无参构造 和 字符串作为参数的构造；</p></li><li><p>异常对象的产生<br>throw new 异常类型();<br>如：<br>throw new NullPointerException(); - 表示产生空指针异常</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map集合简介</title>
    <link href="undefined2019/10/22/2019-10-22-Map-collection/"/>
    <url>2019/10/22/2019-10-22-Map-collection/</url>
    
    <content type="html"><![CDATA[<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p><strong>基本概念</strong><br>   <code>java.util.Map&lt;K,V&gt;</code>接口中存放元素的基本单位是：单对元素 (键值对) </p><ul><li><p>K - 用于描述键(Key)的类型</p></li><li><p>V - 用于描述值(Value)的类型</p><p>该接口的主要实现类：HashMap类 和 TreeMap类<br>该接口中key(键)不允许重复，而且每个key(键)能且只能对应一个Value(值)  </p></li></ul><p><strong>常用方法</strong><br><code>V put(K key, V value)</code>   用于将key和value组成一对放入当前集合中  </p><ul><li><p>若实现增加功能则返回null；若实现修改功能则返回原来的value.    </p><p><code>boolean containsKey(Object key)</code></p><pre><code>用于判断当前集合中是否存在参数指定的key  </code></pre><p><code>boolean containsValue(Object value)</code> </p><pre><code>用于判断当前集合中是否存在参数指定的value   </code></pre><p><code>V get(Object key)</code></p><pre><code>用于根据参数指定的key返回对应的value，若key不存在则返回null  </code></pre><p><code>V remove(Object key)</code></p><pre><code>用于根据参数指定的key来删除键值对，返回该key对应的value    </code></pre><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></p><pre><code>用于将Map集合转换为Set集合，集合中的每个元素都是键值对  </code></pre><ul><li>其中Map.Entry是接口类型，常用方法有：  </li></ul><ul><li>K getKey()   用于获取键值对中的键 </li><li>V getValue()  用于获取键值对中的值</li></ul><p><code>Set&lt;K&gt; keySet()</code>  用于将Map集合中的所有键放入Set集合中并返回  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//Map集合各种方法的使用</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TestHashMap &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//1.声明Map类型的引用指向实现类的对象，形成多态</span><br><span class="line">Map&lt;String, String&gt; m1 = new HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">//2.向Map集合中添加元素并打印</span><br><span class="line">m1.put(&quot;1&quot;, &quot;one&quot;);</span><br><span class="line">m1.put(&quot;2&quot;, &quot;two&quot;);</span><br><span class="line">m1.put(&quot;3&quot;, &quot;three&quot;);</span><br><span class="line">System.out.println(&quot;m1 = &quot; + m1); //输出&#123;1=one, 2=two, 3=three&#125;</span><br><span class="line"> </span><br><span class="line">//3.查找Map集合中是否拥有指定的key以及指定的value并打印</span><br><span class="line">boolean b1 = m1.containsKey(&quot;4&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); //false</span><br><span class="line">b1 = m1.containsKey(&quot;1&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); //true</span><br><span class="line"></span><br><span class="line">b1 = m1.containsValue(&quot;eleven&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); //false</span><br><span class="line">b1 = m1.containsValue(&quot;three&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); //true</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line">//4.根据参数指定的key返回对应的value，若不存在则返回null</span><br><span class="line">String str1 = m1.get(&quot;5&quot;);</span><br><span class="line">System.out.println(&quot;str1 = &quot; + str1); //null</span><br><span class="line">str1 = m1.get(&quot;2&quot;);</span><br><span class="line">System.out.println(&quot;str1 = &quot; + str1); //two</span><br><span class="line"></span><br><span class="line">//5.实现集合中元素的删除</span><br><span class="line">String str2 = m1.remove(&quot;10&quot;);</span><br><span class="line">System.out.println(&quot;str2 = &quot; + str2); //null</span><br><span class="line">System.out.println(&quot;m1 = &quot; + m1); //&#123;1=one, 2=two, 3=three&#125;</span><br><span class="line"></span><br><span class="line">str2 = m1.remove(&quot;1&quot;);</span><br><span class="line">System.out.println(&quot;str2 = &quot; + str2); //one</span><br><span class="line">System.out.println(&quot;m1 = &quot; + m1); //&#123;2=two, 3=three&#125;</span><br><span class="line"></span><br><span class="line">//6.实现Map集合中所有元素的遍历</span><br><span class="line">//方式一：调用toString()方法可以实现遍历</span><br><span class="line">System.out.println(&quot;m1 = &quot; + m1); //&#123;2=two, 3=three&#125;</span><br><span class="line"></span><br><span class="line">//方式二：调用entrySet()方法可以实现遍历</span><br><span class="line">//实现Map集合向Set集合的转换</span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; s1 = m1.entrySet();</span><br><span class="line">//使用for each结构来打印Set集合中的所有元素</span><br><span class="line">for(Map.Entry&lt;String,String&gt; me : s1)&#123;</span><br><span class="line">//System.out.println(me);</span><br><span class="line">System.out.println(me.getKey() + &quot;=&quot; + me.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方式三：调用keySet()方法可以实现遍历</span><br><span class="line">//实现Map集合中所有的key转换为Set集合</span><br><span class="line">Set&lt;String&gt; s2 = m1.keySet();</span><br><span class="line">//使用for each结构打印Set集合中的所有元素</span><br><span class="line">for(String ts : s2)&#123;</span><br><span class="line">System.out.println(ts + &quot;=&quot; + m1.get(ts));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set集合简介</title>
    <link href="undefined2019/10/21/2019-10-21-Set-Collection/"/>
    <url>2019/10/21/2019-10-21-Set-Collection/</url>
    
    <content type="html"><![CDATA[<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>   java.util.Set接口是Collection接口的子接口，与List接口是平级关系<br>   该接口与List接口相比元素没有先后次序，并且不允许有重复的元素。无序且唯一<br>   该接口的主要实现类：HashSet类 和 TreeSet类<br>   其中HashSet类的底层是采用哈希表进行数据管理的<br>   其中TreeSet类的底层是采用有序二叉树进行数据管理的  </p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><p>   其实Set集合好多方法都是从Collection中继承过来的，所以常用方法参照Collection集合 </p><p>   <code>Iterator&lt;E&gt; iterator()</code>  获取当前集合中的迭代器对象，用于迭代/遍历集合中所有元素<br>   其中Iterator<e>是个接口，常用方法如下：<br>       <code>boolean hasNext()</code> 用于判断是否拥有可以访问的元素<br>      <code>E next()</code>  用于取出一个元素并指向下一个位置<br>      <code>void remove()</code>   用于将刚刚取出的元素删除  </e></p><p><strong>小知识—forEach循环</strong></p><ul><li>语法格式<br><code>for( 元素类型 变量名 : 集合/数组的名称){  循环体;}</code><ul><li>执行流程<br>不断地从集合/数组中取出一个元素赋值给变量后执行循环体，直到处理完毕所有元素为止</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// Set集合常用方法使用</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TestSet &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">// 1.声明Set接口的引用指向实现类的对象，形成了多态</span><br><span class="line">Set&lt;String&gt; s1 = new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">// 2.向集合中添加元素内容</span><br><span class="line">boolean b1 = s1.add(&quot;two&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); // true</span><br><span class="line">System.out.println(&quot;s1 = &quot; + s1); // [one, two]</span><br><span class="line">b1 = s1.add(&quot;one&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); // true</span><br><span class="line">System.out.println(&quot;s1 = &quot; + s1); // [one]</span><br><span class="line">b1 = s1.add(&quot;three&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); // true</span><br><span class="line">System.out.println(&quot;s1 = &quot; + s1); // [one, two, three]</span><br><span class="line">b1 = s1.add(&quot;one&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1); // false</span><br><span class="line">// 自动调用toString()方法，得到String类型的整体</span><br><span class="line">System.out.println(&quot;s1 = &quot; + s1); // [one, two, three]</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">// 3.使用迭代器来访问集合中的每个元素并打印出来</span><br><span class="line">// 3.1 获取迭代器对象并记录</span><br><span class="line">Iterator&lt;String&gt; it1 = s1.iterator();</span><br><span class="line">/*</span><br><span class="line">// 3.2 判断是否拥有可以访问的元素</span><br><span class="line">System.out.println(it1.hasNext()); // true</span><br><span class="line">// 3.3 取出该元素并并打印出来然后指向下一个位置</span><br><span class="line">System.out.println(&quot;获取到的元素是：&quot; + it1.next()); // one</span><br><span class="line"></span><br><span class="line">// 3.2 判断是否拥有可以访问的元素</span><br><span class="line">System.out.println(it1.hasNext()); // true</span><br><span class="line">// 3.3 取出该元素并并打印出来然后指向下一个位置</span><br><span class="line">System.out.println(&quot;获取到的元素是：&quot; + it1.next()); // two</span><br><span class="line">*/</span><br><span class="line">while(it1.hasNext())&#123;</span><br><span class="line">System.out.println(&quot;获取到的元素是：&quot; + it1.next()); //one two three</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//练习：使用StringBuilder类和迭代器实现toString()方法的打印效果</span><br><span class="line">StringBuilder sb1 = new StringBuilder();</span><br><span class="line">sb1.append(&quot;[&quot;);</span><br><span class="line">//重新获取迭代器，也就是让迭代器回到开头位置</span><br><span class="line">it1 = s1.iterator();</span><br><span class="line">//将集合中每个元素取出来拼接字符串</span><br><span class="line">while(it1.hasNext())&#123;</span><br><span class="line">String str = it1.next();</span><br><span class="line">//若处理最后一个元素时，直接连接元素和]</span><br><span class="line">/*</span><br><span class="line">if(!it1.hasNext())&#123;</span><br><span class="line">sb1.append(str).append(&quot;]&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">sb1.append(str).append(&quot;,&quot;).append(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">if(it1.hasNext())&#123;</span><br><span class="line">sb1.append(str).append(&quot;,&quot;).append(&quot; &quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">sb1.append(str).append(&quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//将最后一个元素后面的逗号和空格删除</span><br><span class="line">//sb1.delete(sb1.length()-2, sb1.length());</span><br><span class="line">//拼接最后的]</span><br><span class="line">//sb1.append(&quot;]&quot;);</span><br><span class="line">System.out.println(&quot;s1 = &quot; + sb1);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">//4.实现集合中元素的删除操作</span><br><span class="line">System.out.println(&quot;s1 = &quot; + s1); //[one, two, three]</span><br><span class="line">//使用迭代器获取集合中的每个元素并判断，若是&quot;two&quot;则删除否则打印即可</span><br><span class="line">//重新获取迭代器，也就是让迭代器回到开头位置</span><br><span class="line">it1 = s1.iterator();</span><br><span class="line">while(it1.hasNext())&#123;</span><br><span class="line">//切记next()方法会取出元素的同时指向下一个位置</span><br><span class="line">/*</span><br><span class="line">if(it1.next().equals(&quot;two&quot;))&#123;</span><br><span class="line">//调用迭代器的remove()方法可以删除元素</span><br><span class="line">it1.remove();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(it1.next());</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">String str2 = it1.next();</span><br><span class="line">if(&quot;two&quot;.equals(str2))&#123;</span><br><span class="line">//调用迭代器自己的remove()方法删除元素</span><br><span class="line">it1.remove();</span><br><span class="line">//调用Set集合自己的remove()方法删除元素</span><br><span class="line">//s1.remove(str2); //编译ok，运行产生异常</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(str2); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">System.out.println(&quot;删除之后的结果是：&quot; + s1); //[one, three]</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">//5.使用forEach循环来打印集合s1中的所有元素，推荐使用</span><br><span class="line">for(String ts : s1)&#123;</span><br><span class="line">System.out.println(ts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">//使用forEach打印数组中的所有元素</span><br><span class="line">int[] arr = &#123;11, 22, 33, 44, 55&#125;;</span><br><span class="line">for(int ti : arr)&#123;</span><br><span class="line">System.out.println(ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List集合简介</title>
    <link href="undefined2019/10/19/2019-10-19-List-Collection/"/>
    <url>2019/10/19/2019-10-19-List-Collection/</url>
    
    <content type="html"><![CDATA[<h2 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection 集合"></a>Collection 集合</h2><p>在Java中 集合框架的顶层接口就是<code>java.util.Collection 和 java.util.Map</code><br> 其中Collection接口中存放元素的基本单位是：单个元素<br> 而Map接口中存放元素的基本单位是：单对元素  </p><p> 而我们今天学习的是List集合，它是Collection接口的子接口 ，其实我们开发中很少直接使用Collection接口，而是更多的使用该接口的子接口：List接口、Queue接口以及Set接口</p><p><strong>常用方法</strong><br> <code>boolean add(E e)</code> 用于将参数指定的元素e放入当前集合中<br>  <code>boolean addAll(Collection&lt;? extends E&gt; c)</code><br>        用于将参数集合c中的所有元素放入当前集合中<br>   <code>boolean contains(Object o)</code>用于判断当前集合是否包含参数指定的单个元素<br>  <code>boolean containsAll(Collection&lt;?&gt; c)</code><br>   用于判断是否包含参数c中的所有元素<br>   <code>boolean remove(Object o)</code>  用于将参数指定的单个元素从当前集合删除<br>   <code>boolean removeAll(Collection&lt;?&gt; c)</code><br>        用于删除参数集合中的所有元素<br>  <code>void clear()</code>用于清空当前集合中的所有元素<br>   <code>int size()</code>  用于获取集合中的元素个数<br>  <code>boolean isEmpty()</code>  用于判断当前集合是否为空<br>  <code>boolean retainAll(Collection&lt;?&gt; c)</code><br>        用于计算调用对象和参数对象的交集并保留到当前集合中，覆盖原有数据<br>     当前集合中的元素若发生改变则返回true，否则返回false</p><h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h2><p>   java.util.List接口是Collection接口的子接口<br>   该集合中的所有元素拥有先后放入次序，并且允许重复。 简称有序不唯一<br>   该集合的主要实现类由：ArrayList类、LinkedList类、Stack类<br>   其中ArrayList类的底层是采用动态数组实现的，因此访问元素方便，增删元素不方便<br>   其中LinkedList类的底层是采用链表实现的，因此访问元素不方便，增删元素方便<br>   其中Stack类的底层是采用动态数组实现的，该集合主要用于描述具有后进先出特性的数据结构，叫做栈(last in first out LIFO)  </p><p>   <strong>常用方法</strong><br>   <code>void add(int index, E element)</code><br>         用于将元素element插入到下标index的位置<br>   <code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>  用于将集合c中的所有元素插入到下标index的位置<br>  <code>E get(int index)</code><br>         用于根据参数index指定的下标获取对应的元素并返回<br>  <code>E remove(int index)</code><br>         用于根据参数index指定的下标位置来删除元素<br>   返回被删除的元素值<br>  <code>E set(int index, E element)</code><br>         用于将参数index指定下标位置的元素修改为element，返回修改之前的元素<br>   <code>List&lt;E&gt;subList(int fromIndex, int toIndex)</code><br>        用于获取子List，sublist获取的List与原List占有相同的存储空间，对子List的操作会影响到原List </p><p><strong>Java中的泛型机制</strong>  </p><p>通常情况下集合中允许存放各种不同类型的对象，此时这些对象都被看做Object类型放入，当集合中的这些数据被取出之后也是Object类型，为了表达数据的真实类型需要做强制类型转换，而强制类型转换很可能引发类型转换异常</p>所以泛型机制的出现，明确要求集合后跟<数据类型>，规范了该集合可以存放的类型   <p>集合 &lt;数据类型&gt; 变量名 = new 集合&lt;同前边的数据类型，可写可不写&gt;();</p><p>泛型的本质就是参数化类型，也就是让数据类型作为参数传递的方式，其中E相当于形式参数负责占位，当准备集合时&lt;&gt;中的数据类型相当于实际参数负责给形式参数E进行赋值，此时集合中所有E都被替换为实际参数类型，由于实际参数可以传递的类型非常广泛，因此得名”泛型”</p></数据类型>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期日历类</title>
    <link href="undefined2019/10/18/2019-10-18-date/"/>
    <url>2019/10/18/2019-10-18-date/</url>
    
    <content type="html"><![CDATA[<h2 id="日期相关的类"><a href="#日期相关的类" class="headerlink" title="日期相关的类"></a>日期相关的类</h2><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p><strong>基本概念</strong><br>   <code>java.util.Date</code>类用于描述特征的瞬间，可以精确到毫秒数</p><p><strong>常用的方法</strong></p><p>   <code>Date()</code> 使用无参的方式构造对象，默认采用当前系统时间来初始化<br>   <code>Date(long date)</code>  根据参数指定的毫秒数来构造对象。</p><ul><li>其中参数为距离1970年1月1日0时0分0秒以来的毫秒数  </li><li>1秒 = 1000毫秒</li></ul><ul><li><p>可File类中的方法搭配使用。  </p><p><code>long getTime()</code><br>用于获取当前调用对象距离1970年1月1日0时0分0秒的毫秒数<br><code>void setTime(long time)</code><br>用于设置当前调用对象的时间为距离1970年1月1日0时0分0秒的毫秒数。</p></li></ul><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><p><strong>基本概念</strong><br><code>java.text.SimpleDateFormat</code>类主要用于实现日期和文本之间的转换  </p><p><strong>常用的方法</strong><br>   <code>SimpleDateFormat(String pattern)</code>  根据参数指定的模式来构造对象</p><ul><li>常用的模式有：y-年  M-月  d-日  H-时  m-分  s-秒  </li></ul><p><code>public final String format(Date date)</code><br>  用于实现Date类型向String类型的转换<br>   <code>Date parse(String source)</code><br>        用于实现String类型向Date类型的转换。</p><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p><strong>基本概念</strong><br>   <code>java.util.Calendar</code>类用于描述特定的瞬间，来取代Date类中的过时方法<br>   <em>该类是个抽象类，因此该类不能构造对象。</em></p><p><strong>常用的方法</strong><br>   <code>static Calendar getInstance()</code><br>        用于获取Calendar类型的引用并返回<br>   <code>void set(int year, int month, int date, int hourOfDay, int minute, int second)</code><br>        用于设置年月日时分秒信息<br>   <code>Date getTime()</code><br>        用于将Calendar类型的时间转换为Date类型的对象并返回</p><pre><code>一个小案例: 提示用户按照指定的格式输入生日信息，计算距离1970年1月1日的天数并打印出来    //1.提示用户按照指定的格式输入生日信息并使用变量记录      System.out.println(&quot;请输入您的生日信息(xxxx年xx月xx日)：&quot;);      Scanner sc = new Scanner(System.in);      String str = sc.next();      //2.根据用户输入的生日信息转换为距离1970年1月1日的天数并记录      SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);      //实现字符串内容向Date类型的转换      Date d1 = sdf.parse(str);      System.out.println(&quot;根据用户输入的字符串转换的日期是：&quot; + d1);      //获取距离1970年1月1日的毫秒数      long msec = d1.getTime();      System.out.println(&quot;距离1970年1月1日的毫秒数为：&quot; + msec);      //转换为天数      long day = (msec/1000/3600+8)/24;      //3.打印最终的转换结果      System.out.println(&quot;距离1970年1月1日的天数为：&quot; + day);</code></pre>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String,StringBuffer,StringBuilder</title>
    <link href="undefined2019/10/17/2019-10-17-String%20StringBuilder%20StringBuffer/"/>
    <url>2019/10/17/2019-10-17-String%20StringBuilder%20StringBuffer/</url>
    
    <content type="html"><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>String类用于描述字符串，Java程序中的所有字符串字面值都可以使用该类的实例/对象加以描述<br>String类描述的字符串内容是个常量，因此可以被共享<br>String类被<code>final</code>关键字修饰 表示不能被继承<br><strong>构造方法(常见的)</strong><br><code>String()</code>  使用无参方式构造对象得到空字符序列</p><p><code>String(byte[] bytes)</code>  使用bytes数组中的所有内容构造对象 </p><p><code>String(char[] value)</code>  使用value数组中的所有内容构造对象。</p><p><strong>成员方法(常见的)</strong></p><p><code>char charAt(int index)</code>  根据参数指定的下标返回对应的单个字符<br><code>boolean contains(CharSequence s)</code> 用于判断当前字符串是否包含参数指定的内容(参数传递接口类的引用，所以实参传递实现类的对象，<b>String类</b> 刚好实现了这个接口)<br><code>boolean endsWith(String suffix)</code>  判断当前字符串是否以参数指定的内容为结尾<br><code>boolean startsWith(String prefix)</code>判断当前字符串中是否以参数指定的内容为开头<br><code>String toLowerCase()</code> 用于将当前字符串中所有字符转换为小写<br><code>String toUpperCase()</code> 用于将当前字符串中所有字符转换为大写<br><code>String trim()</code> 用于去除当前字符串中两端的空白字符<br><code>boolean equals(Object anObject)</code> 用于比较字符串内容是否相等并返回；<br><code>String substring(int beginIndex)</code> 用于获取当前字符串中从beginIndex位置开始的子字符串并返回<br><code>String substring(int beginIndex, int endIndex)</code>  用于获取当前字符串中从beginIndex位置开始到endIndex结尾的子字符串并返回<br><code>int indexOf(int ch)</code> 用于返回当前字符串中参数ch指定的字符第一次出现的下标</p><h2 id="StringBuilder类-和-StringBuffer类"><a href="#StringBuilder类-和-StringBuffer类" class="headerlink" title="StringBuilder类 和 StringBuffer类"></a>StringBuilder类 和 StringBuffer类</h2><p>这俩个类方法一模一样，只不过StringBuilder单线程效率高，而StringBuffer多线程效率低<br>StringBuilder类 和 StringBuffer类的出现是为了弥补String类描述的字符串内容是个常量不可改变，所以 StringBuilder类 和 StringBuffer类可以直接修改字符串内容<br>String StringBuffer StringBuilder操作的数据类型相同，即字符串类型</p><p><strong>常用方法</strong>  </p><p><code>StringBuilder(String str)</code>  根据参数指定的字符串来构造对象<br><code>StringBuilder insert(int offset, String str)</code>用于将参数str代表的内容插入到当前字符串中下标为offset的位置上。</p><ul><li>返回当前对象的引用，也就是当前对象自己  </li></ul><p><code>StringBuilder append(String str)</code> 用于将参数str代表的内容追加到当前字符串的末尾<br><code>StringBuilder delete(int start, int end)</code>  用于将当前字符串中从start位置(含)开始到end位置(不含)结束之间的内容删除<br><code>StringBuilder deleteCharAt(int index)</code> 用于将当前字符串中下标为index位置的单个字符删除<br><code>StringBuilder replace(int start, int end, String str)</code>用于将当前字符串中从start位置到end位置之间的内容使用str替换掉<br><code>void setCharAt(int index, char ch)</code> 用于将当前字符串中下标为index位置的单个字符修改为参数ch的数值<br><code>int indexOf(String str)</code> 用于在当前字符串中查找参数str第一次出现的索引位置<br><code>StringBuilder reverse()</code> 用于实现字符串内容的反转</p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类与接口</title>
    <link href="undefined2019/10/16/2019-10-16-abstractClass/"/>
    <url>2019/10/16/2019-10-16-abstractClass/</url>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类主要指不能具体实现的类，体现在该类不能实例化/构造对象并使用abstract修饰。  </p><p><strong>抽象方法</strong>  </p><p>抽象方法主要指不能具体实现的方法，体现在该方法没有方法体并使用abstract关键字修饰 </p><blockquote><p>public abstract void 方法名(); </p></blockquote><p><strong>注意事项</strong>  </p><ul><li>抽象类中可以有成员变量、成员方法以及构造方法。</li><li>抽象类中可以有抽象方法也可以没有。</li><li>拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并使用abstract<br>  关键字修饰的类才是真正意义上的抽象类  </li></ul><p><strong>意义</strong></p><p>抽象类的意义在于被继承而不是自身实例化对象，当一个类继承另一个类，必须重写抽象方法，否则自身也必须是抽象类，所以抽象类对子类具有规范性</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一种比抽象类还抽象的类，因此也不能实例化对象 定义接口的关键字是<code>interface</code>,实现接口的关键字是<code>implements</code>  </p><p><strong>抽象类和接口之间的区别</strong>  </p><ul><li>定义抽象类的关键字是class，而定义接口的关键字是interface。</li><li>继承抽象类的关键字是extends，而实现接口的关键字是implements。</li><li>继承抽象类支持单继承，而实现接口支持多实现。</li><li>抽象类中可以有构造方法，而接口中不可以有。</li><li>抽象类中可以有成员变量，而接口中只可以有常量。</li><li>抽象类中可以有成员方法，而接口中只可以有抽象方法。</li><li>抽象类中增加方法通常不影响子类，而接口中增加方法通常影响子类。</li><li>从jdk1.8开始允许接口中有非抽象方法，但需要使用default关键字修饰。</li></ul>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object Oriebted</title>
    <link href="undefined2019/10/15/2019-10-15-Object%20Oriented/"/>
    <url>2019/10/15/2019-10-15-Object%20Oriented/</url>
    
    <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>为了防止给成员变量赋于一些合法但不合理的数值，对成员变量进行密封包装处理，来保证成员变量值的合理性，这种机制就叫封装</p><p>   <strong>封装的流程</strong></p><ul><li>私有化成员变量，使用private关键字修饰；</li><li>提供公有的get和set方法，在方法体中进行合理值的判断；</li><li>在构造方法中调用set方法进行合理值的判断；</li></ul><p><strong>封装好处</strong></p><ul><li>提高代码安全性（可维护性）</li><li>防止外部随意调用</li><li>降低了类于类之间的耦合度</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>当多个类中具有相同的特征和行为时，可以将共性的内容提取出来组成一个公共类，让多个类分别吸收公共类中已有的特征和行为，而在多个类的内部只需要编写自己独有特征和行为的机制就叫继承  <b>继承关键字extends</b></p><blockquote><p>注意: 其中被继承的类叫父类或者超类，或者基类<br> 继承的类叫子类或派生类<br> 一个父类可以有多个子类<br> 但是一个子类只能由一个父类</p></blockquote><p>其中可以继承的有 <em>父类中被public protected修饰的类成员</em><br>不能被继承的有 <em>父类的构造器和所有私有化的类成员</em><br>选择继承的有 <em>缺省修饰的类成员</em></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态主要指同一种事物表现出来的多种形态。<br>语法格式:  父类类型 引用变量名 = new 子类类型();  </p><p><strong>多态效果</strong><br>当父类引用指向子类对象时，父类引用可以直接调用父类独有的成员方法<br>当父类引用指向子类对象时，父类引用可以直接调用子类独有的成员方法<br>对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类版本；<br>对于父子类都有的静态成员方法来说，编译和运行阶段都调用父类版本；<br>     (静态成员隶属于类层级，与指向哪个对象无关)</p><p><strong>多态效果</strong><br>多态的实际意义在于屏蔽不同子类的差异性实现通用的编程带来不同的结果。</p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象小知识</title>
    <link href="undefined2019/10/14/2019-10-14-object%20oriented/"/>
    <url>2019/10/14/2019-10-14-object%20oriented/</url>
    
    <content type="html"><![CDATA[<p>周末午后，我正在愉快的打着王者荣耀，五杀在即之际。女朋友拿着一本我看过的《面向对象编程》过来找我。</p><p><ul><li>女朋友：什么是面向对象？是要面向我写代码吗？</li><li>我： 不是啦，这个面向对象的对象不是你这个对象啦。</li><li>此时，我突然感受到了一股莫名的杀气。</li><li>我：什么？你还有其他对象吗？有我好看吗？有我瘦吗？不对。你不能有其他对象。</li><li>什么是面向对象？</li></ul><blockquote><p>面向对象，英文名字叫Object Oriented，是一种软件开发方法。是和面向过程相对应的。</p></blockquote><ul><li><p>女朋友：别给我拽英文。给我详细说说，说不明白今天就没完。</p></li><li><p>我：我有点饿了，要不然你给我做点饭，我慢慢的详细给你讲吧。</p></li><li><p>女朋友：我现在就想听你给我讲，咱们直接点外卖吧，别自己动手做饭了。</p><p>其实，对于吃饭这件事儿，就可以分为面向过程吃饭和面向对象吃饭。自己亲自下厨就是面向过程，点外卖就是面向对象。</p><p>在面向过程的吃饭中，我们想要填饱肚子，需要自己亲自下厨把这顿饭做出来，那么，我们就需要先想好吃什么、然后去买菜、洗菜、洗米、蒸饭、炒菜等等一系列的事情。</p></li><li><p>我：那么，你说和点外卖相比，自己做饭有哪些缺点啊？</p></li><li><p>女朋友：那还用说，麻烦呗。</p></li><li><p>的确，面向过程编程也一样，由于想要完成做饭这件事，需要自己定义很多个方法。除此之外，还有很多遇到很多其他问题，比如：</p><ul><li>我不想吃米饭，我想吃馒头。</li><li>上次买的菜家里面还有，不需要去买菜。</li><li>中午吃剩下的菜家里面还有，直接热一热就可以吃了。</li><li>这次去的一家超市提供洗菜服务，不需要我们自己洗菜了。<p>以上这些突发事件，在编程中就叫做需求变更或者新的需求，这种事情发生是必然会发生的。</p></li></ul></li></ul></p><p>那么，有<strong>新的需求</strong>了怎么办？上面这种自己动手做饭的场景，就只能重新拼凑咯。</p><p>对于程序员来说，就需要通读代码，找出可以复用的方法，然后重新调用，不能复用的就重新写一个。时间久了，方法就会越来越多，系统维护越来越复杂。</p><p>面向对象，其实就是我们通过点外卖的方式来“做饭”。我们知道我们需要一顿饭，我们只需要打开外卖软件，在里面选择我们需要的菜品然后下单就可以了。我们不关心饭店做饭的过程。想吃什么点什么，家里来人了就再下一个订单，不想吃米饭了，想吃馒头了，也可以给饭店打电话，让他们把米饭换成馒头。</p><p>所以，通过面向对象的方式“做饭”，就像上面的代码一样。</p><ul><li>女朋友：哦，我明白了，面向对象就是把本来可能需要自己做的事情交给别人来做？对于我来说，外卖软件就是个对象，我再面向他“做饭”，其实是他帮我做的。</li><li>我：额、你说的也对，也不对。在这个场景中，确实可以把外卖软件当做是「对象」。其实，在面向对象编程中，抛弃了函数，想要实现一个功能不再是通过函数的叠加调用实现的了。而是通过对象。<br>对象就是对事物的一种抽象描述。现实世界中的事物，都可以用「数据」和「能力」来描述。</li></ul><blockquote><p>比如我要描述一个人，「数据」就是他的年龄、性别、身高体重，「能力」就是他能做什么工作，承担什么样的责任。</p></blockquote><blockquote><p>描述一个外卖软件，「数据」就是他包含的菜品，而「能力」就是他可以点菜。</p></blockquote><p><strong>什么是封装？</strong></p><blockquote><p>我们把「数据」和「能力」组合成一个对象的过程就叫做「封装」。</p></blockquote><blockquote><p>封装的结果就是可以有一个类，通过这个类我们可以获得一个对象。然后我们就可以通过给这个对象下命令，让他执行自己的「能力」。</p></blockquote><ul><li>女朋友：除了把「数据」和「能力」封装成一个「对象」更加方便使用以外，还有啥其他的特点么？<blockquote><p>封装只是面向对象的第一步，目的是把现实世界的东西抽象成对象。面向对象真正有威力的地方是「继承」和「多态」。</p></blockquote></li></ul><p>举一个不是很恰当，但是女朋友比较容易理解的例子。</p><p>我们使用外卖软件点餐，当我们第二次去某一家店时，外卖软件会提示你上一次你在这家点了什么，你可以点击<再来一单>把上次的菜品直接加到购物车中，这就是「继承」。而在购物车中的物品你可以直接付款下单，也可以把增删和修改菜品。这就是「多态」。</再来一单></p><p><strong>什么是继承？</strong></p><blockquote><p>在面向对象编程中，当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类「继承」这个父类。继承后子类自动拥有了父类的部分属性和方法。</p></blockquote><p><code>通过继承创建的新类称为“子类”或“派生类”。</code></p><p><code>被继承的类称为“基类”、“父类”或“超类”。</code></p><p>比如：</p><p>上面的例子中，狗类 是父类，牧羊犬类 是子类。牧羊犬类 通过继承获得狗类的 吠() 的能力，同时增加了自己独有的 放羊() 的能力。转换成Java代码如下：</p><p><strong>什么是多态？</strong></p><blockquote><p>同一操作，作用于不同的对象，可以产生不同的结果，这就是「多态」。通常说的多态都是指运行期的多态，也叫动态绑定。</p></blockquote><p>要实现多态，需要满足三个条件：</p><p><strong>有类继承或接口实现、子类重写父类的方法、父类引用指向子类的对象。</strong> 比如：</p><p>狗和狼都是犬科动物，拉来一直犬科动物，如果它你叫的话，你可能没办法直接分辨出他到底是狼还是狗。只要他真正的叫出来的时候，你才知道。这就是运行时多态。转化成Java代码如下：</p><p>这样，就实现了多态，同样是Canidae的实例，canidae.bark调用的就是Dog类的方法，而canidae1.bark();调用的却是Wolf的方法。</p><p>有人说，你自己定义的对象，定义的时候不就知道canidae到底是什么类的对象了么，这个其实并不决定的，很多时候我们可能不知道，原因是，对象可能并不是我们自己new出来的，比如Spring的IOC。</p><ul><li>女朋友：奥，那我终于知道什么是面向对象编程了。</li><li>我：嗯，对了，外卖点好了么？</li><li>女朋友：呃…</li><li>我：那.. 咋不吃饭了</li><li>女朋友：不吃饭怎么行啊</li><li>我：吃你啊<p>画面不可描述中······</p> </li></ul>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orcale,mysql,mongodb,redis对比</title>
    <link href="undefined2019/10/12/2019-10-12-ribao/"/>
    <url>2019/10/12/2019-10-12-ribao/</url>
    
    <content type="html"><![CDATA[<p><strong>MySQL概述：</strong></p><blockquote><p>关系型数据库。无论数据还是索引都存放在硬盘中。到要使用的时候才交换到内存中。能够处理远超过内存总量的数据。</p></blockquote><blockquote><p>在不同的引擎上有不同 的存储方式。</p></blockquote><blockquote><p>查询语句是使用传统的 SQL 语句，拥有较为成熟的体系，成熟度很高。</p></blockquote><blockquote><p>开源数据库的份额在不断增加，MySQL 的份额页在持续增长。</p></blockquote><blockquote><p>缺点：在海量数据处理的时候效率会显著变慢。</p></blockquote><p><strong>MySQL特点：</strong></p><blockquote><ol><li>使用c和c++编写，并使用了多种编译器进行测试，保证源代码的可移植性</li></ol></blockquote><blockquote><ol start="2"><li>支持多种操作系统</li></ol></blockquote><blockquote><ol start="3"><li>为多种编程语言提供可API</li></ol></blockquote><blockquote><ol start="4"><li>支持多线程，充分利用CPU资源<br>优化的SQL查询算法，有效的提高查询速度</li></ol></blockquote><blockquote><ol start="5"><li>提供多语言支持，常见的编码如：GB2312、BIG5、UTF8</li></ol></blockquote><blockquote><ol start="6"><li>提供TCP/IP、ODBC和JDBC等多种数据库连接途径<br>提供用于管理、检查、优化数据库操作的管理工具</li></ol></blockquote><blockquote><ol start="7"><li>大型的数据库。可以处理拥有上千万条记录的大型数据库</li></ol></blockquote><blockquote><p>8.支持多种存储引擎</p></blockquote><blockquote><ol start="9"><li>MySQL软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库</li></ol></blockquote><blockquote><ol start="10"><li>MySQL使用标准的SQL数据语言形式</li></ol></blockquote><blockquote><ol start="11"><li>Mysql是可以定制的，采用GPL协议，你可以修改源码来开发自己的MySQL系统</li></ol></blockquote><blockquote><ol start="12"><li>在线DDL更改功能</li></ol></blockquote><blockquote><ol start="13"><li>复制全局事务标识</li></ol></blockquote><blockquote><ol start="14"><li>复制无崩溃从机</li></ol></blockquote><blockquote><p>15.复制多线程从机</p></blockquote><p><strong>MongoDB概述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">它是一个内存数据库，数据都是放在内存里面的。</span><br><span class="line"></span><br><span class="line">对数据的操作大部分都在内存中，但 MongoDB 并不是单纯的内存数据库。</span><br><span class="line"></span><br><span class="line">MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的开源数据库系统。</span><br><span class="line"></span><br><span class="line">在高负载的情况下，添加更多的节点，可以保证服务器性能。</span><br><span class="line"></span><br><span class="line">MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</span><br></pre></td></tr></table></figure><blockquote><p>缺点：占用的空间很大</p></blockquote><p><strong>MongoDB特点：</strong></p><blockquote><ol><li>模式自由：可以把不同结构的文档存储在同一个数据库里</li></ol></blockquote><blockquote><ol start="2"><li>面向集合的存储：适合存储JSON风格文件的形式</li></ol></blockquote><blockquote><ol start="3"><li>完整的索引支持，对任何属性可索引</li></ol></blockquote><blockquote><ol start="4"><li>复制和高可用性：支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目的是提供冗余及自动故障转移</li></ol></blockquote><blockquote><ol start="5"><li>自动分片：支持水平的数据库集群，可动态添加额外的机器</li></ol></blockquote><blockquote><p>6.丰富的查询：支持丰富的查询表达方式，查询指令使用JSON形式额标记，可轻易查询文档中的内嵌的对象及数组</p></blockquote><blockquote><ol start="7"><li>快速就地更新：查询优化器会分析查询表达式，并生成一个高效的查询计划</li></ol></blockquote><blockquote><p>8.高效的传统存储方式：支持二进制数据及大型对象</p></blockquote><p><strong>Redis：</strong></p><blockquote><p>它就是一个不折不扣的内存数据库。</p></blockquote><blockquote><p>持久化方式：Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。</p></blockquote><p><strong>Redis特点：</strong></p><blockquote><ol><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li></ol></blockquote><blockquote><ol start="2"><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，在set，hash等数据结构的存储。</li></ol></blockquote><blockquote><ol start="3"><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ol></blockquote><blockquote><ol start="4"><li>性能极高- Redis能读的速度是110000次/s，写的速度是81000次/s</li></ol></blockquote><blockquote><ol start="5"><li>丰富的数据类型-Redis支持二进制案例的Strings,Lists,Hashes,Setes及Ordered Sets数据类型操作。</li></ol></blockquote><blockquote><ol start="6"><li>原子 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ol></blockquote><blockquote><ol start="7"><li>丰富的特性 - Redis还支持publish/subscribe,通知，key过期等等特性。</li></ol></blockquote><p><strong>数据量和性能的比较：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当物理内存够用的时候，Redis &gt; MongoDB &gt; MySQL</span><br><span class="line"></span><br><span class="line">当物理内存不够用的时候，Redis 和 MongoDB 都会使用虚拟内存。</span><br><span class="line"></span><br><span class="line">实际上如果Redis要开始虚拟内存，那很明显要么加内存条，要么你就该换个数据库了。</span><br><span class="line"></span><br><span class="line">但是，MongoDB 不一样，只要，业务上能保证，冷热数据的读写比，使得热数据在物理内存中，mmap 的交换较少。</span><br><span class="line"></span><br><span class="line">MongoDB 还是能够保证性能。有人使用 MongoDB 存储了上T的数据。</span><br><span class="line"></span><br><span class="line">MySQL，MySQL根本就不需要担心数据量跟内存下的关系。不过，内存的量跟热数据的关系会极大地影响性能表现。</span><br><span class="line"></span><br><span class="line">当物理内存和虚拟内存都不够用的时候，估计除了 MySQL 你没什么好选择了。</span><br><span class="line"></span><br><span class="line">其实，从数据存储原理来看，我更倾向于将 MongoDB 归类为硬盘数据库，但是使用了 mmap 作为加速的手段而已。</span><br></pre></td></tr></table></figure><p><strong>使用场景的不同：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、MongoDB适用于：</span><br><span class="line"></span><br><span class="line">①网站数据：适合实时的插入，更新与查询，并具备网站实时数据存储所需对的复制及高度伸缩性；</span><br><span class="line"></span><br><span class="line">②缓存：由于性能很高，也适合作为信息基础设施的缓存层，在系统重启之后，搭建的持久化缓存可以避免下层的数据源过载；</span><br><span class="line"></span><br><span class="line">③大尺寸、低价值的数据也是MongoDB的最佳选择，使用传统的关系数据库存储一些数据时可能会比较贵，再次之前很多程序员往往会选择传统的文件进行存储</span><br><span class="line"></span><br><span class="line">④高伸缩的场景，非常是个由数十或者数百台服务器组成的数据库</span><br><span class="line"></span><br><span class="line">⑤用于对象及json数据的存储，MongoDB的bson数据格式非常适合文档格式化的存储及查询。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2、而mysql还是更加适用于：</span><br><span class="line"></span><br><span class="line">①高度事务性的系统。例如银行或者会计系统，传统的关系型数据库目前还是更实用于需要大量原子性复杂事务的应用程序</span><br><span class="line"></span><br><span class="line">②传统的商业智能应用，针对特定问题的BI数据库会对产生高度优化的查询方式，对于此类应用，数据仓库可能是更合适的选择</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3、Redis应用场景：</span><br><span class="line"></span><br><span class="line">①用来做缓存-redis的所有数据时放在内存中的</span><br><span class="line"></span><br><span class="line">②可以在某些特定应用场景下替代传统数据库--比如社交类的应用</span><br><span class="line"></span><br><span class="line">③在一些大型系统中，巧妙的实现一些特定的功能：session共享、购物车</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql碎片整理优化</title>
    <link href="undefined2019/10/11/2019-10-11-ribao/"/>
    <url>2019/10/11/2019-10-11-ribao/</url>
    
    <content type="html"><![CDATA[<p><strong>MysqL碎片整理优化</strong></p><p>先来说一下什么是碎片，怎么知道碎片有多大！</p><blockquote><p>简单的说,删除数据必然会在数据文件中造成不连续的空白空间,而当插入数据时,这些空白空间则会被利用起来.于是造成了数据的存储位置不连续,以及物理存储顺序与理论上的排序顺序不同,这种是数据碎片.实际上数据碎片分为两种,一种是单行数据碎片,另一种是多行数据碎片.前者的意思就是一行数据,被分成N个片段,存储在N个位置.后者的就是多行数据并未按照逻辑上的顺序排列.当有大量的删除和插入操作时,必然会产生很多未使用的空白空间,这些空间就是多出来的额外空间.索引也是文件数据,所以也会产生索引碎片,理由同上,大概就是顺序紊乱的问题.Engine 不同,OPTIMIZE 的操作也不一样的,MyISAM 因为索引和数据是分开的,所以 OPTIMIZE 可以整理数据文件,并重排索引。这样不但会浪费空间，并且查询速度也更慢。</p></blockquote><blockquote><p>解决方案：（切记，一定要在夜里执行，表越大，越耗资源时间，不要频繁修复，可以几个月甚至一年修复一次，如果表频繁被更改，可以按周/月来整理。）</p></blockquote><p><strong>查看表碎片的方法</strong><br><code>select ROW_FORMAT,TABLE_ROWS,DATA_LENGTH,INDEX_LENGTH,MAX_DATA_LENGTH,DATA_FREE,ENGINE from TABLES where TABLE_SCHEMA=&#39;test_db&#39; and TABLE_NAME=&#39;table_name&#39; limit 1;</code></p><blockquote><p>通过<code>OPTIMIZE TABLE　table_name</code>后再查询一下</p></blockquote><blockquote><p>也可以观察Mysql的数据目录存储文件Data文件大小，如MYD</p></blockquote><p>一、Innodb存储引擎清理碎片方法</p><p><code>ALTER TABLE tablename ENGINE=InnoDB</code></p><p>二、Myisam存储引擎清理碎片方法</p><blockquote><p>OPTIMIZE 操作会暂时锁住表,而且数据量越大,耗费的时间也越长,它毕竟不是简单查询操作.所以把 Optimize 命令放在程序中是不妥当的,不管设置的命中率多低,当访问量增大的时候,整体命中率也会上升,这样肯定会对程序的运行效率造成很大影响.比较好的方式就是做个 Script,定期检查mysql中 information_schema.TABLES字段,查看 DATA_FREE 字段,大于0话,就表示有碎片.脚本多长时间运行一次,可以根据实际情况来定,比如每周跑一次.</p></blockquote><p><code>OPTIMIZE TABLE table_name</code> </p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql简单整理</title>
    <link href="undefined2019/10/10/2019-10-10-ribao/"/>
    <url>2019/10/10/2019-10-10-ribao/</url>
    
    <content type="html"><![CDATA[<ol><li><p>windows键+r启动小黑框，输入 <code>mysql -u用户名 p密码</code>，会出现WELCOME to MYSQL 等字眼</p></li><li><p>我们经常用小黑框查询以及测试数据是否正常：<br> 首先看看有没有数据库，或者创建数据库</p><p>查看数据库: <code>SHOW DATABASES</code>; </p></li></ol><p>2.或者如果没有你想选择的数据库，你可以创建一个数据库</p><p><code>CREATE DATABASE IF NOT EXISTS</code>数据库名;</p><p>记住数据库名后要写分号’;’</p><p>选取创建的数据库 ： USE 数据库名;</p><p>创建数据表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE IF NOT EXISTS 表名(</span><br><span class="line"></span><br><span class="line">    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line"></span><br><span class="line">    name VARCHAR(255) UNIQUE, -- 如果你想让你的字段名的值是唯一值的话就加上UNIQUE，否则就去掉</span><br><span class="line"></span><br><span class="line">   age TINYINT UNSIGNED NOT NULL DEFAULT 1,  -- 默认值请为1， UNSIGNED 字段值不能有符号</span><br><span class="line"></span><br><span class="line">   sex TINYINNT UNSIGNED NOT NULL </span><br><span class="line"></span><br><span class="line">)ENGINE = InnoDB DEFAULT CHARSET = UTF8;</span><br></pre></td></tr></table></figure><p>增加数据:<code>INSERT INTO 表名(id,字段2，字段N。。) VALUES(NULL,&#39;张三&#39;,12,1);</code></p><p>查询数据: <code>SELECT id,nam,age,sex FROM 表名; ||  SELECT id,name,age,sex FROM WHERE id=N；</code></p><p>修改数据: <code>UPDATE 表名 SET 修改的字段名 WHERE  id=N；</code></p><p>删除数据：</p><p><strong>删除数据之前先添加一条数据免得表是空的</strong></p><p>  <code>INSERT INTO 表名(id,字段2，字段N。。) VALUES(NULL,&#39;张三&#39;,12,1);</code></p><p>ok,简单的增删改查就ok了</p>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="undefined2019/10/09/2019-10-9-ribao/"/>
    <url>2019/10/09/2019-10-9-ribao/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB操作命令"><a href="#MongoDB操作命令" class="headerlink" title="MongoDB操作命令"></a>MongoDB操作命令</h1><h2 id="Mongo简介"><a href="#Mongo简介" class="headerlink" title="Mongo简介"></a>Mongo简介</h2><p>属于非关系型数据库，是分布式文档数据库。<br>特点：扩展灵活、结构灵活、使用方便、支持查询、索引。<br>不足：缺乏事务控制，无法保障数据完整性。</p><p>oracle存储结构</p><p><img src="https://i.imgur.com/iGIiT2H.png" srcset="undefined" alt></p><p>mongodb存储结构</p><p><img src="https://i.imgur.com/03lOJQN.png" srcset="undefined" alt></p><h2 id="Mongo命令"><a href="#Mongo命令" class="headerlink" title="Mongo命令"></a>Mongo命令</h2><ol><li><p>库命令</p><ul><li><p>查看</p><pre><code>show dbs</code></pre></li><li><p>使用</p><pre><code>use 库名称</code></pre></li><li><p>创建</p><pre><code>use 库名称  //库存在就是使用；不存在就创建再使用</code></pre></li><li><p>删除</p><pre><code>db.dropDatabase() //删除当前use的库</code></pre></li></ul></li><li><p>集合</p><ul><li><p>查看</p><pre><code>show collections</code></pre></li><li><p>创建</p><pre><code>当使用&quot;db.集合名.insert()&quot;插入数据时，集合不存在时会自动创建</code></pre></li><li><p>删除</p><pre><code>db.集合名.drop()</code></pre></li></ul></li><li><p>数据操作</p><ul><li><p>插入</p><p>  插入单条记录</p><pre><code>db.dept.insert({&quot;no&quot;:1,&quot;dname&quot;:&quot;beijing&quot;})</code></pre><p>  插入多条记录</p><pre><code>var objs = [{&quot;no&quot;:3,&quot;dname&quot;:&quot;chengdu&quot;},{&quot;no&quot;:4,&quot;dname&quot;:&quot;shenyang&quot;}];db.dept.insert(objs)</code></pre><p>  或</p><pre><code>for(var i=1;i&lt;10;i++){ db.dept.insert({&quot;no&quot;:10+i,&quot;dname&quot;:&quot;bj&quot;+i});}</code></pre></li><li><p>删除</p><p>  删除单条记录</p><pre><code>db.dept.remove({&quot;no&quot;:1})</code></pre><p>  删除所有记录</p><pre><code>db.dept.remove({})</code></pre></li><li><p>修改</p><p>  全部更新覆盖</p><pre><code>db.dept.update({&quot;no&quot;:1},{&quot;dname&quot;:&quot;shanghai&quot;})</code></pre><p>  部分更新</p><pre><code>db.dept.update(条件json对象,{$set:要更新的json对象})//示例db.dept.update({&quot;no&quot;:1},{$set:{&quot;dname&quot;:&quot;chengdu&quot;}})</code></pre></li><li><p>查询</p><p>  $gt、$lt、$gte、$lte、$ne等</p><p>  查询所有记录</p><pre><code>db.dept.find()</code></pre><p>  查询某条记录，no=1的记录</p><pre><code>db.dept.find({&quot;no&quot;:1})</code></pre><p>  查询条件记录，no&gt;1的记录</p><pre><code>db.dept.find({&quot;no&quot;:{$gt:1}})db.dept.find({&quot;no&quot;:{$gte:1}})</code></pre><p>  排序</p><pre><code>db.dept.find().sort({&quot;no&quot;:1})</code></pre><p>  1表示升序、-1表示降序</p><p>  分页</p><pre><code>//跳过begin条，然后抓取记录db.dept.find().skip(begin).limit(记录数)</code></pre></li><li><p>统计</p><p>  统计所有记录数量</p><pre><code>db.dept.count()</code></pre><p>  统计满足条件记录数</p><pre><code>db.dept.count({&quot;no&quot;:11})db.dept.count({&quot;no&quot;:{$gt:10}})</code></pre></li></ul></li></ol><h1 id="Java访问MongoDB"><a href="#Java访问MongoDB" class="headerlink" title="Java访问MongoDB"></a>Java访问MongoDB</h1><pre><code>驱动包：mongo-java-driver-2.13.2.jar</code></pre><ol><li><p>原生方式</p><ul><li><p>引入mongo-java-driver-2.13.2.jar驱动包</p></li><li><p>建立连接</p><pre><code>MongoClient mongo = new MongoClient(&quot;localhost&quot;);//操作mongo.close();关闭连接</code></pre></li><li><p>获取库和集合信息</p><pre><code>MongoClient mongo = new MongoClient(&quot;localhost&quot;);List&lt;String&gt; dbs = mongo.getDatabaseNames();//show dbs 查看所有库名DB db = mongo.getDB(&quot;java11&quot;);//use java11 获取库对象//db.getCollectionNames();//show collections 查看集合名</code></pre></li><li><p>插入记录</p><pre><code>MongoClient mongo = new MongoClient(&quot;localhost&quot;);DB db = mongo.getDB(&quot;java11&quot;);DBCollection dept = db.getCollection(&quot;dept&quot;);DBObject arr = new BasicDBObject();arr.put(&quot;no&quot;, 10);arr.put(&quot;dname&quot;, &quot;beijing1&quot;);dept.insert(arr);//db.dept.insert({&quot;no&quot;:10,&quot;dname&quot;:&quot;beijing1&quot;})mongo.close();</code></pre></li><li><p>更新记录</p><pre><code>MongoClient mongo = new MongoClient(&quot;localhost&quot;);DB db = mongo.getDB(&quot;java11&quot;);DBCollection dept = db.getCollection(&quot;dept&quot;);DBObject q = new BasicDBObject();q.put(&quot;no&quot;, 10);DBObject o = new BasicDBObject();DBObject n = new BasicDBObject();n.put(&quot;dname&quot;, &quot;北京&quot;);o.put(&quot;$set&quot;, n);//db.dept.update({&quot;no&quot;:10},{$set:{&quot;dname&quot;:&quot;北京&quot;}})dept.update(q, o);mongo.close();</code></pre></li><li><p>查询记录</p><pre><code>MongoClient mongo = new MongoClient(&quot;localhost&quot;);DB db = mongo.getDB(&quot;java11&quot;);//use java11 获取库对象DBCollection dept = db.getCollection(&quot;dept&quot;);//获取dept集合对象DBCursor cursor = dept.find();//db.dept.find() 查询所有记录while(cursor.hasNext()){    DBObject obj = cursor.next();    Object no = obj.get(&quot;no&quot;);    Object dname = obj.get(&quot;dname&quot;);    System.out.println(&quot;no=&quot;+no+&quot; dname=&quot;+dname);}mongo.close();</code></pre></li></ul></li><li><p>spring-data-mongodb方式（Spring框架）</p><p> 利用MongoTemplate对象进行MongoDB操作。</p></li></ol><pre><code>- 导入下列jar包，注意版本匹配，容易产生冲突。    - mongo-java-driver-2.13.2.jar    - spring-data-mongodb-1.4.2.RELEASE.jar    - spring-data-commons-1.7.2.RELEASE.jar    - slf4j-api-1.5.8.jar    - slf4j-log4j12-1.5.8.jar    - log4j-1.2.12.jar- 追加Spring配置，创建MongoTemplate对象        &lt;!-- 追加mongo命名空间，定义Factory --&gt;        &lt;mongo:db-factory id=&quot;mongoFactory&quot;             host=&quot;localhost&quot; port=&quot;27017&quot; dbname=&quot;java11&quot;/&gt;        &lt;!-- 创建MongoTemplate --&gt;        &lt;bean id=&quot;mongoTemplate&quot;             class=&quot;org.springframework.data.mongodb.core.MongoTemplate&quot;&gt;            &lt;constructor-arg index=&quot;0&quot; ref=&quot;mongoFactory&quot;&gt;            &lt;/constructor-arg&gt;        &lt;/bean&gt;- 测试Template应用        @RunWith(SpringJUnit4ClassRunner.class)        @ContextConfiguration(locations={&quot;classpath:spring-mongo.xml&quot;})        public class TestMongoTemplate {            @Resource            private MongoTemplate mongoTemplate;            @Test//测试添加            public void test1(){                System.out.println(mongoTemplate);                User user = new User();                user.setId(20);                user.setName(&quot;tiger&quot;);                user.setPassword(&quot;123456&quot;);                mongoTemplate.save(user);//默认集合名user            }            @Test//测试查询所有记录            public void test2(){                List&lt;User&gt; list = mongoTemplate.findAll(User.class);//默认查user集合                for(User user:list){                    System.out.println(user.getId()+&quot; &quot;+user.getName()+&quot; &quot;+user.getPassword());                }            }            @Test//测试按条件查询记录            public void test3(){                Query query = new Query(Criteria.where(&quot;id&quot;).is(10));                User user = mongoTemplate.findOne(                    query,User.class);                System.out.println(user.getId()+&quot; &quot;+user.getName()+&quot; &quot;+user.getPassword());            }        }</code></pre>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="undefined2019/10/08/2019-10-8-ribao/"/>
    <url>2019/10/08/2019-10-8-ribao/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p> 目的：利用Redis做数据缓存,缓存查询出来的对象数据。</p><p> NoSQL：Not Only SQL，非关系数据库。</p><p> 关系型数据库指的是表结构存储，典型Oracle、MySQL、DB2。</p><ul><li>key-value存储 : 典型Redis</li><li>列存储 ： HBase</li><li>文档存储 : MongoDB</li><li>图形存户：Neo4j</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Redis是基于内存的数据库，常用于缓存</li><li>Redis是采用C语言编写</li><li>Redis是采用Key-value结构存储</li><li>Redis中value值支持存储类型为字符串、哈希、列表、集合、可排序集合</li><li>Redis支持高速读写操作，效率高</li><li>Redis支持持久化、按一定策略将内存数据异步保存到磁盘</li><li>Redis支持事务控制、消息传递等功能</li></ul><h2 id="各种类型数据存储命令"><a href="#各种类型数据存储命令" class="headerlink" title="各种类型数据存储命令"></a>各种类型数据存储命令</h2><ol><li><p>字符串操作（string）</p><p> <img src="https://i.imgur.com/9sJtYCB.png" srcset="undefined" alt></p><ul><li>set key value  //存一组key value</li><li>mset key value key value //存多组key value</li><li>get key //获取value</li><li>strlen key //获取value字符长度</li><li>incr key //将value加1</li><li>incrby key number //将value加number</li><li>decr key //将value减1</li><li>decrby key number //将value减number</li><li>append key value1 //将value拼接value1</li></ul></li><li><p>key操作</p><ul><li>keys *  //查看有哪些key</li><li>del key //删除key</li><li>expire key n  //设置key有效期为n秒</li><li>rename key newkey //修改key名字</li><li>type key //返回value值得类型</li><li>exists key //判断key是否存在</li></ul></li></ol><ol start="3"><li><p>哈希操作 (hashmap)</p><p> <img src="https://i.imgur.com/3ROwSOy.png" srcset="undefined" alt></p><ul><li>hset key 字段名 字段值  //设置一个字段名和字段值</li><li>hmset key 字段名1 字段值1 字段名2 字段值2 //设置多个</li><li>hget key 字段名 //获取一个字段值</li><li>hmget key 字段名1 字段名2 //获取多个字段值</li><li>hlen key  //获取字段数量</li><li>hkeys key //获取字段名</li><li>hdel key 字段名 //删除某个字段</li></ul></li></ol><ol start="4"><li><p>列表操作 (list)</p><p> <img src="https://i.imgur.com/ZGLumMQ.png" srcset="undefined" alt></p><ul><li>lpush key value //在列表头部插入一个元素</li><li>rpush key value //在列表尾部插入一个元素</li><li>lrange key 0 -1 //获取列表所有元素</li><li>llen key //获取列表元素数量</li><li>lrem key count value //删除列表指定数量的元素</li><li>lset key index value //更新某个索引位置的元素</li><li>lindex key index //获取指定索引位置的元素</li><li>lpop key //删除列表头部第一个元素</li><li>rpop key //删除列表尾部最后一个元素</li><li>linsert key BEFROE|AFTER value newvalue //在列表value元素前或后插入newvalue值</li></ul></li><li><p>集合操作 (set)</p><p> A = {1,3,5}</p><p> B = {3,5,7,9}</p><p> A交B = {3,5}</p><p> A并B = {1,3,5,7,9}</p><p> A差B = {1}</p><p> B差A = {7,9}</p><ul><li>sadd key value value //向集合存数据</li><li>smembers key //获取集合所有元素</li><li>scard key //获取集合元素数量</li><li>srem key value //删除value元素</li><li>spop key //随机删除一个元素</li><li>srandmember key n //随机返回n个元素</li><li>sdiff key1 key2 //key1和key2集合的差集</li><li>sinter key1 key2 //key1和key2集合交集</li><li>sunion key1 key2 //key1和key2集合并集</li><li>sdiffstore key key1 key2 //key1和key2集合的差集,结果存放到key集合中   </li></ul></li></ol><ol start="6"><li><p>有序集合操作</p><p> 排序规则：给每个元素配一个double分值，按分值排序，默认由小到大排序。</p><ul><li>zadd key score value score value //添加元素</li><li>zcard key //获取元素数量</li><li>zrange key 0 n //获取指定索引范围的元素,0 -1表示所有元素(由小到大排序)。</li><li>zrevrange key 0 n//根据score由大到小排序,获取指定索引的元素</li><li>zrem key value //删除某个元素</li><li>zscore key value //返回元素的分值</li><li>zrank key value //获取元素索引位置(由小到大排序)</li><li>zrevrank key value //获取元素索引位置（由大到小排序）</li><li>zcount key min max //统计分值在min和max之间的元素数量</li></ul></li></ol><ol start="7"><li>其他</li></ol><h2 id="Java如何操作Redis存取数据"><a href="#Java如何操作Redis存取数据" class="headerlink" title="Java如何操作Redis存取数据"></a>Java如何操作Redis存取数据</h2><p>连接Redis</p><pre><code>@Test//测试连接public void test1(){    Jedis jedis = new Jedis(&quot;localhost&quot;);    System.out.println(jedis.ping());}</code></pre><p>字符串写操作</p><pre><code>public void test2_1(){    long i = 10000L;    Jedis jedis = new Jedis(&quot;localhost&quot;);    jedis.set(&quot;i&quot;, i+&quot;&quot;);    jedis.set(&quot;msg1&quot;, &quot;Hello Redis&quot;);    jedis.set(&quot;msg2&quot;.getBytes(), &quot;你好 Redis&quot;.getBytes());    jedis.close();}</code></pre><p>字符串读操作</p><pre><code>public void test2_2(){    Jedis jedis = new Jedis(&quot;localhost&quot;);    String str = jedis.get(&quot;msg1&quot;);    byte[] bts = jedis.get(&quot;msg2&quot;.getBytes());    long i = Long.parseLong(jedis.get(&quot;i&quot;));    String str2 = new String(bts);    System.out.println(str);    System.out.println(str2);    jedis.close();}</code></pre><p><strong>其他类型存取操作请参考课上示例代码</strong></p><h2 id="Java如何利用Redis做缓存"><a href="#Java如何利用Redis做缓存" class="headerlink" title="Java如何利用Redis做缓存"></a>Java如何利用Redis做缓存</h2><ol><li><p>对象存取方案</p><ul><li>将Java对象转成json字符串然后写入redis，取值时将json串转成Java对象</li></ul></li></ol><pre><code>        @Test//写对象        public void test1(){            User user = new User();            user.setId(10);            user.setName(&quot;scott&quot;);            user.setPassword(&quot;123&quot;);            //写对象            Jedis jedis = new Jedis(&quot;localhost&quot;);            Gson gson = new Gson();            String s = gson.toJson(user);            jedis.set(&quot;user_&quot;+user.getId(), s);            jedis.close();        }        @Test//读对象        public void test2(){            int id = 10;            Jedis jedis = new Jedis(&quot;localhost&quot;);            String s = jedis.get(&quot;user_&quot;+id);            Gson gson = new Gson();            User user = gson.fromJson(s, User.class);            System.out.println(user.getId()+&quot; &quot;+user.getName());            jedis.close();        }- 将Java对象序列化成字节数组然后写入redis，取值时反序列化成Java对象        @Test//写对象        public void test3(){            User user = new User();            user.setId(10);            user.setName(&quot;scott&quot;);            user.setPassword(&quot;123&quot;);            //写对象            Jedis jedis = new Jedis(&quot;localhost&quot;);            //序列化            byte[] value = SerializableUtil.serialize(user);            jedis.set(&quot;user_10&quot;.getBytes(), value);            jedis.close();        }        @Test//读对象        public void test4(){            int id = 10;            String key = &quot;user_&quot;+id;            Jedis jedis = new Jedis(&quot;localhost&quot;);            byte[] value = jedis.get(key.getBytes());            //反序列化            User user = (User)SerializableUtil.unserialize(value);            System.out.println(user.getId()+&quot; &quot;+user.getName()+&quot; &quot;+user.getPassword());            jedis.close();        }</code></pre>]]></content>
    
    
    <categories>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28日日报</title>
    <link href="undefined2019/09/28/2019-9-28-ribao-md/"/>
    <url>2019/09/28/2019-9-28-ribao-md/</url>
    
    <content type="html"><![CDATA[<p>今天搞了一天的博客和git，我的电脑出了问题，怎么也连不上git</p><p>于是我想到了用hexo部署至git，还可以加一个可爱的看板娘</p><p>说干就干，我尝试百度了好多，终于安装好了hexo及其需要的环境</p><p>博客是搭好了，可是出了乱码，原因是我的.md文件编码不是utf-8，于是乎我 关闭虚拟机，在win10上进行操作,最终干掉了疑难</p><p>OK!</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建国70周年观后感</title>
    <link href="undefined2019/09/27/2019-9-27-xinde/"/>
    <url>2019/09/27/2019-9-27-xinde/</url>
    
    <content type="html"><![CDATA[<p>在这个蓝色的、富有生命的星球中，在世界这片广阔的地域里，有一只雄鸡它巍然屹立在亚洲的海陆之中，它——就是中国!</p><p>中国历史古老而又文明，中国文化更是源远流长,是信念，也是希望</p><p>我很高兴我是中国人，我的祖先被万代国人传诵。中国人民坚强刚毅，无论在任何困难面前都不会退缩，他们会坚持下去，克服眼前的所有困难</p><p>我们是跨世纪的一代新人，我们的今天就是祖国的明天，我们肩负着振兴国家，是国家更加繁荣富强的重任，所以我们更要努力的学习，学习真知识，掌握真本领，我们心中，伟大的祖国时时刻刻在激励着我们，给我们以勇气，给我们以力量</p><p>望着祖国日新月异、日渐富强的景象，我骄傲，因为我有一颗中国心;望着国外那一台台印着“中国制造”字样的电视、电脑，我骄傲，因为我有一颗中国心;</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库(4)</title>
    <link href="undefined2019/09/26/2019-9-26-datebasekey/"/>
    <url>2019/09/26/2019-9-26-datebasekey/</url>
    
    <content type="html"><![CDATA[<p>约束   constraint </p><p>   概念 </p><p>  当数据进入 数据库表中时,数据库管理系统 可以通过加在字段上 约束 限制来对数据进行<br>    检查 符合检查条件的数据才能进入数据库的表。</p><p>  约束的种类 </p><p>   主键约束       primary  key      pk<br>       如果对一个字段加了主键约束 则 这个字段的取值 必须不能为空 并且 值 不能<br>        重复。一张表只能有一个主键。<br>    唯一性约束    unique           uk<br>        如果对一个字段加了唯一性约束 则这个字段的值 不能重复<br>    非空约束       not  null        nn<br>        字段的值不能为空<br>     检查约束     check             ck<br>         字段的值必须符合检查条件<br>     外键约束     foreign  key      fk<br>            references   </p><p>  约束的实现方式 </p><p>   列级约束实现 : 在定义表的某一列时 直接在这一列后面加约束限制  </p><p>   表级约束实现: 在定义完表的所有列之后  再选择某些列加约束限制。</p><p>   主键的列级约束实现</p><p>   create  table  column_cons(<br>       id    number   primary key,<br>       name  varchar2(30),<br>       salary  number<br>   );<br>   insert into  column_cons values(1,’t1’,12312);<br>   ERROR at line 1:<br>   ORA-00001: unique constraint (SYSTEM.SYS_C007123) violated<br>   SYSTEM.SYS_C007123  这代表约束的名字  系统默认提供一个不重复的<br>   约束名  但不方便记忆 和 对数据的维护。</p><p>   建立约束时 给约束起名字 </p><p>   名字构成 是  表名_字段名_约束简称<br>   drop    table  column_cons;<br>   create  table  column_cons(<br>       id    number  constraint  column_cons_id_pk primary key,<br>       name  varchar2(30),<br>       salary  number<br>   );<br>   insert into  column_cons values(1,’t1’,12312);<br>   ERROR at line 1:<br>ORA-00001: unique constraint (SYSTEM.COLUMN_CONS_ID_PK) violated<br>```</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库(3)</title>
    <link href="undefined2019/09/25/2019-9-25-data/"/>
    <url>2019/09/25/2019-9-25-data/</url>
    
    <content type="html"><![CDATA[<p>** 日期类型 **</p><h5 id="1-日期类型的默认表现"><a href="#1-日期类型的默认表现" class="headerlink" title="1.日期类型的默认表现"></a>1.日期类型的默认表现</h5><pre><code>&gt; dd-MON-yy      select  id,start_date from  s_emp;</code></pre> <p>按照入职日期排序 显示  id  first_name start_date</p>    > select  id,first_name,start_date from s_emp order by start_date;<h5 id="2-使用-to-char-来改变显示的格式"><a href="#2-使用-to-char-来改变显示的格式" class="headerlink" title="2.使用 to_char 来改变显示的格式"></a>2.使用 to_char 来改变显示的格式</h5><pre><code>&lt;p&gt;新的日期格式:&lt;/p&gt;</code></pre><p>    yyyy     四位年</p><p>    mm       两位月</p><p>    dd       天</p><p>    hh       12小时制 </p><p>    hh24     24小时制</p> <p>    mi       分钟 </p><p>    ss       秒 </p> <p>    day      星期几 </p><p>    MON      英文月的缩写</p> <p>    month    英文月的全写 </p><p>    pm       上午 显示成 am  下午显示成pm</p><blockquote><p>select  id,first_name,to_char(start_date,’yyyy-mm-dd hh24:mi:ss MON pm’)<br>       from s_emp order by start_date;</p></blockquote><blockquote><p>select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss day pm’) from dual; </p></blockquote><h5 id="3-日期数据的插入"><a href="#3-日期数据的插入" class="headerlink" title="3. 日期数据的插入"></a>3. 日期数据的插入</h5><blockquote><p>sysdate   可以代表 当前的时间点 </p></blockquote>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   过去和 未来的时间 如何处理? </span><br><span class="line">   2008-08-08 20:08:10 </span><br><span class="line">   2090-08-08 08:10:25</span><br><span class="line">   dd-MON-yy  只能放入 年月日 时分秒 默认是 零 </span><br><span class="line">   ``` </span><br><span class="line">   &gt; to_date(par1,par2)  par1 是要处理的日期字符串  par2 是日期格式字符串 </span><br><span class="line">      能把日期字符串 根据日期格式转换成 日期数据 </span><br><span class="line"> </span><br><span class="line">``` </span><br><span class="line">   insert  into  myemp values(5,&apos;test&apos;,&apos;test&apos;,&apos;08-AUG-08&apos;);</span><br><span class="line">   commit;</span><br><span class="line">   select  id,to_char(sdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) from myemp;</span><br><span class="line">   insert  into  myemp values(6,&apos;test&apos;,&apos;test&apos;,</span><br><span class="line">      to_date(&apos;2008-08-08 20:08:10&apos;,&apos;yyyy-mm-dd hh24:mi:ss&apos;));</span><br><span class="line">   commit;</span><br><span class="line">   insert  into  myemp values(7,&apos;test&apos;,&apos;test&apos;,</span><br><span class="line">      to_date(&apos;2090-08-08 08:10:25&apos;,&apos;yyyy-mm-dd hh24:mi:ss&apos;));</span><br><span class="line">   commit;</span><br><span class="line">```   </span><br><span class="line">##### 4. 日期调整 </span><br><span class="line">     &gt; 先调整  秒  分钟  小时  天   默认以天为单位</span><br></pre></td></tr></table></figure><p>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(sysdate+1,’yyyy-mm-dd hh24:mi:ss’) from dual;<br>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(sysdate-2,’yyyy-mm-dd hh24:mi:ss’) from dual;<br>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(sysdate+10/(24*60),’yyyy-mm-dd hh24:mi:ss’) from dual;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; add_months(par1,par2)  par1 要处理的日期   par2 几个月 正数负数都可以</span><br></pre></td></tr></table></figure><p>   select  to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’),<br>    to_char(add_months(sysdate,2),’yyyy-mm-dd hh24:mi:ss’) from dual;    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; trunc(par1,par2) par1 是要处理的日期   par2处理的精度  默认是天 </span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">select  to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;),</span><br><span class="line"> to_char(trunc(sysdate),&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual;     </span><br><span class="line">select  to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;),</span><br><span class="line"> to_char(trunc(sysdate,&apos;mm&apos;),&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual; </span><br><span class="line">select  to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;),</span><br><span class="line"> to_char(trunc(add_months(sysdate,-1),&apos;mm&apos;),&apos;yyyy-mm-dd hh24:mi:ss&apos;)</span><br><span class="line"> from dual;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库(2)</title>
    <link href="undefined2019/09/24/2019-9-24-study_select/"/>
    <url>2019/09/24/2019-9-24-study_select/</url>
    
    <content type="html"><![CDATA[<p> 表连接</p><pre><code>内连接         等值连接     员工和部门       部门和地区                非等值连接   员工的工资 和 对应的工资级别        自连接          谁是领导? 外连接        等值连接     员工和部门 (找出没有部门的员工)      部门和地区 (没有地区编号的部门)                非等值连接   员工的工资 和 对应的工资级别  (超出统计范围的工资)        自连接          谁是普通员工?  外连接的结果集 等于 内连接的结果集  加上匹配不上的记录         如何实现的?  (+)   (+)的意思所在字段的对面的表的数据全部被匹配出来         本质上 底层是通过 NULL 记录进行的匹配</code></pre><p>   SQL99 内外连接</p><pre><code>内连接标准  from  a表  join b表  on 连接条件  where 过滤条件; from  a表  inner join b表  on 连接条件  where 过滤条件;       显示 每个部门的名字 和 对应的地区的名字    select  d.name,r.name      from  s_dept d,s_region r          where  d.region_id = r.id; select  d.name,r.name      from  s_dept d  join s_region r          on  d.region_id = r.id; select  d.name,r.name      from  s_dept d  inner  join s_region r          on  d.region_id = r.id; 外连接的标准 a表  left outer  join  b 表  on 表的连接条件   where  过滤条件; a表  right outer  join  b 表  on 表的连接条件   where  过滤条件; a表  full  outer  join  b 表  on 表的连接条件  where  过滤条件;  a表  left outer  join  b 表  就是a表发起连接  意思就是a表的数据全部被匹配出来。 a表  right outer  join b 表  就是b表发起连接  意思就是 b表的数据全部被匹配出来。       本质上也通过 NULL 记录进行的匹配       显示每个部门的名字  和 对应的地区的名字  没有地区编号的部门也要显示    select d.id, d.name,r.name      from  s_dept  d,s_region r           where  d.region_id = r.id(+);      select d.id, d.name,r.name      from  s_dept  d left outer  join s_region r           on  d.region_id = r.id;   select d.id, d.name,r.name      from  s_region r  right outer  join  s_dept  d          on  d.region_id = r.id;                 使用左外连接  实现 s_emp 谁是普通员工的问题 显示  id  first_name            谁是领导?40   谁是普通员工 40   改成 left outer  join  20    select distinct m.id,m.first_name        from  s_emp  e,s_emp m             where  e.manager_id(+) = m.id and e.manager_id is null;           select distinct m.id,m.first_name        from  s_emp  m  left outer join s_emp e             on  e.manager_id = m.id where e.manager_id is null;  select distinct m.id,m.first_name        from  s_emp  m  left  join s_emp e             on  e.manager_id = m.id where e.manager_id is null;  full outer join          全外连接 只是一个逻辑概念，代表左外连接的结果集 加上 右外连接的结果集 然后 排除重复的记录。  Oracle 中如何实现全外连接呢? 不是通过两端都加(+) 实现的。         而是通过  union    来实现的 union 的意思是 合并两个结果集  然后排重。  union  all  合并两个结果集  不排重。  select  id from  s_emp  union    select id from s_emp;  select  id from  s_emp  union  all   select id from s_emp;    </code></pre>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库(1)</title>
    <link href="undefined2019/09/23/2019-9-23-stuey-select/"/>
    <url>2019/09/23/2019-9-23-stuey-select/</url>
    
    <content type="html"><![CDATA[<p>** 内连接 **<br>      </p><p>内连接的特点就是 符合连接条件的数据 被选中  不符合连接条件的数据被过滤掉。</p><br>      <p>上面的  等值连接    非等值连接   自连接 都是内连接。</p><br>** 外连接 **<br>   <p>外连接的结果集 等于 内连接的结果集  加上 匹配不上的记录(一个也不能少)</p>  <p></p> <p> (+)  (+) 所在的表的字段 对面的表的数据全部被匹配出来               底层通过 NULL 记录匹配出来的  </p>  >select distinct m.id,m.first_name from  s_emp  e,s_emp m  where e.manager_id(+) = m.id and  e.manager_id is null;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">练习   s_emp   s_dept </span><br><span class="line">     显示每个员工的id, first_name  和 对应的 部门名(name)</span><br><span class="line">    select  e.id,first_name,name</span><br><span class="line">        from  s_emp e,s_dept d</span><br><span class="line">            where  e.dept_id=d.id; </span><br><span class="line">     公司为了业务发展 需要抽调一部分人出来  这些人将离开原来的部门 </span><br><span class="line">  update  s_emp  set dept_id = null where id &lt; 3;</span><br><span class="line">  commit; </span><br><span class="line">     显示每个员工的id, first_name  和 对应的 部门名(name)  没有部门编号的员工也要显示 </span><br><span class="line">  select  e.id,first_name,name</span><br><span class="line">        from  s_emp e,s_dept d</span><br><span class="line">            where  e.dept_id=d.id(+);   </span><br><span class="line"></span><br><span class="line">练习   s_dept     s_region</span><br><span class="line">   显示每个部门的名字  和 对应的地区的名字</span><br><span class="line"> select d.id, d.name,r.name</span><br><span class="line">      from  s_dept  d,s_region r </span><br><span class="line">          where  d.region_id = r.id;</span><br><span class="line"> 公司业务扩大了  增加了一些新的部门 </span><br><span class="line"> insert  into  s_dept  values(100,&apos;test100&apos;,NULL);</span><br><span class="line"> insert  into  s_dept  values(101,&apos;test101&apos;,NULL);</span><br><span class="line"> commit;                      </span><br><span class="line"> 显示每个部门的名字  和 对应的地区的名字  没有地区编号的部门也要显示  </span><br><span class="line">  select d.id, d.name,r.name</span><br><span class="line">      from  s_dept  d,s_region r </span><br><span class="line">          where  d.region_id = r.id(+);          </span><br><span class="line">  非等值连接的外连接    salgrade   s_emp </span><br><span class="line">   列出每个员工的 id  salary  和  salary 对应的工资级别</span><br><span class="line"> select id,salary,grade</span><br><span class="line">      from  s_emp,salgrade </span><br><span class="line">          where salary  between  losal and hisal;</span><br><span class="line"> 把 id = 25  和 id=24 的这两个人的工资 改成 12345</span><br><span class="line"> update  s_emp  set  salary=12345 where id &gt;= 24;</span><br><span class="line"> commit;</span><br><span class="line"> 列出每个员工的 id  salary  和  salary 对应的工资级别  超出统计范围的员工也要显示 </span><br><span class="line"> select id,salary,grade</span><br><span class="line">      from  s_emp,salgrade </span><br><span class="line">          where salary  between  losal(+) and hisal(+);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22日日报</title>
    <link href="undefined2019/09/22/2019-9-22-windows/"/>
    <url>2019/09/22/2019-9-22-windows/</url>
    
    <content type="html"><![CDATA[<p><strong>终于我还是败给了deepin</strong></p><p>今天又安回了win10系统,因为我Linux下安装数据库安装了好长时间</p><p>于是我自闭了，安回了win10。看见熟悉的画面，emmm.... 还是windows看着舒服</p><p>今天安装各种软件安装了好长时间,所以学习时间就少了好多</p><p>但是这并不是我不努力的理由,所以只有更努力的学习了嘛</p><p>you can</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="undefined2019/09/20/2019-9-20-jvm/"/>
    <url>2019/09/20/2019-9-20-jvm/</url>
    
    <content type="html"><![CDATA[<p><strong>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</strong></p><p>Java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。   Java虚拟机本质是就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。</p>   <p>Java虚拟机不仅是一种跨平台的语言，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种API、优化技术等。Java技术使同一种应用可以运行在不同的平台上。Java平台可分为两部分，即Java虚拟机（Java virtual machine，JVM）和Java API类库。</p>   <p>Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块   Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据，这样做的目的就是为了保持Java虚拟机的指令集尽量的紧凑，同时也便于JAVA虚拟机在那些只有很少通用寄存器的平台上实现</p>   <p>   对于Java运行时涉及到的存储区域主要包括程序计数器、Java虚拟机栈、本地方法栈、java堆、方法区以及直接内存等等．   程序计数器主要是取下一条指令，在Java里面主要是取下一条指令的字节码文件；Java虚拟机栈主要是利用栈先进后出的特性存储局部变量表，动态链接等，主要包括堆内存和栈内存，对于程序员内存分析而言是特别重要的。本地方法栈与上边的栈基本作用差不多，只不过这里是为Java方法而服务。Java堆是内存管理中最大的一块，所有的线程共享这一块内容，同时该部分也是垃圾收集器的主要区域   </p>   <p>   虚拟机的垃圾回收机制是完善的，动态内存分配和回收是比较成熟的，一般的对于内存回收首先就是判断某一个部分是生存还是死亡，主要是通过下面二种算法：                                  <br>其一是引用计数算法:该算法实现简单，判定的效率也比较高，但是它难以处理对象之间相互调用的问题   <br>其二是称可达性分析算法，该算法核心思想是依靠判断对象是否存活来实现的，本算法是通过一系列的GC ROOTS的对象作为起始点，采用搜索的算法遍历引用链，如果搜索过程中没有发现该节点，则认为该节点是不可达的，即可回收的   </p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>兄弟会感悟</title>
    <link href="undefined2019/09/19/2019-9-19-ganwu/"/>
    <url>2019/09/19/2019-9-19-ganwu/</url>
    
    <content type="html"><![CDATA[<p>时间如白马过隙，悄然而逝，但是自从我来到兄弟会，不仅学到了好多东西，而且认识了这么多可以帮得到我的兄弟萌，有辛苦，有欢乐</p><p>当然，我们兄弟会成立之初，我们也有过迷茫，我们也想过兄弟会是否能给我们以进步(emmm...),但是小明告诉我，我们其实学到了很多，比如自己的学习能力，解决问题的能力，知识覆盖面，尤其是我们很少主动问别人问题了(当然不能不会还憋着不问)</p><p>到现在，教练们的辛苦负责，组长们的热情多助，学员们的心得分享，已让我的生活变得充实，每天都有自己能学到的东西。迷茫，彷徨自然就随风而散了。每天的充实生活已让我陶醉，每天的学习也让我进步</p><p>所以呀，考虑一千次，不如去做一次；犹豫一万次，不如实践一次；华丽的跌倒，胜过无谓的彷徨，将来的你，一定会感谢现在奋斗的你</p><p>小明说:所有成功的背后，都是苦苦堆积的坚持；所有人前的风光，都是背后傻傻的不放弃，那么我们也要紧追他的步伐</p><p>so,加油啊少年</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动vue时报错</title>
    <link href="undefined2019/09/17/2019-9-17-dsb.md/"/>
    <url>2019/09/17/2019-9-17-dsb.md/</url>
    
    <content type="html"><![CDATA[<p>✘ 1 problem (1 error, 0 warnings)</p><p>Errors:<br>  1  <a href="http://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener">http://eslint.org/docs/rules/no-trailing-spaces</a></p><p>  ✘  <a href="http://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener">http://eslint.org/docs/rules/no-trailing-spaces</a>  Trailing spaces not allowed<br>  src/components/HelloWorld.vue:6:1</p><p>   ^</p><p>  ✘  <a href="http://eslint.org/docs/rules/eol-last" target="_blank" rel="noopener">http://eslint.org/docs/rules/eol-last</a>            Newline required at end of file but not found<br>  src/components/HelloWorld.vue:16:10<br>  </p><p>✘ 2 problems (2 errors, 0 warnings)</p><p>Errors:<br>  1  <a href="http://eslint.org/docs/rules/eol-last" target="_blank" rel="noopener">http://eslint.org/docs/rules/eol-last</a><br>  1  <a href="http://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener">http://eslint.org/docs/rules/no-trailing-spaces</a></p><p>You may use special comments to disable some warnings.<br>Use // eslint-disable-next-line to ignore the next line.<br>Use /* eslint-disable */ to ignore all warnings in a file.</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><p>在 my-project/config/index.js里有配置:</p><blockquote><p>useEslint: true, // 改为false即可。</p></blockquote><p>然后重新执行   cnpm run dev</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17日日报</title>
    <link href="undefined2019/09/17/2019-9-17-ribao/"/>
    <url>2019/09/17/2019-9-17-ribao/</url>
    
    <content type="html"><![CDATA[<br><p><strong>今天又是学习Vue的一天</strong></p><p>有在很努力学习vue的呢</p><p>emmm... 今天还进行了3个js的学习</p><p>但是我只学会了一个(手动狗头)</p><p>不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多</p><p>10年后的你肯定会感谢现在努力的自己</p><p>you can</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue语法格式</title>
    <link href="undefined2019/09/16/2019-9-16-ribao/"/>
    <url>2019/09/16/2019-9-16-ribao/</url>
    
    <content type="html"><![CDATA[<h4 id="吼吼-，今天其实已经开始了vue的学习"><a href="#吼吼-，今天其实已经开始了vue的学习" class="headerlink" title="吼吼 ，今天其实已经开始了vue的学习"></a>吼吼 ，今天其实已经开始了vue的学习</h4><h2 id="vue语法格式"><a href="#vue语法格式" class="headerlink" title="vue语法格式"></a>vue语法格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id = &quot;vue_det&quot;&gt;</span><br><span class="line"> &lt;h1&gt;&lt;/h1&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> var vm=new Vue(&#123;</span><br><span class="line">el:&apos;#vue_det&apos;,</span><br><span class="line">data:&#123;</span><br><span class="line">  site: &quot;菜鸟教程&quot;,</span><br><span class="line">  url: &quot;www.runoob.com&quot;,</span><br><span class="line">  alexa: &quot;10000&quot;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">  details:function()&#123;</span><br><span class="line">    return  this.site+&quot;-学的不仅是技术，更是梦想！&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> &lt;p&gt;data 用于定义属性，实例中有三个属性分别为：site、url、alexa。&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;methods 用于定义的函数，可以通过 return 来返回函数值。&lt;/p&gt;</span><br><span class="line"> 在Vue构造器中有一个el参数，它是DOM元素中的id，这意味着我们接下来的改动全部在以上指定的div内，div外部不受影响。</span><br></pre></td></tr></table></figure><blockquote><p>当一个Vue实例被创建时，它向Vue的响应式系统中加入了其data对象中能找到的所有的属性。当这些属性的值发生改变时，html视图将也会产生相应的变化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var data = &#123; site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000&#125;</span><br><span class="line"> var vm = new Vue(&#123;</span><br><span class="line">   el: &apos;#vue_det&apos;,</span><br><span class="line">data: data      // 它们引用相同的对象！</span><br><span class="line"> &#125;)</span><br><span class="line"> document.write(vm.site === data.site) // true</span><br><span class="line"> document.write(&quot;&lt;br&gt;&quot;)                // 设置属性也会影响到原始数据</span><br><span class="line"> vm.site = &quot;Runoob&quot;</span><br><span class="line"> document.write(data.site + &quot;&lt;br&gt;&quot;) // Runoob</span><br><span class="line"> // ……反之亦然</span><br><span class="line"> data.alexa = 1234</span><br><span class="line"> document.write(vm.alexa) // 1234</span><br></pre></td></tr></table></figure><p>除了数据属性，Vue实例还提供了一些有用的实例属性与方法。它们都有前缀$，以便与用户定义的属性区分开来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vue_det&quot;&gt;</span><br><span class="line">  &lt;h1&gt;site : Jekyll::Drops::SiteDrop&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var data = &#123; site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#vue_det&apos;,</span><br><span class="line">  data: data</span><br><span class="line">&#125;) </span><br><span class="line">document.write(vm.$data === data) // true</span><br><span class="line">document.write(&quot;&lt;br&gt;&quot;) </span><br><span class="line">document.write(vm.$el === document.getElementById(&apos;vue_det&apos;)) // true</span><br></pre></td></tr></table></figure><blockquote><p>vue插值</p></blockquote><p>文本和html</p><p>使用v-text指令不解析直接输出字符串，使用v-html指令解析后用于输出字符串的执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-text=&quot;message&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &apos;&lt;h1&gt;菜鸟教程&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; 属性绑定</span><br><span class="line"> </span><br><span class="line"> &lt;p&gt; value值的绑定&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组。</span><br><span class="line">  单选按钮是直接取值不是逻辑值。&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;select列表与单选按钮是相似取值&lt;/p&gt;</span><br></pre></td></tr></table></figure> <input type="checkbox" v-model="use"> <input type="checkbox" id="runoob" value="Runoob" v-model="checkedNames"> <label for="runoob">Runoob</label>  new Vue({    el: '#app',    data:{      use: false    }  });<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> &lt;p&gt; input的value等于use，值的变化是相互的。即如果勾选后，use=true；&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&gt; class的绑定</span><br><span class="line"> </span><br><span class="line"> ``` </span><br><span class="line">  v-bind:class =&quot;&#123;class名1:boolean值，...,class名2:boolean值&#125;&quot;</span><br><span class="line">  判断class名1的值，如果为true使用class名1类的样式，否则不使用该类。</span><br><span class="line">  &lt;div v-bind:class=&quot;&#123;&apos;class1&apos;: use&#125;&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">      use: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  v-bind:class =&quot;[vue的属性名1,...,vue的属性名n]&quot;</span><br><span class="line">  class数组中的vue属性值就是class名。</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      activeClass: &apos;active&apos;,</span><br><span class="line">      errorClass: &apos;text-danger&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><blockquote><p> style的绑定，与class相似。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;div v-bind:style=&quot;&#123;color:activeColor,fontSize:fontSize+&apos;px&apos;&#125;&quot;&gt;菜鸟教程&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> new Vue(&#123;</span><br><span class="line">   el: &apos;#app&apos;,</span><br><span class="line">   data: &#123;</span><br><span class="line">     activeColor: &apos;green&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;菜鸟教程&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> new Vue(&#123;</span><br><span class="line">   el: &apos;#app&apos;,</span><br><span class="line">   data: &#123;</span><br><span class="line">     baseStyles: &#123;</span><br><span class="line">       color: &apos;green&apos;,</span><br><span class="line">       fontSize: &apos;30px&apos;</span><br><span class="line">     &#125;,</span><br><span class="line">  overridingStyles: &#123;</span><br><span class="line">       &apos;font-weight&apos;: &apos;bold&apos;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>表达式</p></blockquote><p>Vue.js都提供了完全的JavaScript表达式支持。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> new Vue(&#123;</span><br><span class="line">   el: &apos;#app&apos;,</span><br><span class="line">   data: &#123;</span><br><span class="line">  ok: true,</span><br><span class="line">     message: &apos;RUNOOB&apos;,</span><br><span class="line">  id : 1</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>指令</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v-if指令将根据表达式seen的值(true 或 false )来决定是否插入p元素。</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">还有v-else 、v-else-if指令，具有与JavaScript的条件语句相同的含义，</span><br><span class="line">v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后。</span><br><span class="line">v-show指令来根据条件真假来是否展示元素。</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    ok: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p> v-for指令</p></blockquote> <p> v-for="变量名 in 数组名"  变量名是从数组中取出的每一个变量的临时名称，数组名是vue的一个属性名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;value in object&quot;&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      name: &apos;菜鸟教程&apos;,</span><br><span class="line">      url: &apos;http://www.runoob.com&apos;,</span><br><span class="line">      slogan: &apos;学的不仅是技术，更是梦想！&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v-for=&quot;（变量名1，变量名2）in 数组名&quot;</span><br><span class="line">变量名1是从数组中取出的每一个变量的临时名称，变量名2是从数组中取出的每一个变量的键名，数组名是vue的一个属性名。</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value, key) in object&quot;&gt;</span><br><span class="line">       : </span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">v-for=&quot;（变量名1，变量名2，变量名3）in 数组名&quot;</span><br><span class="line">变量名1是从数组中取出的每一个变量的临时名称，变量名2是每一个变量的键名，变量名3是每一个变量的下标值，数组名是vue的一个属性名。</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value, key, index) in object&quot;&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue.js安装</title>
    <link href="undefined2019/09/16/2019-9-16-dsaf-day/"/>
    <url>2019/09/16/2019-9-16-dsaf-day/</url>
    
    <content type="html"><![CDATA[<h3 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1. 独立版本"></a>1. 独立版本<br></h3><p>我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="2-使用-CDN-方法"><a href="#2-使用-CDN-方法" class="headerlink" title="2. 使用 CDN 方法"></a>2. 使用 CDN 方法<br></h3><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p><blockquote><p>Staticfile CDN（国内） : <a href="https://cdn.staticfile.org/vue/2.2.2/vue.min.js" target="_blank" rel="noopener">https://cdn.staticfile.org/vue/2.2.2/vue.min.js</a></p></blockquote><blockquote><p>unpkg：<a href="https://unpkg.com/vue/dist/vue.js" target="_blank" rel="noopener">https://unpkg.com/vue/dist/vue.js</a>, 会保持和 npm 发布的最新的版本一致。</p></blockquote><blockquote><p>cdnjs : <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</a></p></blockquote><h3 id="3-NPM-方法"><a href="#3-NPM-方法" class="headerlink" title="3. NPM 方法"></a>3. NPM 方法</h3><p>npm 版本需要大于 3.0，如果低于此版本需要升级它</p><h4 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h4><blockquote><p>npm install npm -g</p></blockquote><h4 id="全局安装-vue-cli"><a href="#全局安装-vue-cli" class="headerlink" title="全局安装 vue-cli"></a>全局安装 vue-cli</h4><blockquote><p>$ cnpm install –global vue-cli</p></blockquote><h4 id="创建一个基于-webpack-模板的新项目"><a href="#创建一个基于-webpack-模板的新项目" class="headerlink" title="创建一个基于 webpack 模板的新项目"></a>创建一个基于 webpack 模板的新项目</h4><blockquote><p>$ vue init webpack my-project</p></blockquote><h4 id="这里需要进行一些配置，默认回车即可"><a href="#这里需要进行一些配置，默认回车即可" class="headerlink" title="这里需要进行一些配置，默认回车即可"></a>这里需要进行一些配置，默认回车即可</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This will install Vue 2.x version of the template.</span><br><span class="line"></span><br><span class="line">For Vue 1.x use: vue init webpack#1.0 my-project</span><br><span class="line"></span><br><span class="line">? Project name my-project</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author runoob &lt;test@runoob.com&gt;</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Use ESLint to lint your code? Yes</span><br><span class="line">? Pick an ESLint preset Standard</span><br><span class="line">? Setup unit tests with Karma + Mocha? Yes</span><br><span class="line">? Setup e2e tests with Nightwatch? Yes</span><br></pre></td></tr></table></figure><h4 id="进入项目，安装并运行："><a href="#进入项目，安装并运行：" class="headerlink" title="进入项目，安装并运行："></a>进入项目，安装并运行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd my-project </span><br><span class="line">$ cnpm install</span><br><span class="line">$ cnpm run dev</span><br><span class="line">DONE  Compiled successfully in 4388ms</span><br><span class="line">Listening at http://localhost:8080</span><br></pre></td></tr></table></figure><p>成功执行以上命令后访问 <a href="http://localhost:8080/，可得输出结果" target="_blank" rel="noopener">http://localhost:8080/，可得输出结果</a></p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12日日报</title>
    <link href="undefined2019/09/12/2019-9-12-ribao/"/>
    <url>2019/09/12/2019-9-12-ribao/</url>
    
    <content type="html"><![CDATA[<br><p>今天学习了新的js特效，充实的一天很快过去，疲惫的一天也即将完结</p><p>但是我的心里的激动却停不了，明天就是中秋节，那明天就是假期?</p><p>甚至会情不自禁笑出声，忽然航哥告诉我们:明天放假，作业是...</p><p>wtf? 忽然一瞬间，心情由高空落向低谷，行吧做作业把</p><p>you can,加油少年</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11日日报</title>
    <link href="undefined2019/09/11/2019-9-11-ribao/"/>
    <url>2019/09/11/2019-9-11-ribao/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>又是超级无聊的一天日报</p><p>但是又是超级努力的一天</p><p>不只是我在努力哦，全班同学都十分努力</p><p>大家都想提前努力，好让航哥知道我们不是吃醋的(还是糖好吃)</p><p>行吧，还是要努力呀</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10日日报</title>
    <link href="undefined2019/09/10/2019-9-10-ribao/"/>
    <url>2019/09/10/2019-9-10-ribao/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天又是重复的一天</p><p>日子一天天过去</p><p>js也越发熟练，然而我的耐心也一点点消耗着</p><p>但是，小明告诉我们不要放弃呀</p><p>所以，要跟紧小明的步伐</p><p>推一首歌<strong><rain(魔女与玛丽之花主题曲)></rain(魔女与玛丽之花主题曲)></strong></p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9日日报</title>
    <link href="undefined2019/09/09/2019-9-9-ddddribao/"/>
    <url>2019/09/09/2019-9-9-ddddribao/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天学习了用js制作表单验证和表单设置默认值</p><p>学的马马虎虎，但是能默写出来(时间够的话)</p><p>哦，对了，今天还学会了div转圈圈 和 js设置选项卡</p><p>emmm... 过了 ，毫无瑕疵</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例设计模式</title>
    <link href="undefined2019/09/08/2019-9-8-singleton/"/>
    <url>2019/09/08/2019-9-8-singleton/</url>
    
    <content type="html"><![CDATA[<p><strong>什么是单例设计模式？</strong></p><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>需要：</p>1. 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。2. 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。3.  定义一个静态方法返回这个唯一对象。<p><em>实现一：立即加载 / “饿汉模式”</em></p><p>立即加载就是使用类的时候已经将对象创建完毕（不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”），常见的实现办法就是直接new实例化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static、final修饰</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“饿汉模式”的优缺点：</p><p>优点：实现起来简单，没有多线程同步问题。</p><p>缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。</p><p><em>实现二：延迟加载 / “懒汉模式”</em></p><p>延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“懒汉模式”的优缺点：</p><p>优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。</p><p>缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。</p><p><em>实现三：线程安全的“懒汉模式”</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例，加synchronized关键字实现同步</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：在多线程情形下，保证了“懒汉模式”的线程安全。</p><p>缺点：众所周知在多线程情形下，synchronized方法通常效率低，显然这不是最佳的实现方案。</p>*实现四：DCL双检查锁机制（DCL：double checked locking）*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        // 第一次检查instance是否被实例化出来，如果没有进入if块</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                // 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四算是单例模式的最佳实现方式。内存占用率高，效率高，线程安全，多线程操作原子性。</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webstrom安装</title>
    <link href="undefined2019/09/07/2019-9-7-wwebstorm/"/>
    <url>2019/09/07/2019-9-7-wwebstorm/</url>
    
    <content type="html"><![CDATA[<p>安装webstorm首先应该配置环境安装 java的开源代码库,再下载安装包进行</p><p>WebStorm是基于Java的,我们需要安装Oracle JDK的支持.   注:有jdk就不用本步骤了</p><p>安装 Oracle JDK 的命令如下:</p><p></p><h3 id="1-sudo-add-apt-repository-ppa-webupd8team-java"><a href="#1-sudo-add-apt-repository-ppa-webupd8team-java" class="headerlink" title="1. sudo add-apt-repository ppa:webupd8team/java"></a>1. sudo add-apt-repository ppa:webupd8team/java</h3><p>add-apt-repository ppa:<ppa_name>  下载java开源代码库。</ppa_name></p><h3 id="2-sudo-apt-get-update"><a href="#2-sudo-apt-get-update" class="headerlink" title="2.sudo apt-get update"></a>2.sudo apt-get update</h3><p>获取到最新的软件包(apt-get update)</p><h3 id="3-sudo-apt-get-install-oracle-java7-installer"><a href="#3-sudo-apt-get-install-oracle-java7-installer" class="headerlink" title="3.sudo apt-get install oracle-java7-installer"></a>3.sudo apt-get install oracle-java7-installer</h3><p>下载并安装java开源代码库</p><h3 id="4-sudo-apt-get-install-oracle-java7-set-defaul"><a href="#4-sudo-apt-get-install-oracle-java7-set-defaul" class="headerlink" title="4.sudo apt-get install oracle-java7-set-defaul"></a>4.sudo apt-get install oracle-java7-set-defaul</h3><p>运行命令查看是否安装成功:</p><blockquote><p>java -version</p></blockquote><p>显示java开源代码的版本,如果显示则说明java开源代码安装成功.</p><p><strong>[WebStorm]安装</strong></p><p>首先需要下载WebStrom的Linux安装包,地址如下:</p><p><blockquote><p>s<a href="https://www.jetbrains.com/webstorm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/webstorm/download/</a></p></blockquote></p><p>然后运行如下命令解压并安装并运行WebStorm:</p><blockquote><p>sudo tar xfz ~/Downloads/WebStorm-16.2.3.tar.gz</p></blockquote><p>这一步是先进行解压缩</p><blockquote><p>sudo mv ~/Downloads/WebStorm-162.2228.20 /home/wang/下载/</p></blockquote><p>mv移动命令</p><p>然后再把解压文件移动到 home/wang/下载/ 下</p><blockquote><p>cd /home/wang/下载/WebStorm-162.2228.20/<br>   cd bin/</p></blockquote><p>进入bin目录</p><blockquote><p>sudo sh webstorm.sh</p></blockquote><p>sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取启动webstorm</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重装系统后重新与github建立连接</title>
    <link href="undefined2019/09/07/2019-9-7-dddd/"/>
    <url>2019/09/07/2019-9-7-dddd/</url>
    
    <content type="html"><![CDATA[<p><strong>解决办法是，再次生成一个密钥，然后完成跟github远程仓库的认证即可建立连接。</strong></p><p>默认你已经安装好了git，如果没有安装，windows下安装gitbash自带git，linux系统的话sudo apt-get  install -g git就可以了</p><h3 id="生成SSH秘钥"><a href="#生成SSH秘钥" class="headerlink" title="生成SSH秘钥"></a>生成SSH秘钥</h3><p>第一步先生成ssh秘钥。在系统根目录下打开命令行终端，执行命令：ssh-keygen -t rsa -C "填写你的任意邮箱"，</p><p>执行完成后，会生成一个.ssh文件夹，里面的id_rsa.pub文件内容就是秘钥，那么我们就进入ssh文件夹打开该文件后复制它的内容。或者命令行快速打开cd ./.ssh && cat id_rsa.pub然后会有一大串字符打印在终端，这个是秘钥内容，全部复制下来。</p><h3 id="登录github新建SSH-Key"><a href="#登录github新建SSH-Key" class="headerlink" title="登录github新建SSH Key"></a>登录github新建SSH Key</h3><p>登录自己的github，在右上角头像框点击邮件选择Settings，然后在左边菜单选择SSH and GPG keys,在SSH keys一栏点击New SSH key的绿色按钮，title随便写，key那一个框框里把刚才复制的id_rsa.pub的内容粘贴到这里，确定复制的是完整的秘钥不要漏了。粘贴完后点下面Add的绿色按钮，这样就在github上生成了一个对应的SSH秘钥了。</p><h3 id="验证SSH"><a href="#验证SSH" class="headerlink" title="验证SSH"></a>验证SSH</h3><p>回到本地，随便找个空文件夹或者新建一个文件夹，在这个新文件夹下新建一个git本地仓库。终端在这个文件夹的路径下打开，路径一定要正确，然后执行</p><blockquote><p>git init</p></blockquote><p>再然后就是设置用户名和邮箱：</p><blockquote><p>git config –global user.name “你的用户名”</p></blockquote><blockquote><p>git config –global user.email “你的邮箱”</p></blockquote><p>设置完后，设置你想要建立对应连接的远程仓库地址：</p><blockquote><p>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:XXXXXXX/xxxxxxx.git </p></blockquote><p>这里的地址填写你github仓库的SSH地址，注意是SSH的地址不是http的地址</p><p>设置完成后，把远程仓库的源代码拉取到本地：</p><blockquote><p>git pull origin master –allow-unrelated-histories  </p></blockquote><p><strong>这里的master是你远程仓库的分支名，如果你的分支名不是master你就改成你的分支名</strong></p><p>一般来讲没有改过的分支名肯定有一个是master，只不过不知道你想要的代码在不在master分支。</p><p>执行上述命令后会出现一堆信息，大概就是关于验证的，结束会有一个（yes/no），这里手打‘yes’再回车就可以完成验证了，直接打回车会验证错误，原贴在这里 [https://blog.csdn.net/u010193432/article/details/82877663](https://blog.csdn.net/u010193432/article/details/82877663)    验证通过后就会拉取远程master分支的代码到你的文件夹，并同时在本地创建一个master分支。接下来就是要建立本地分支和远程分支的追踪关系，方便以后push，执行如下命令：</p><blockquote><p>git branch –set-upstream-to=origin/master</p></blockquote><p>至此，本地仓库重新与github远程仓库建立了连接,再次执行git pull,出现up to date就没问题了</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6日日报</title>
    <link href="undefined2019/09/06/2019-9-6-ddddd/"/>
    <url>2019/09/06/2019-9-6-ddddd/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天也考核了</p><p>考核前,感觉良好,因为看了好几天,总归是有点记忆的</p><p>但是,航哥开口一瞬间,我感觉到了自己的不足(诧异),好像没学过似的</p><p>但是我是不会努力的,杰宝come on</p><p>Keep on going never give up</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>放大镜实现</title>
    <link href="undefined2019/09/05/2019-9-5-ddddd/"/>
    <url>2019/09/05/2019-9-5-ddddd/</url>
    
    <content type="html"><![CDATA[<h4 id="放大镜的实现"><a href="#放大镜的实现" class="headerlink" title="放大镜的实现"></a>放大镜的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;    </span><br><span class="line">*&#123;margin:0px;</span><br><span class="line">padding:0px;&#125;</span><br><span class="line">.img&#123;</span><br><span class="line">width: 350px;</span><br><span class="line">height: 350px;</span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">margin: 0px;</span><br><span class="line">position: absolute;</span><br><span class="line">cursor:move;</span><br><span class="line">left: 500px;</span><br><span class="line">&#125;    </span><br><span class="line">.bimg&#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: -1px;</span><br><span class="line">left: 360px;         </span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">width: 350px;</span><br><span class="line">height: 350px;         </span><br><span class="line">overflow: hidden;</span><br><span class="line">display: none;</span><br><span class="line">&#125;  </span><br><span class="line">#move&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;        </span><br><span class="line">  background-color: rgba(8,152,202,0.2);</span><br><span class="line">  top: 0px;        </span><br><span class="line">  left: 0px;</span><br><span class="line">  display: none;</span><br><span class="line">  &#125;   </span><br><span class="line">.simg&#123;</span><br><span class="line">width: 350px;</span><br><span class="line">height: 350px;</span><br><span class="line">&#125;</span><br><span class="line">.bimg&gt;img&#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 0px;</span><br><span class="line">   top: 0px;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;img&quot;&gt;   </span><br><span class="line">&lt;div class=&quot;simg&quot;&gt;&lt;!--小图片--&gt;     </span><br><span class="line">    &lt;img src=&quot;/home/zhangjie/图片/miojk(复件).jpg&quot; style=&quot;width:350px;height:350px;&quot; /&gt;     </span><br><span class="line">    &lt;div id=&quot;move&quot;&gt;&lt;/div&gt;&lt;!--放大区域--&gt;  </span><br><span class="line"> &lt;/div&gt;  </span><br><span class="line">    &lt;div class=&quot;bimg&quot;&gt;&lt;!--大图片--&gt;    </span><br><span class="line">    &lt;img src=&quot;/home/zhangjie/图片/miojk.jpg&quot; style=&quot;width:1225px ;height: 1225px;&quot; /&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">//鼠标移动到图片显示，移除隐藏     </span><br><span class="line">$(&quot;.img&quot;).hover(function()&#123;           </span><br><span class="line">   $(&quot;.bimg&quot;).css(&quot;display&quot;,&quot;block&quot;);          </span><br><span class="line">    $(&quot;#move&quot;).css(&quot;display&quot;,&quot;block&quot;);       </span><br><span class="line">&#125;,function()&#123;       </span><br><span class="line">  $(&quot;.bimg&quot;).css(&quot;display&quot;,&quot;none&quot;);         </span><br><span class="line">  $(&quot;#move&quot;).css(&quot;display&quot;,&quot;none&quot;);       </span><br><span class="line">  &#125;);</span><br><span class="line">//放大区域移动，大图片移动</span><br><span class="line">$(&quot;.img&quot;).mousemove(function(event)&#123;</span><br><span class="line">    var x = event.pageX;          </span><br><span class="line">    var y = event.pageY;                   </span><br><span class="line">    var nx = x - $(&quot;.img&quot;).offset().left-$(&quot;#move&quot;).width()/2;            </span><br><span class="line">    var ny = y - $(&quot;.img&quot;).offset().top-$(&quot;#move&quot;).height()/2;           </span><br><span class="line">    if(nx &lt; 0)&#123; </span><br><span class="line">        nx = 0;</span><br><span class="line">    &#125;            </span><br><span class="line">    if(nx &gt; $(&quot;.img&quot;).width()-$(&quot;#move&quot;).width())&#123;        </span><br><span class="line">        nx = $(&quot;.img&quot;).width()-$(&quot;#move&quot;).width();         </span><br><span class="line">    &#125;            </span><br><span class="line">    if(ny &lt; 0)&#123;       </span><br><span class="line">        ny = 0;            </span><br><span class="line">    &#125;            </span><br><span class="line">    if(ny &gt; $(&quot;.img&quot;).height()-$(&quot;#move&quot;).height())&#123;       </span><br><span class="line">        ny = $(&quot;.img&quot;).height()-$(&quot;#move&quot;).height();     </span><br><span class="line">    &#125;                </span><br><span class="line">    $(&quot;#move&quot;).css(&#123;           </span><br><span class="line">        left:nx+&quot;px&quot;,           </span><br><span class="line">        top:ny+&quot;px&quot;       </span><br><span class="line">    &#125;);           </span><br><span class="line">    $(&quot;.bimg&gt;img&quot;).css(&#123;         </span><br><span class="line">        left:-nx*$(&quot;.bimg&quot;).width()/$(&quot;#move&quot;).width()+&quot;px&quot;,   </span><br><span class="line">        top:-ny*$(&quot;.bimg&quot;).height()/$(&quot;#move&quot;).height()+&quot;px&quot;      </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">                                              </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4日日报</title>
    <link href="undefined2019/09/04/2019-9-4-ddddd/"/>
    <url>2019/09/04/2019-9-4-ddddd/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><p>今天任务比较重 ,大家都什么认真的在学习,我也不例外</p><p>但是我能看的出来大家都有点局促不安</p><p>果然,下午航哥来对我们进行考核了,大家在一片哈哈声中有了一丝丝的沉重</p><p>考完了,怎么说呢 ,差点去世,航哥考核我们的是团队协作能力</p><p>大家都有一些顿悟,大家的声音也感觉到了靠近</p><p>什么是兄弟呢?</p>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3日日报</title>
    <link href="undefined2019/09/03/2019-9-2-dsad-day/"/>
    <url>2019/09/03/2019-9-2-dsad-day/</url>
    
    <content type="html"><![CDATA[<h4 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h4><h5 id="今天任务繁重-明天任需加油"><a href="#今天任务繁重-明天任需加油" class="headerlink" title="今天任务繁重 明天任需加油"></a>今天任务繁重 明天任需加油</h5><h5 id="今天听书内容精湛-同学们准备充足-思路清晰-主题明确-大家都积极发言-好和谐一集体"><a href="#今天听书内容精湛-同学们准备充足-思路清晰-主题明确-大家都积极发言-好和谐一集体" class="headerlink" title="今天听书内容精湛,同学们准备充足 思路清晰 主题明确,大家都积极发言,好和谐一集体"></a>今天听书内容精湛,同学们准备充足 思路清晰 主题明确,大家都积极发言,好和谐一集体</h5><h5 id="以后还得加油鸭"><a href="#以后还得加油鸭" class="headerlink" title="以后还得加油鸭"></a>以后还得加油鸭</h5>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2日日报</title>
    <link href="undefined2019/09/02/2019-9-2-dasda/"/>
    <url>2019/09/02/2019-9-2-dasda/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><h4 id="今天背了用socketio做成的聊天室-虽然比较简陋-但是是可以作为自己玩乐的小游戏的"><a href="#今天背了用socketio做成的聊天室-虽然比较简陋-但是是可以作为自己玩乐的小游戏的" class="headerlink" title="今天背了用socketio做成的聊天室 虽然比较简陋,但是是可以作为自己玩乐的小游戏的"></a>今天背了用socketio做成的聊天室 虽然比较简陋,但是是可以作为自己玩乐的小游戏的</h4><h4 id="emmm…今天还和兄弟们一起装修了工作区-我们都很高兴-新办公桌办公椅真是舒服"><a href="#emmm…今天还和兄弟们一起装修了工作区-我们都很高兴-新办公桌办公椅真是舒服" class="headerlink" title="emmm…今天还和兄弟们一起装修了工作区,我们都很高兴,新办公桌办公椅真是舒服"></a>emmm…今天还和兄弟们一起装修了工作区,我们都很高兴,新办公桌办公椅真是舒服</h4><h4 id="所以呀-要更加努力了"><a href="#所以呀-要更加努力了" class="headerlink" title="所以呀,要更加努力了"></a>所以呀,要更加努力了</h4><h4 id="come-on"><a href="#come-on" class="headerlink" title="come on!"></a>come on!</h4>]]></content>
    
    
    <categories>
      
      <category>9月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>websocket和socketio的总结</title>
    <link href="undefined2019/08/30/2019-8-30-thth-day/"/>
    <url>2019/08/30/2019-8-30-thth-day/</url>
    
    <content type="html"><![CDATA[<h3 id="WebSocket和SocketIO总结"><a href="#WebSocket和SocketIO总结" class="headerlink" title="WebSocket和SocketIO总结"></a>WebSocket和SocketIO总结</h3><h4 id="WebSocket是什么？"><a href="#WebSocket是什么？" class="headerlink" title="WebSocket是什么？"></a>WebSocket是什么？</h4><p>WebScoket是一种让客户端和服务器之间能进行双向实时通信的技术。它是HTML最新标准HTML5的一个协议规范，本质上是个基于TCP的协议，它通过HTTP/HTTPS协议发送一条特殊的请求进行握手后创建了一个TCP连接，此后浏览器/客户端和服务器之间便可以通过此连接来进行双向实时通信。</p><h4 id="为什么要用WebSocket？"><a href="#为什么要用WebSocket？" class="headerlink" title="为什么要用WebSocket？"></a>为什么要用WebSocket？</h4><ul><li><p>一直以来，HTTP协议是无状态、单向通信的，即客户端请求一次，服务器回复一次。如果想让服务器消息及时下发到客户端，需要采用类似于轮询的机制，即客户端定时频繁的向服务器发出请求，这样效率很低，而且HTTP数据包头本身的字节量较大，浪费了大量带宽和服务器资源；</p></li><li><p>为提高效率，出现了AJAX/Comet技术，它实现了双向通信且节省了一定带宽，但仍然需要发出请求，本质上仍然是轮询；</p></li><li><p>新一代HTML标准HTML5推出了WebSocket技术，它使客户端和服务器之间能通过HTTP协议建立TCP连接，之后便可以随时随地进行双向通信，且交换的数据包头信息量很小；</p><h4 id="如何使用WebSocket？"><a href="#如何使用WebSocket？" class="headerlink" title="如何使用WebSocket？"></a>如何使用WebSocket？</h4></li></ul><p>在支持WebSocket的浏览器中，创建Socket之后，通过onopen、onmessage、onclose、onerror四个事件的实现来处理Socket的响应；</p><h4 id="WebSocket与HTTP、TCP的关系"><a href="#WebSocket与HTTP、TCP的关系" class="headerlink" title="WebSocket与HTTP、TCP的关系"></a>WebSocket与HTTP、TCP的关系</h4><p>WebSocket和HTTP都属于应用层协议，且都是基于TCP的，它们的send函数最终也是通过TCP系统接口来做数据传输。那么WebSocket和HTTP的关系呢？WebSocket在建立握手连接时，数据是通过HTTP协议传输的，但是在连接建立后，真正的数据传输阶段则不需要HTTP协议的参与</p><h4 id="什么情况下使用WebSocket？"><a href="#什么情况下使用WebSocket？" class="headerlink" title="什么情况下使用WebSocket？"></a>什么情况下使用WebSocket？</h4><p>如果游戏需要同时支持手机端、Web端，那毫无疑问应该使用WebSocket，现在各个平台都提供了相应的WebSocket实现。如果游戏不需要支持Web端，且对实时性要求比较高，如多人射击、MMORPG之类，那么使用TCP/UDP结合的原生Socket会比较好。</p><h4 id="SocketIO"><a href="#SocketIO" class="headerlink" title="SocketIO"></a>SocketIO</h4><p>WebSocket是HTML5最新提出的规范，虽然主流浏览器都已经支持，但仍然可能有不兼容的情况，为了兼容所有浏览器，给程序员提供一致的编程体验，SocketIO将WebSocket、AJAX和其它的通信方式全部封装成了统一的通信接口，也就是说，我们在使用SocketIO时，不用担心兼容问题，底层会自动选用最佳的通信方式。因此说，WebSocket是SocketIO的一个子集。</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30日日报</title>
    <link href="undefined2019/08/30/2019-8-30--ththth-day/"/>
    <url>2019/08/30/2019-8-30--ththth-day/</url>
    
    <content type="html"><![CDATA[<h3 id="今日日报"><a href="#今日日报" class="headerlink" title="今日日报"></a>今日日报</h3><ul><li><p>今天学习了服务器和客户端之间的知识</p></li><li><p>然后搞了点视频教学,视频教学在B站</p><blockquote><p><a href="https://www.bilibili.com/video/av16660731?from=search&amp;seid=16870578180827938449" target="_blank" rel="noopener">https://www.bilibili.com/video/av16660731?from=search&amp;seid=16870578180827938449</a></p></blockquote></li></ul><p>我看了好长时间...  主要是俩个字母错了,结果在整个代码找了好久</p><h4 id="我太难了"><a href="#我太难了" class="headerlink" title="我太难了"></a>我太难了</h4><ul><li><p>好了,学习使我快乐, 努力学习</p></li><li><p>加油 加油 加油!</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轮播图</title>
    <link href="undefined2019/08/29/2019-8-29--ththtz-day/"/>
    <url>2019/08/29/2019-8-29--ththtz-day/</url>
    
    <content type="html"><![CDATA[<h3 id="轮播图代码"><a href="#轮播图代码" class="headerlink" title="轮播图代码"></a>轮播图代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html lang=&quot;ch&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;轮播演示&lt;/title&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">img&#123;</span><br><span class="line">border: 1px solid pink;</span><br><span class="line">height: 270px;</span><br><span class="line">&#125;</span><br><span class="line">body&#123;</span><br><span class="line">background-color: purple;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"> &lt;div &gt;</span><br><span class="line"> &lt;img src=&quot;/home/zhangjie/图片/ccc1.jpg&quot; id=&quot;iid&quot;&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> var index =1;</span><br><span class="line"> window.onload=function()&#123;setInterval(lunbo,1000);&#125;</span><br><span class="line"> function lunbo()&#123;</span><br><span class="line"> var img = document.getElementById(&apos;iid&apos;);</span><br><span class="line"> index++;</span><br><span class="line"> img.src=&quot;/home/zhangjie/图片/ccc&quot;+index+&quot;.jpg&quot;;</span><br><span class="line">  if(index===5)&#123;</span><br><span class="line"> index =1;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>如上代码可实现轮播,但是图片得自行调整</li></ul>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodejs简单使用</title>
    <link href="undefined2019/08/29/2019-8-29--ththth-day/"/>
    <url>2019/08/29/2019-8-29--ththth-day/</url>
    
    <content type="html"><![CDATA[<h3 id="Node-js-组成"><a href="#Node-js-组成" class="headerlink" title="Node.js 组成"></a>Node.js 组成</h3><ol><li><p>引入required模块：我们可以使用require指令来载入Node.js模块。</p></li><li><p>创建服务器：服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p></li><li><p>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>29日日报</title>
    <link href="undefined2019/08/29/2019-8-29--ththth-da/"/>
    <url>2019/08/29/2019-8-29--ththth-da/</url>
    
    <content type="html"><![CDATA[<h3 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h3><ol><li><p>今天学习了点nodejs 并且安装了nodejs 环境算是对nodejs有点基础</p></li><li><p>今天学习了制作定时器,分为定时弹出和周期性弹出</p></li><li><p>今日感觉良好,并且看了点有关服务器和客户端的知识</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css选择权简介</title>
    <link href="undefined2019/08/28/2019-8-28-thir-thirteenth-day/"/>
    <url>2019/08/28/2019-8-28-thir-thirteenth-day/</url>
    
    <content type="html"><![CDATA[<h4 id="CSS样式实现方式"><a href="#CSS样式实现方式" class="headerlink" title="CSS样式实现方式"></a>CSS样式实现方式</h4><ol><li><p>内联样式</p><ul><li>单独作用在 一个元素的上的 样式 叫 内联样式 </li><li>实现是通过  元素的 style 属性 </li></ul></li><li><p>内部样式</p><ul><li>针对单独的一个页面的  样式 </li><li>实现是 通过   style 标签实现的 </li></ul></li><li><p>外部样式</p><ul><li>针对 多个页面的   一般先定义成样式文件  然后在需要的页面上进行引入 </li><li>具体事项  先有样式 文件  ***.css</li><li>使用 link 标签 或者  style 标签进行引入 </li></ul></li></ol><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><ol><li><p>元素选择器</p></li><li><p>类选择器</p></li><li><p>id选择器</p></li><li><p>伪类选择器</p></li><li><p>后代选择器</p></li><li><p>子元素选择器</p></li></ol><h4 id="常用伪类"><a href="#常用伪类" class="headerlink" title="常用伪类"></a>常用伪类</h4><ul><li><p>:link<br>向未被访问的超链接添加样式</p></li><li><p>:visited<br>向已被访问的超列检添加样式</p></li><li><p>:active<br>向被激活的元素添加样式</p></li><li><p>:hover<br>当鼠标悬停至元素上方时,向钙元素添加样式</p></li><li><p>:focus<br>当元素获取焦点时,向该元素添加样式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28日日报</title>
    <link href="undefined2019/08/28/2019-8-28-thirteenth-day/"/>
    <url>2019/08/28/2019-8-28-thirteenth-day/</url>
    
    <content type="html"><![CDATA[<h3 id="学习js…"><a href="#学习js…" class="headerlink" title="学习js…"></a>学习js…</h3><ol><li><p>今天粗略看了html,css,js,果然有点基础就是好,理解起来超级快</p></li><li><p>然后一天就过去了,我又在刚才看了点关于node.js的内容</p></li><li><p>好了,今日日报到此结束</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodejs安装</title>
    <link href="undefined2019/08/27/2019-8-27-twelth-technolog/"/>
    <url>2019/08/27/2019-8-27-twelth-technolog/</url>
    
    <content type="html"><![CDATA[<h3 id="ubuntu下安装nodejs和npm"><a href="#ubuntu下安装nodejs和npm" class="headerlink" title="ubuntu下安装nodejs和npm"></a>ubuntu下安装nodejs和npm</h3><p><strong>第一种安装方法</strong>：</p><blockquote><p>安装nodejs ：</p></blockquote><p>sudo apt-get install nodejs</p><p>运行 nodejs -v 会弹出安装node的版本号<br></p><p>这里使用的是 nodejs 并不是常用的node ，可以通过<br></p><blockquote><p>sudo ln -s /usr/bin/nodejs /usr/bin/node</p></blockquote><p>命令让node与nodejs建立软连接，接着就可以使用 node命令<br></p><p>安装npm:<br></p><blockquote><p>sudo apt-get install npm</p></blockquote><p>测试安装是否成功: npm -v 弹出安装的版本号，即可证明安装成功</p><p><strong>第二种安装方法：</strong></p><p>先安装，nvm，即是Node Version Manager(Node版本管理器)</p><blockquote><p>curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash" target="_blank" rel="noopener">https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash</a></p></blockquote><p>或者使用 wget</p><blockquote><p>wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash" target="_blank" rel="noopener">https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh|bash</a></p></blockquote><p>之后需要激活nvm:</p><blockquote><p>source ~/.nvm/nvm.sh</p></blockquote><p>激活完成后，安装node</p><blockquote><p>nvm install node</p></blockquote><p>安装完成后，切换到该版本</p><blockquote><p>nvm use node</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单命令</title>
    <link href="undefined2019/08/27/2019-8-27-eleven-day/"/>
    <url>2019/08/27/2019-8-27-eleven-day/</url>
    
    <content type="html"><![CDATA[<h4 id="echo-显示文本行"><a href="#echo-显示文本行" class="headerlink" title="echo  //显示文本行"></a>echo  //显示文本行</h4><h4 id="echo-LANG-显示系统语言"><a href="#echo-LANG-显示系统语言" class="headerlink" title="echo $LANG  //显示系统语言"></a>echo $LANG  //显示系统语言</h4><h4 id="echo-PATH-显示系统的环境变量"><a href="#echo-PATH-显示系统的环境变量" class="headerlink" title="echo $PATH  //显示系统的环境变量"></a>echo $PATH  //显示系统的环境变量</h4><h4 id="date-显示当前时间"><a href="#date-显示当前时间" class="headerlink" title="date //显示当前时间"></a>date //显示当前时间</h4><h4 id="date-’-Y-m-d’-以yyyy-mm-dd格式显示日期"><a href="#date-’-Y-m-d’-以yyyy-mm-dd格式显示日期" class="headerlink" title="date +’%Y/%m/%d’  //以yyyy/mm/dd格式显示日期"></a>date +’%Y/%m/%d’  //以yyyy/mm/dd格式显示日期</h4><h4 id="date-’-Y-m-d’-以yyyy-mm-dd格式显示日期-1"><a href="#date-’-Y-m-d’-以yyyy-mm-dd格式显示日期-1" class="headerlink" title="date +’%Y-%m-%d’  //以yyyy-mm-dd格式显示日期"></a>date +’%Y-%m-%d’  //以yyyy-mm-dd格式显示日期</h4><h4 id="date-H-M-显示时、分"><a href="#date-H-M-显示时、分" class="headerlink" title="date +%H:%M  //显示时、分"></a>date +%H:%M  //显示时、分</h4><h4 id="date-r-test-显示test文件最后一次的修改时间"><a href="#date-r-test-显示test文件最后一次的修改时间" class="headerlink" title="date -r test  //显示test文件最后一次的修改时间"></a>date -r test  //显示test文件最后一次的修改时间</h4><h4 id="cat-etc-shells-查看shell版本"><a href="#cat-etc-shells-查看shell版本" class="headerlink" title="cat /etc/shells  //查看shell版本"></a>cat /etc/shells  //查看shell版本</h4><h4 id="hostname-显示主机名"><a href="#hostname-显示主机名" class="headerlink" title="hostname  //显示主机名"></a>hostname  //显示主机名</h4><h4 id="hostname-a-显示主机别名"><a href="#hostname-a-显示主机别名" class="headerlink" title="hostname  -a  //显示主机别名"></a>hostname  -a  //显示主机别名</h4><h4 id="hostname-d-显示主机域名"><a href="#hostname-d-显示主机域名" class="headerlink" title="hostname  -d  //显示主机域名"></a>hostname  -d  //显示主机域名</h4><h4 id="hostname-i-显示主机IP地址"><a href="#hostname-i-显示主机IP地址" class="headerlink" title="hostname  -i  //显示主机IP地址"></a>hostname  -i  //显示主机IP地址</h4><h4 id="hostname-主机名-设置主机名称"><a href="#hostname-主机名-设置主机名称" class="headerlink" title="hostname 主机名 //设置主机名称"></a>hostname 主机名 //设置主机名称</h4><h4 id="cal-显示当前月份"><a href="#cal-显示当前月份" class="headerlink" title="cal  //显示当前月份"></a>cal  //显示当前月份</h4><h4 id="查看Linux-端口"><a href="#查看Linux-端口" class="headerlink" title="查看Linux 端口"></a>查看Linux 端口</h4><h4 id="netstat-pan-grep-177-查看177端口情况"><a href="#netstat-pan-grep-177-查看177端口情况" class="headerlink" title="netstat -pan|grep 177  //查看177端口情况"></a>netstat -pan|grep 177  //查看177端口情况</h4><h4 id="netstat-nlap-查询进程占用哪些端口"><a href="#netstat-nlap-查询进程占用哪些端口" class="headerlink" title="netstat -nlap  //查询进程占用哪些端口"></a>netstat -nlap  //查询进程占用哪些端口</h4>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux简单命令</title>
    <link href="undefined2019/08/26/2019-8-26-dddd-day/"/>
    <url>2019/08/26/2019-8-26-dddd-day/</url>
    
    <content type="html"><![CDATA[<h4 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h4><p>pwd 输出当前目录</p><p>uname 输出本地计算机信息</p><p>date 输出当前系统时间</p><p>date -s 可修改当前日期和时间</p><p>free 输出内存使用信息</p><p>ls 列出当前目录的内容</p><p>cd 更改当前目录</p><p>clear 清屏</p><p>su 更换用户身份</p><p>shutdown 关机</p><p>reboot 重启</p><p>mv 移动某个文件或者更改名称</p><p>rm 删除指定文件</p><p>cp 复制某个文件 </p><p>mkdir 创建一个目录</p><p>rmdir 删除一个目录</p><p>cat 文本查看</p><p>head 显示头部文本内容</p><p>tail 显示尾部文本内容</p><p>vi 进入vi编辑模式</p><p>diff 找出俩个文件的不同</p><p>grep 搜索并指定字符串</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux简单命令</title>
    <link href="undefined2019/08/26/2019-8-26-tenth-day/"/>
    <url>2019/08/26/2019-8-26-tenth-day/</url>
    
    <content type="html"><![CDATA[<p>####今日演讲 <a href="../../桌面/演示稿.tar.xz">演示稿.tar.xz</a><br>今天我和组员们 演讲了整理一周的报告 我讲js基础知识<br><br>感觉收货很大<br></p><p><strong>这是今天的练习</strong><br> <a href="../../桌面/练习.html">练习.html</a> </p><p>今天还学习了Linux的部分知识,速度太慢<br></p><p><em>用户和群组</em></p><blockquote><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组 </p><p>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令 </p></blockquote><p><em>打包和压缩文件</em></p><blockquote><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件</p></blockquote><p>但是要努力啊</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iotop的安装</title>
    <link href="undefined2019/08/23/2019-8-23-ninth-techoolog/"/>
    <url>2019/08/23/2019-8-23-ninth-techoolog/</url>
    
    <content type="html"><![CDATA[<h3 id="iotop的简介："><a href="#iotop的简介：" class="headerlink" title="iotop的简介："></a>iotop的简介：</h3><p>iotop是一款开源、免费的用来监控磁盘I/O使用状况的类似top命令的工具，iotop可以监控进程的I/O信息。它是Python语言编写的，与iostat工具比较，iostat是系统级别的IO监控，而iotop是进程级别IO监控。目前最新的版本为iotop 0.6。其官方网址<a href="http://guichaz.free.fr/iotop/" target="_blank" rel="noopener">http://guichaz.free.fr/iotop/</a></p><h3 id="iotop的安装："><a href="#iotop的安装：" class="headerlink" title="iotop的安装："></a>iotop的安装：</h3><p><strong>注意</strong>，iotop的安装有前提条件（如果操作系统不满足这些条件，iotop无法正确安装）：</p><p>  1：内核版本为2.6.20或更高版本<br></p><p>  2：Python 2.7或更高的版本<br></p><h3 id="官方文档的详细介绍如下："><a href="#官方文档的详细介绍如下：" class="headerlink" title="官方文档的详细介绍如下："></a>官方文档的详细介绍如下：</h3><p>Linux has always been able to show how much I/O was going on (the bi and bo columns of the vmstat 1 command).<br></p><p>Iotop is a Python program with a top like UI used to show of behalf of which process is the I/O going on. It requires Python ≥ 2.7 and a Linux kernel ≥ 2.6.20 with the TASK_DELAY_ACCT CONFIG_TASKSTATS, TASK_IO_ACCOUNTING and CONFIG_VM_EVENT_COUNTERS options on.<br></p><h3 id="iotop的yum安装"><a href="#iotop的yum安装" class="headerlink" title="iotop的yum安装"></a>iotop的yum安装</h3><p>yum安装是最简单、快捷的。前提条件是你有配置yum的源配置。<br></p><p>[root@DB-Server ~]# python -V<br></p><p>Python 2.7.5<br></p><p>[root@DB-Server ~]# uname -a<br></p><p>Linux DB-Server 3.10.0-862.el7.x86_64 #1 SMP Fri Apr 20 16:44:24 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux<br></p><p>[root@DB-Server ~]# <br></p><p>[root@DB-Server ~]# yum -y install iotopbr&lt;&gt;</p><h3 id="iotop的源码安装"><a href="#iotop的源码安装" class="headerlink" title="iotop的源码安装"></a>iotop的源码安装</h3><p>wget <a href="http://guichaz.free.fr/iotop/files/iotop-0.6.tar.bz2" target="_blank" rel="noopener">http://guichaz.free.fr/iotop/files/iotop-0.6.tar.bz2</a><br></p><p>tar -xvf iotop-0.6.tar.gz <br></p><p>cd iotop-0.6<br></p><p>python setup.py build<br></p><p>python setup.py install<br><br><a href="https://www.cnblogs.com/kerrycode/p/11344506.html" target="_blank" rel="noopener">具体参考</a></p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iotop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23日日报</title>
    <link href="undefined2019/08/23/2019-8-23-ninth-day/"/>
    <url>2019/08/23/2019-8-23-ninth-day/</url>
    
    <content type="html"><![CDATA[<p>Linux下几个常见的文件查找命令：</p><ul><li>which       查看可执行文件的位置 </li><li>whereis    寻找特定文件，查看文件的位置 </li><li>locate       配合数据库查看文件位置 </li><li>find          实际搜寻硬盘查询文件名称 </li></ul><p><strong>find</strong>（用于在文件树中查找文件，并进行相应操作）</p><p>格式： find  [PATH]  [option]  [action]</p><ul><li><p>[PATH] : 所要搜索遍历的目录，默认为当前目录</p></li><li><p>[option] : 所要搜索文件的条件特征</p></li><li><p>[action] : 对搜索结果进行特殊处理</p></li></ul><p><strong>与时间有关的参数</strong></p><ul><li><p>amin  n     ：查找n分钟内被访问过的文件</p></li><li><p>cmin  n     : 查找n分钟内被修改过文件状态的所有文件</p></li><li><p>mmin  n    ： 查找n分钟内被修改过文件内容的所有文件</p></li><li><p>atime n     : 将n天内存取过的的文件列出来 </p></li></ul><p><strong>与文件权限及名称有关的参数</strong></p><ul><li><p>name [filename] : 查找文件名为filename的文件</p></li><li><p>type [TYPE]        ：查找文件类型为TYPE的文件</p></li><li><p>type选项常见的参数：</p></li></ul><p>参数|含义<br>b|块设备文件<br>c|字符设备文件<br>d|目录文件<br>f|普通文件<br>p|命名管道<br>l|符号链接</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22日日报</title>
    <link href="undefined2019/08/22/2019-8-22-eighth-day/"/>
    <url>2019/08/22/2019-8-22-eighth-day/</url>
    
    <content type="html"><![CDATA[<p>三种模式: 命令模式(Command mode)  输入模式(Insert mode) 和底线命令模式(Last line mode)<br></p><p>命令模式:<br><br>启动vi/vim时 我们便进入了命令模式<br><br>按 i切换到输入模式<br><br>按 x删除当前光标所在处的字符<br><br>： 切换到底线命令模式  在最底下一行输入命令<br></p><p>输入模式: <br><br>字符按键以及Shift组合,输入字符<br><br>ENTER，回车键，换行<br><br>BACK SPACE，退格键，删除光标前一个字符<br><br>DEL，删除键，删除光标后一个字符<br><br>方向键，在文本中移动光标<br><br>HOME/END，移动光标到行首/行尾<br><br>Page Up/Page Down，上/下翻页<br><br>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线<br><br>ESC，退出输入模式，切换到命令模<br></p><p><strong>底线命令模式</strong><br>在命令模式下按下:（英文冒号）就进入了底线命令模式<br><br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多<br><br>在底线命令模式中，基本的命令有（已经省略了冒号: <br><br>q 退出程序<br><br>w 保存文件<br></p><p>按ESC键可随时退出底线命令模式<br></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png" srcset="undefined" alt="Vi/Vim工作模式"></p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21日日报</title>
    <link href="undefined2019/08/21/2019-8-21-seventh-day/"/>
    <url>2019/08/21/2019-8-21-seventh-day/</url>
    
    <content type="html"><![CDATA[<ol><li>今天学习了同步远程仓库 : fit fetch 兄弟会 test</li><li>合并分支到主分支 : git merge 兄弟会/test</li><li>推主分支到github库 : git push -u 兄弟会/test</li><li>添加标签 : git tag v1.0</li><li>添加标签 : git tag v2.0</li></ol>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git4中协议</title>
    <link href="undefined2019/08/20/2019-8-20-sixth-day/"/>
    <url>2019/08/20/2019-8-20-sixth-day/</url>
    
    <content type="html"><![CDATA[<p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。<br></p><p>最基本的就是<em>本地协议（Local protocol）</em>，所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录<br></p><p>SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和Git）通常都是只读的<br></p><p>ssh-keygen -t rsa -C<br></p><p>Git 协议是一个包含在 Git 软件包中的特殊守护进程<br></p><p>HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的 post-update挂钩（hook）就可以搞定</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubantu安装QQ</title>
    <link href="undefined2019/08/20/2019-8-20-sixth-technology/"/>
    <url>2019/08/20/2019-8-20-sixth-technology/</url>
    
    <content type="html"><![CDATA[<p><strong>安装 wine</strong></p><p>git clone <a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git" target="_blank" rel="noopener">https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</a><br><br>cd deepin-wine-for-ubuntu<br><br>sudo sh install.sh<br><br><strong>安装QQ</strong></p><p>wget <a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb</a><br><br>sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb<br><br>sudo apt-get install -f<br></p><p>卸载QQ请自行百度</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git变基和标签操作</title>
    <link href="undefined2019/08/19/2019-8-19-fifth-day/"/>
    <url>2019/08/19/2019-8-19-fifth-day/</url>
    
    <content type="html"><![CDATA[<ol><li>变基操作，改写历史提交 把多次提交合并起来</li></ol><p>git rebase -i HEAD~3 变基之后的哈希值与之前的不同 证明变基是重新做的提交 把多次提交合并成了几次提交</p><ol start="2"><li>回撤操作</li></ol><p>git commit –amend -m “提交信息” // 回撤上一次提交并与本次工作区一起提交</p><p>git reset HEAD~2 –hard // 回撤2步</p><p>git reset –files // 从仓库回撤到暂存区</p><p>git reset HEAD // 回撤暂存区内容到工作目录</p><p>git reset HEAD –soft 回撤提交到暂存区</p><p>git reset HEAD –hard // 回撤提交 放弃变更<br>(慎用)</p><p>git reset HEAD^  // 回撤仓库最后一次提交</p><p>git reset –hard commitid // 回撤到该次提交id的位置</p><p>git push -f -u origin 分支名 所有内容都回撤完了 将回撤后的操作强制推送到远程分支</p><ol start="3"><li>标签操作</li></ol><p>git tag // 查看列出所有打过的标签名</p><p>git tag -d 标签名 // 删除对应标签</p><p>git tag 标签名字 // 在当前仓库打个标签</p><p>git tag foo -m “message” // 在当前提交上，打<br>标签foo 并给message信息注释</p><p>git tag 标签名 哈希值 -m “message” // 在某个哈希值上打标签并且写上标签的信息</p><p>git tag foo HEAD~4 // 在当前提交之前的第4个版本上 打标签foo</p><p>git push origin –tags // 把所有打好的标签推送到远程仓库</p><p>git push origin 标签名 // 把指定标签推送到远程仓库</p><p>git stash // 把暂存区的内容 暂时放在其他中 使暂存区变空</p><p>git stash list // 查看stash了哪些存储</p><p>git stash pop // 将stash中的内容恢复到当前目录，将缓存堆栈中的对应stash删除</p><p>git stash apply // 将stash中的内容恢复到当前目录，不会将缓存堆栈中的对应stash删除</p><p>git stash clear // 删除所有缓存的stash</p><p>git pull –tags // 把远程仓库的标签也拉取下来</p><p>git push origin :refs/tags/远程标签名 // 删除远程仓库的标签</p><ol start="4"><li>分支</li></ol><p>git branch 分支名 // 新建分支</p><p>git branch // 查看当前所有分支</p><p>git checkout 分支名 // 检出分支</p><p>git checkout -b 分支名 // 创建并切换分支</p><p>git branch -v // 查看分支以及提交hash值和commit信息</p><p>git merge 分支名 // 把该分支的内容合并到现有分支上</p><p>git branch -d 分支名 // 删除分支</p><p>git branch -D 分支名 // 强制删除 若没有其他分支合并就删除 d会提示 D不会</p><p>git branch -m 旧分支名 新分支名 // 修改分支名</p><p>git branch -M 旧分支名 新分支名 // 修改分支名 M强制修改 若与其他分支有冲突也会创建(慎用)</p><p>git branch -r // 列出远程分支(远程所有分支名)</p><p>git branch -a // 查看远程分支(列出远程分支以及本地分支名)</p><p>git fetch // 更新remote索引</p><p>git push -u origin 分支名 // 将本地分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push 也可解决 git建立远程分支关联时出现fatal … upstram的问题</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看提交信息</title>
    <link href="undefined2019/08/18/2019-8-18-fourth-day/"/>
    <url>2019/08/18/2019-8-18-fourth-day/</url>
    
    <content type="html"><![CDATA[<ol><li>查看提交内容</li></ol><p>git hi -5 // 查看前5条内容</p><p>git hi –grep hello // 过滤提交信息里有hello字眼的内容</p><ol start="2"><li>修改文件名以及移动</li></ol><p>git mv a b // 把a文件名字改成b 并且直接放入<br>git add后的暂存区</p><p>git mv b ./demos/ // 把b文件移动到demos文件夹下</p><ol start="3"><li>对比工作区，暂存区，仓库的差异</li></ol><p>git diff // 查看变更 工作区与暂存区的差异比对</p><p>git diff –cached // 暂存区与提交版本的差异</p><p>git diff HEAD // 工作区与仓库中最后一次提交版本的差别</p><p>git diff 版本哈希值 版本哈希值 // 查看这2个版本哈希之间的区别</p><p>或者 git diff HEAD<del>数字 HEAD</del>数字</p><p>git tag tt HEAD~4 给倒数第5次提交打一个tag tag名字是tt</p><p>git diff tt 就是倒数第5个版本与第一个版本之间的差异</p><p>git diff –cached tt 暂存区与倒数第5个版本之间的比对</p><ol start="4"><li>查看提交信息</li></ol><p>git show HEAD // 查看最后一次提交修改的详细信息 也可以用git show 哈希值 查看对应的内容</p><p>git show HEAD^ // 查看倒数第二次的提交修改详细信息</p><p>git show HEAD^^ 或者git show HEAD~2 查看前2次变更</p><p>git show HEAD 或 git show 哈希值 或者git show tag(标签名) 都可以查看最近一次提交的详细信息</p><ol start="5"><li>查看信息</li></ol><p>git log –pretty=format:’%h %ad | %s%d [%an]’ –graph –date=short<br>// 获取git log里的树形详细信息 包括hasg 日期 提交信息 提交人等</p><p>git log –oneline //拉出所有提交信息 q是退出</p><p>git log -5 // 查看前5次的提交记录</p><p>git log –oneline -5 // 打印出的日志里面只有哈希值和修改的内容备注</p><p>git log 文件名 // 查看该文件的提交</p><p>git log –grep // 想过滤看到的内容   过滤日志</p><p>git log -n // 查看近期提交的n条信息内容</p><p>git log -p // 查看详细提交记录</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用git命令</title>
    <link href="undefined2019/08/17/2019-8-17-third-day/"/>
    <url>2019/08/17/2019-8-17-third-day/</url>
    
    <content type="html"><![CDATA[<ol><li>常用git 命令</li></ol><p>git init // 初始化 在工作路径上创建主分支</p><p>git clone 地址 // 克隆远程仓库</p><p>git clone -b 分支名 地址 // 克隆分支的代码到本地</p><p>git status // 查看状态</p><p>git add 文件名 // 将某个文件存入暂存区</p><p>git add b c //把b和c存入暂存区</p><p>git add . // 将所有文件提交到暂存区</p><p>git add -p 文件名 // 一个文件分多次提交</p><p>git stash -u -k // 提交部分文件内容 到仓库 例如本地有3个文件 a b c 只想提交a b到远程仓库 </p><p>git add a b 然后 git stash -u -k 再然后git </p><p>commit -m “备注信息” 然后再push push之后 git stash pop 把之前放入堆栈的c拿出来 继续下一波操作</p><p>git commit -m “提交的备注信息”  // 提交到仓库<br>若已经有若干文件放入仓库，再次提交可以不用git add和git commit -m “备注信息” 这2步， 直接用</p><p>git commit -am “备注信息” // 将内容放至仓库 也可用git commit -a -m “备注信息”</p><p>git commit中的备注信息尽量完善 养成良好提交习惯 例如 git commit -m “变更(范围)：变更的内容”</p><ol start="2"><li>存储密码凭证 设置别名 获取config信息以及配置</li></ol><p>git config –list // 获取config信息</p><p>git config –global core.safecrlf false // 去掉git add 命令后 出现的一堆CR LF提示信息<br>其中CR是回车的意思 LF是换行</p><p>git config –global credential.helper wincred // 存储凭证 (可用于输入一次用户密码后，不再输入 有时我们已经用SSH key 绑定关联好了 但是每次git提交的时候 还是需要你输入用户名密码 在这个时候 敲入这个命令 将凭证存储起来 用户名密码就不需要再次输入了)</p><p>git config –global alias.ci commit // 将commit命令设置别名ci git commit命令将由git ci来代替</p><ol start="3"><li>查看git常用命令</li></ol><p>git helper -a // 查看全部git子命令</p><ol start="4"><li>逐行查看文件的修改历史</li></ol><p>git blame 文件名 // 查看该文件的修改历史</p><p>git blame -L 100,10 文件名 // 从100行开始，到110行 逐行查看文件的修改历史</p><ol start="5"><li>清除</li></ol><p>git clean -n // 列出打算清除的档案(首先会对工作区的内容进行提示)</p><p>git clean -f // 真正的删除</p><p>git clean -x -f // 连.gitignore中忽略的档案也删除</p><p>git status -sb (sb是 short branch) // 简洁的输出git status中的信息</p><ol start="6"><li>删除放入暂存区文件的方法（已commit后）</li></ol><p>git rm 文件名 // 将该文件从commit后撤回到add后<br>g<br>it reset HEAD^ –hard // 删除后 可以用git rm 文件名再回撤一步</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git部分用法</title>
    <link href="undefined2019/08/16/2019-8-16-secend-day/"/>
    <url>2019/08/16/2019-8-16-secend-day/</url>
    
    <content type="html"><![CDATA[<ol><li>强制推送（慎用，除非你认为其他冲突等可以丢弃 或者不是很重要）</li></ol><p>git push – force</p><ol start="2"><li>创建文件等小命令</li></ol><p>touch a // 创建一个a文件</p><p>echo 1234 &gt;&gt; a // 把1234这个内容放入a文件</p><p>cat a // 打开a文件 读取出a文件中的内容</p><p>mkdir test // 创建test文件夹</p><p>rm 文件名 // 删除文件</p><p>pwd // 打印当前工作路径</p><ol start="3"><li>安装git的时候 都会安装git bash和git GUI 我们完全也可以使用git GUI来提交版本 与sourcetree等功能相同</li></ol><p>gitk // 用git命令快速打开git GUI</p><ol start="4"><li>文件信息</li></ol><p>ls // 查看当前路径下面的所有文件名</p><p>ls 文件夹名 // 查看对应文件夹中的内容</p><p>ls -l // 拉出最近git提交记录以及对应修改的文件名</p><p>ls -l -a // 拉出最近git提交记录以及对应修改的文件名，隐藏的文件也会显示</p><ol start="5"><li>cd快速切换路径</li></ol><p>cd ~ // 将工作路径快速切换到root</p><p>cd - // 将工作路径切换到上一状态</p><p>cd ../ // 切回到上一个工作路径</p><p>cd 文件夹名 // 进入某个目录</p><p>cd / // 进入根目录</p><ol start="6"><li>vim模式</li></ol><p>vim 文件名 // 新建一个文件</p><p>i 插入内容</p><p>按下esc :wq 保存并退出</p><p>按下esc :q 直接退出</p><p>vim 模式下 文件中#号开头的为注释</p><p>.project 忽略.project文件<br>*.obj 或者 *.exe 忽略一类文件 例如以.obj<br>.exe 结尾的文件</p><p>git check-ignore -v .project 查看ignore中.project的位置</p>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16日日报</title>
    <link href="undefined2019/08/16/2019-8-16-dd-day/"/>
    <url>2019/08/16/2019-8-16-dd-day/</url>
    
    <content type="html"><![CDATA[<h5 id="HEAD：指向当前的工作路径"><a href="#HEAD：指向当前的工作路径" class="headerlink" title="HEAD：指向当前的工作路径"></a>HEAD：指向当前的工作路径</h5><h5 id="config：当前仓库的配置信息-core-用户-远程-分支等信息"><a href="#config：当前仓库的配置信息-core-用户-远程-分支等信息" class="headerlink" title="config：当前仓库的配置信息,core,用户,远程,分支等信息"></a>config：当前仓库的配置信息,core,用户,远程,分支等信息</h5><h5 id="refs-heads-存放项目所有的分支"><a href="#refs-heads-存放项目所有的分支" class="headerlink" title="refs/heads:  存放项目所有的分支"></a>refs/heads:  存放项目所有的分支</h5><h5 id="refs-tags-存放tag-（tag又名标签）"><a href="#refs-tags-存放tag-（tag又名标签）" class="headerlink" title="refs/tags :    存放tag （tag又名标签）"></a>refs/tags :    存放tag （tag又名标签）</h5><h5 id="objects：存放对象"><a href="#objects：存放对象" class="headerlink" title="objects：存放对象"></a>objects：存放对象</h5>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15日日报</title>
    <link href="undefined2019/08/15/2019-8-15-first-day/"/>
    <url>2019/08/15/2019-8-15-first-day/</url>
    
    <content type="html"><![CDATA[<ul><li>今天学习了使用 git向github上传文件<br></li><li>我特别想整好，但是又拉不下脸面，不好意思问别人<br></li><li>结果无疑是特别悲惨的 白白浪费了一天时间,也没和同学处好关系<br></li><li>所以以后不能死脑筋 <br></li><li>以后要一定快乐阿  张杰<br></li></ul>]]></content>
    
    
    <categories>
      
      <category>8月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日报</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>